<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Syst√®me Synchro 2025-26 v104</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1600px; margin: 0 auto; }
        .header { background: white; border-radius: 15px; padding: 30px; margin-bottom: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); }
        .header h1 { color: #1e3c72; font-size: 2em; }
        .btn { padding: 12px 24px; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 1em; transition: all 0.3s; }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
        .btn-success { background: #4CAF50; color: white; }
        .btn-excel { background: #217346; color: white; }
        .info-box { background: #e3f2fd; border-left: 4px solid #2196F3; padding: 15px; margin: 15px 0; border-radius: 5px; }
        .debug-box { background: #fff3e0; border-left: 4px solid #FF9800; padding: 15px; margin: 15px 0; border-radius: 5px; font-family: monospace; font-size: 0.85em; }
        .competition-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(350px, 1fr)); gap: 20px; margin-top: 20px; }
        .competition-card { background: #f8f9ff; border: 2px solid #e0e0e0; border-radius: 12px; padding: 20px; cursor: pointer; transition: all 0.3s; }
        .competition-card:hover { transform: translateY(-5px); box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3); }
        .competition-name { font-size: 1.2em; font-weight: bold; color: #1e3c72; margin-bottom: 8px; }
        .stat-card { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 10px; text-align: center; }
        .stat-number { font-size: 2.5em; font-weight: bold; }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin: 20px 0; }
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000; overflow-y: auto; padding: 20px; }
        .modal.active { display: block; }
        .modal-content { background: white; border-radius: 15px; padding: 30px; max-width: 1200px; margin: 20px auto; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid #e0e0e0; }
        .modal-header h2 { color: #1e3c72; font-size: 1.8em; }
        /* ONGLETS DE VUE */
        .view-tabs {
            display: flex;
            gap: 5px;
            margin: 20px 0;
            border-bottom: 2px solid #e0e0e0;
            flex-wrap: wrap;
        }
        .view-tab {
            padding: 12px 20px;
            background: #f5f5f5;
            color: #666;
            border: none;
            cursor: pointer;
            font-weight: 600;
            border-radius: 8px 8px 0 0;
            transition: all 0.3s;
        }
        .view-tab:hover {
            background: #e0e0e0;
        }
        .view-tab.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .view-content {
            display: none;
        }
        .view-content.active {
            display: block;
        }
        /* SOUS-ONGLETS */
        .sub-tabs {
            display: flex;
            gap: 5px;
            margin: 15px 0;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 8px;
        }
        .sub-tab {
            padding: 10px 20px;
            background: white;
            color: #666;
            border: 2px solid #e0e0e0;
            cursor: pointer;
            font-weight: 600;
            border-radius: 6px;
            transition: all 0.3s;
        }
        .sub-tab:hover {
            background: #e8eaf6;
        }
        .sub-tab.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }
        .sub-content {
            display: none;
        }
        .sub-content.active {
            display: block;
        }

        /* FONDS COLOR√âS PAR RANG */
        .rank-cell-1 { background: linear-gradient(135deg, #FFD700, #FFA500) !important; color: #000 !important; font-weight: bold; }
        .rank-cell-2 { background: linear-gradient(135deg, #C0C0C0, #A8A8A8) !important; color: #000 !important; font-weight: bold; }
        .rank-cell-3 { background: linear-gradient(135deg, #CD7F32, #B8860B) !important; color: #000 !important; font-weight: bold; }
        .rank-cell-4 { background: #5a4fcf !important; color: white !important; font-weight: bold; }
        .rank-cell-5 { background: #7b6fd9 !important; color: white !important; font-weight: bold; }
        .rank-cell-6 { background: #9c8fe3 !important; color: white !important; }
        .rank-cell-7 { background: #bdafed !important; color: #333 !important; }
        .rank-cell-8plus { background: #decff7 !important; color: #333 !important; }
        /* COULEURS SEMI-TRANSPARENTES POUR TABLEAUX D√âTAILL√âS */
        .rank-cell-1-transparent { background: rgba(255, 215, 0, 0.25) !important; } /* Or transparent */
        .rank-cell-2-transparent { background: rgba(192, 192, 192, 0.25) !important; } /* Argent transparent */
        .rank-cell-3-transparent { background: rgba(205, 127, 50, 0.25) !important; } /* Bronze transparent */
        .rank-cell-4-transparent { background: rgba(90, 79, 207, 0.15) !important; } /* Violet transparent */
        .rank-cell-5-transparent { background: rgba(123, 111, 217, 0.15) !important; }
        .rank-cell-6-transparent { background: rgba(156, 143, 227, 0.15) !important; }
        .rank-cell-7-transparent { background: rgba(189, 175, 237, 0.15) !important; }
        .rank-cell-8plus-transparent { background: rgba(222, 207, 247, 0.12) !important; }
        /* COULEURS PLUS OPAQUES POUR TOTAUX */
        .rank-cell-1-opaque { background: rgba(255, 215, 0, 0.5) !important; } /* Or 50% */
        .rank-cell-2-opaque { background: rgba(192, 192, 192, 0.5) !important; } /* Argent 50% */
        .rank-cell-3-opaque { background: rgba(205, 127, 50, 0.5) !important; } /* Bronze 50% */
        .rank-cell-4-opaque { background: rgba(90, 79, 207, 0.4) !important; }
        .rank-cell-5-opaque { background: rgba(123, 111, 217, 0.4) !important; }
        .rank-cell-6-opaque { background: rgba(156, 143, 227, 0.4) !important; }
        .rank-cell-7-opaque { background: rgba(189, 175, 237, 0.4) !important; }
        .rank-cell-8plus-opaque { background: rgba(222, 207, 247, 0.35) !important; }
        
        /* COULEURS TR√àS OPAQUES POUR TOTAL FINAL */
        .rank-cell-1-very-opaque { background: rgba(255, 215, 0, 0.7) !important; } /* Or 70% */
        .rank-cell-2-very-opaque { background: rgba(192, 192, 192, 0.7) !important; } /* Argent 70% */
        .rank-cell-3-very-opaque { background: rgba(205, 127, 50, 0.7) !important; } /* Bronze 70% */
        .rank-cell-4-very-opaque { background: rgba(90, 79, 207, 0.6) !important; }
        .rank-cell-5-very-opaque { background: rgba(123, 111, 217, 0.6) !important; }
        .rank-cell-6-very-opaque { background: rgba(156, 143, 227, 0.6) !important; }
        .rank-cell-7-very-opaque { background: rgba(189, 175, 237, 0.6) !important; }
        .rank-cell-8plus-very-opaque { background: rgba(222, 207, 247, 0.55) !important; }




        .close-btn { background: #f44336; color: white; border: none; padding: 8px 20px; border-radius: 8px; cursor: pointer; font-weight: 600; }
        .cat-section { margin: 20px 0; padding: 20px; background: #f8f9ff; border-radius: 10px; }
        .cat-title { font-size: 1.2em; font-weight: bold; color: #1e3c72; margin-bottom: 15px; }
        .prog-section { margin: 15px 0; padding: 15px; background: white; border-radius: 8px; border: 2px solid #e0e0e0; }
        .prog-title { font-weight: 600; color: #667eea; margin-bottom: 10px; }
        .btn-primary { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
        .btn-small { padding: 6px 12px; font-size: 0.85em; }
        .success-box { background: #e8f5e9; border-left: 4px solid #4CAF50; padding: 10px; margin: 10px 0; border-radius: 5px; color: #2e7d32; }
        
        /* Styles pour l'affichage d√©taill√© */
        .team-section { margin: 30px 0; border: 2px solid #e0e0e0; border-radius: 15px; overflow: hidden; box-shadow: 0 4px 15px rgba(0,0,0,0.1); }
        .team-header-detailed { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; }
        .team-title-detailed { font-size: 1.5em; margin-bottom: 15px; }
        .team-scores { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; }
        .score-box { background: rgba(255,255,255,0.2); padding: 12px; border-radius: 8px; }
        .score-box .label { font-size: 0.8em; opacity: 0.9; margin-bottom: 4px; }
        .score-box .value { font-size: 1.3em; font-weight: bold; }
        .score-box .rank { font-size: 0.9em; opacity: 0.95; margin-top: 2px; }
        
        table { width: 100%; border-collapse: collapse; background: white; }
        thead { background: #f5f5f5; border-bottom: 2px solid #667eea; }
        th { padding: 12px 10px; text-align: center; font-weight: 600; font-size: 0.9em; color: #1e3c72; }
        th.text-left { text-align: left; }
        td { padding: 12px 10px; text-align: center; border-bottom: 1px solid #f0f0f0; }
        td.text-left { text-align: left; font-weight: 600; }
        
        .element-row { background: white; }
        .element-row:hover { background: #f8f9ff; }
        
        .judge-rank-row { background: #fafafa; font-size: 0.9em; border-bottom: 2px solid #e0e0e0 !important; }
        .judge-rank-row td { padding: 8px 10px; font-style: italic; color: #666; }
        
        .total-row { background: #e8eaf6; font-weight: bold; border-top: 3px solid #667eea !important; border-bottom: 3px solid #667eea !important; }
        .total-row td { padding: 15px 10px; font-size: 1.05em; }
        
        .rank-row { background: #f5f5f5; font-weight: 600; border-bottom: 3px solid #667eea !important; }
        .rank-row td { padding: 12px 10px; }
        
        .rank-badge { display: inline-block; background: #667eea; color: white; padding: 4px 10px; border-radius: 12px; font-weight: bold; font-size: 0.9em; }
        .rank-1 .rank-badge, .rank-badge.rank-1 { background: linear-gradient(135deg, #FFD700, #FFA500); }
        .rank-2 .rank-badge, .rank-badge.rank-2 { background: linear-gradient(135deg, #C0C0C0, #A8A8A8); }
        .rank-3 .rank-badge, .rank-badge.rank-3 { background: linear-gradient(135deg, #CD7F32, #B8860B); }
        
        .element-code { font-family: 'Monaco', 'Courier New', monospace; background: #e8eaf6; padding: 4px 8px; border-radius: 4px; font-weight: bold; color: #1e3c72; }
        .level-badge { display: inline-block; background: #4caf50; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.85em; margin-left: 5px; }
        .fall-badge { display: inline-block; background: #f44336; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.75em; margin-left: 5px; }
        
        .number { font-family: 'Monaco', 'Courier New', monospace; }
        .positive { color: #4caf50; }
        .negative { color: #f44336; }
        .goe-zero { color: #000000; }
        
        .rank-better, .judge-rank-row td.rank-better, .rank-row td.rank-better { color: #2e7d32 !important; font-weight: 900 !important; font-style: normal !important; }
        .rank-worse, .judge-rank-row td.rank-worse, .rank-row td.rank-worse { color: #c62828 !important; font-weight: 900 !important; font-style: normal !important; }
        .rank-equal, .judge-rank-row td.rank-equal, .rank-row td.rank-equal { color: #000000 !important; font-weight: 700 !important; font-style: normal !important; }
        
        .rank-better-header { color: #2e7d32; font-weight: bold; }
        .rank-worse-header { color: #c62828; font-weight: bold; }
        .rank-equal-header { color: #ffffff; font-weight: normal; }
        
        .section-title { background: #f5f5f5; padding: 15px 30px; border-top: 2px solid #e0e0e0; font-weight: bold; color: #1e3c72; font-size: 1.1em; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header" style="text-align:center;padding:30px 20px;">
            <div style="display:inline-flex;align-items:center;gap:20px;">
                <div style="font-size:4em;filter:drop-shadow(2px 2px 4px rgba(0,0,0,0.2));">‚õ∏Ô∏è</div>
                <div>
                    <h1 style="margin:0;font-size:3em;background:linear-gradient(135deg, #667eea 0%, #764ba2 100%);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;font-weight:800;letter-spacing:2px;">SynchroStats</h1>
                    <p style="margin:5px 0 0 0;color:#666;font-size:1.1em;font-weight:500;">Season 2025-26 Analysis</p>
                </div>
            </div>
        </div>
        
        
        
        <div style="margin-bottom:20px;">
            <button class="btn btn-success" onclick="switchTab('calendar')" style="margin-right:10px;">üìÖ Calendar</button>
            <button class="btn" style="background:#667eea;color:white;" onclick="switchTab('classement')">üèÜ Rankings</button>
            <button class="btn" style="background:#667eea;color:white;" onclick="switchTab('comparaisons')">üìä Comparisons</button>
            <button class="btn" style="background:#667eea;color:white;" onclick="switchTab('statistiques')">üìà Statistics</button>
            <button class="btn" style="background:#667eea;color:white;" onclick="switchTab('settings')">‚öôÔ∏è Settings</button>
            <button class="btn" style="background:#FF9800;color:white;" onclick="afficherDebug()">üîç Debug</button>
        </div>
        
        <div id="debugInfo" class="debug-box" style="display:none;"></div>
        
        <div id="tab-calendar">
        
        <div style="margin-bottom: 20px;">
            <button class="btn btn-success" onclick="chargerCalendrier()">üìã Load calendar</button>
            <button class="btn btn-primary" onclick="ajouterCompetition()" style="margin-left: 10px;">‚ûï Add competition</button>
        </div>
        
        <div style="display: flex; gap: 15px; margin: 30px 0; flex-wrap: wrap;">
            <div style="flex: 1; min-width: 200px;">
                <label style="display: block; font-weight: 600; margin-bottom: 5px; color: #1e3c72;">üîç Search</label>
                <input type="text" id="search" placeholder="Name..." onkeyup="afficher()" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px;">
            </div>
            <div style="flex: 1; min-width: 200px;">
                <label style="display: block; font-weight: 600; margin-bottom: 5px; color: #1e3c72;">üåç Country</label>
                <select id="pays" onchange="afficher()" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px;">
                    <option value="">All</option>
                </select>
            </div>
            <div style="flex: 1; min-width: 250px;">
                <label style="display: block; font-weight: 600; margin-bottom: 5px; color: #1e3c72;">üéØ Filter</label>
                <label style="display: flex; align-items: center; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; background: white; cursor: pointer;">
                    <input type="checkbox" id="showAllCompetitions" onchange="afficher()" style="margin-right: 10px; width: 18px; height: 18px; cursor: pointer;">
                    <span style="font-size: 0.95em;">Show all competitions (including National and Regional)</span>
                </label>
            </div>
        </div>
        
        <div class="competition-grid" id="grid"></div>
        
        </div>  <!-- Fin de tab-calendar -->
        
        <div id="tab-comparaisons" style="display:none;">
            <!-- Contenu g√©n√©r√© par afficherComparaisons() -->
        </div>
        
        <div id="tab-classement" style="display:none;">
            <h2 style="color: #1e3c72; margin-bottom: 20px;">üèÜ Season Rankings</h2>
            
            <div style="background:white;padding:20px;border-radius:10px;margin-bottom:20px;">
                <h3 style="color:#1e3c72;margin-top:0;">Filters</h3>
                
                <div style="margin-bottom:15px;">
                    <strong>Category:</strong><br>
                    <label style="display:inline-block;margin-right:15px;">
                        <input type="checkbox" id="filter-senior" checked onchange="afficherClassement()"> Senior
                    </label>
                    <label style="display:inline-block;margin-right:15px;">
                        <input type="checkbox" id="filter-junior" checked onchange="afficherClassement()"> Junior
                    </label>
                </div>
                
                <div style="margin-bottom:15px;">
                    <strong>Competition Type:</strong><br>
                    <label style="display:inline-block;margin-right:15px;">
                        <input type="checkbox" id="filter-regional" checked onchange="afficherClassement()"> üü£ Regional
                    </label>
                    <label style="display:inline-block;margin-right:15px;">
                        <input type="checkbox" id="filter-national" checked onchange="afficherClassement()"> üîµ National
                    </label>
                    <label style="display:inline-block;margin-right:15px;">
                        <input type="checkbox" id="filter-challenger" checked onchange="afficherClassement()"> üü† Challenger
                    </label>
                    <label style="display:inline-block;margin-right:15px;">
                        <input type="checkbox" id="filter-international" checked onchange="afficherClassement()"> üü¢ International
                    </label>
                </div>
                
                <div style="margin-bottom:15px;">
                    <strong>Program:</strong><br>
                    <label style="margin-right:15px;">
                        <input type="radio" name="classement-programme" value="total" checked onchange="afficherClassement()"> Total Competition (PC+PL)
                    </label>
                    <label style="margin-right:15px;">
                        <input type="radio" name="classement-programme" value="PC" onchange="console.log('Radio PC cliqu√©'); afficherClassement()"> Short Program only
                    </label>
                    <label>
                        <input type="radio" name="classement-programme" value="PL" onchange="console.log('Radio PL cliqu√©'); afficherClassement()"> Free Program only
                    </label>
                </div>
                
                <div style="margin-bottom:15px;">
                    <strong>Display:</strong><br>
                    <label>
                        <input type="radio" name="classement-mode" value="best" checked onchange="afficherClassement()"> Best result per team
                    </label>
                    <label style="margin-left:20px;">
                        <input type="radio" name="classement-mode" value="all" onchange="afficherClassement()"> All results
                    </label>
                </div>
            </div>
            
            <div id="classement-content"></div>
        </div>
        
        <div id="tab-statistiques" style="display:none;">
            <!-- Contenu g√©n√©r√© par afficherStatistiques() -->
        </div>
        
        <div id="tab-settings" style="display:none;">
            <h2 style="color: #1e3c72; margin-bottom: 20px;">‚öôÔ∏è Settings</h2>
            
            <h3 style="color:#1e3c72;margin-top:20px;display:none;">üè∑Ô∏è Format des noms d'√©quipes</h3>
            <div style="padding:20px;background:#f8f9ff;border-radius:10px;margin-bottom:20px;display:none;">
                <div style="display:flex;align-items:center;margin-bottom:15px;">
                    <input type="checkbox" id="standardiserCheckbox" onchange="toggleStandardisation()" style="width:20px;height:20px;margin-right:10px;">
                    <label for="standardiserCheckbox" style="font-weight:600;font-size:1.1em;">Standardiser les noms au format ISU international</label>
                </div>
                <div class="info-box" style="margin:0;">
                    <strong>üìã Format ISU :</strong><br>
                    <ul style="margin-top:10px;margin-left:20px;">
                        <li><strong>Senior :</strong> Team [Nom]<br>
                            <em>Ex: "Dream Edges" (Kaari) ‚Üí "Team Dream Edges" (FIN)</em></li>
                        <li><strong>Junior :</strong> Team [Nom] Junior<br>
                            <em>Ex: "Dream Edges" (Kaari) ‚Üí "Team Dream Edges Junior" (FIN)</em></li>
                    </ul>
                    <p style="margin-top:10px;"><strong>üéØ Conversion automatique :</strong></p>
                    <ul style="margin-left:20px;">
                        <li>Les codes clubs nationaux (Kaari, HL, ESS, HTK, etc.) sont automatiquement convertis en codes pays (FIN, USA, CAN, etc.)</li>
                        <li>La nationalit√© s'affiche entre parenth√®ses : "Team Helsinki Rockettes (FIN)"</li>
                        <li>Le nom reste propre et professionnel, sans suffixe de club</li>
                    </ul>
                </div>
            </div>
            
            <h3 style="color:#1e3c72;margin-top:30px;">üóÉÔ∏è Base de donn√©es d'√©quipes</h3>
            <div style="padding:20px;background:#f8f9ff;border-radius:10px;margin-bottom:20px;">
                <div class="info-box" style="margin-bottom:15px;">
                    <strong>üìä √âquipes reconnues :</strong> <span id="nbEquipesDB">0</span> √©quipes dans la base<br>
                    <strong>üéØ D√©tection automatique :</strong> Le syst√®me reconna√Æt automatiquement les √©quipes et trouve leur pays
                </div>
                
                <button class="btn btn-primary" onclick="afficherListeEquipes()">üìã Voir toutes les √©quipes</button>
                <button class="btn btn-success" onclick="ajouterEquipeManuelle()" style="margin-left:10px;">‚ûï Ajouter une √©quipe</button>
                
                <div id="liste-equipes" style="display:none;margin-top:20px;max-height:400px;overflow-y:auto;">
                    <!-- Liste des √©quipes sera affich√©e ici -->
                </div>
            </div>
            
            <h3 style="color:#1e3c72;margin-top:30px;">‚úèÔ∏è √âditeur d'√©quipes dans les r√©sultats</h3>
            <div id="gestion-equipes" style="padding:20px;background:#f8f9ff;border-radius:10px;margin-bottom:20px;">
                <div class="info-box" style="margin-bottom:15px;">
                    <strong>üéØ Corriger les noms/nations ou supprimer des √©quipes mal pars√©es</strong><br>
                    S√©lectionnez une comp√©tition pour voir et √©diter ses √©quipes.
                </div>
                
                <div style="margin-bottom:15px;">
                    <label style="font-weight:600;">Competition :</label>
                    <select id="editeurCompSelect" onchange="editeurChargerResultats()" style="margin-left:10px;padding:8px;border-radius:6px;border:1px solid #ccc;min-width:300px;">
                        <option value="">-- Choose une comp√©tition --</option>
                    </select>
                </div>
                
                <div id="editeurResultatSelect" style="display:none;margin-bottom:15px;">
                    <label style="font-weight:600;">Program:</label>
                    <select id="editeurProgSelect" onchange="editeurChargerEquipes()" style="margin-left:10px;padding:8px;border-radius:6px;border:1px solid #ccc;">
                        <option value="">-- Choose --</option>
                    </select>
                </div>
                
                <div id="editeurTableEquipes" style="display:none;margin-top:15px;"></div>
            </div>
            
            <h3 style="color:#1e3c72;margin-top:30px;">üîß Migration des donn√©es</h3>
            <div style="padding:20px;background:#fff3e0;border-radius:10px;margin-bottom:20px;">
                <div class="info-box" style="margin-bottom:15px;background:#e3f2fd;border-left-color:#2196F3;">
                    <strong>üîÑ Correction automatique des donn√©es</strong><br>
                    Cliquez sur ce bouton pour mettre √† jour automatiquement TOUS vos r√©sultats existants.
                    <br><br>
                    <strong>‚ö° Cette op√©ration va :</strong>
                    <ul style="margin-left:20px;margin-top:10px;">
                        <li><strong>Corriger les rangs :</strong> Trie les √©quipes par score et recalcule les rangs (1, 2, 3, etc.)</li>
                        <li><strong>Convertir les codes de programme :</strong> SP ‚Üí PC, FS ‚Üí PL (pour afficher correctement les r√©sultats)</li>
                        <li>S'applique √† tous vos r√©sultats d√©j√† analys√©s</li>
                        <li>Ne n√©cessite PAS de r√©-analyser les PDFs</li>
                    </ul>
                    <br>
                    <strong>üéØ √Ä faire une seule fois !</strong> Apr√®s cette migration, vos competitions s'afficheront correctement.
                </div>
                <button class="btn btn-primary" onclick="migrerRangs()" style="font-size:1.1em;padding:15px 30px;">
                    üîÑ Migrer tous les r√©sultats (rangs + codes)
                </button>
                <div id="migration-status" style="margin-top:15px;"></div>
            </div>
            
            <h3 style="color:#1e3c72;margin-top:30px;">üìÅ Export & Sauvegarde</h3>
            <button class="btn btn-success" onclick="telechargerPage()">üíæ T√©l√©charger cette page HTML</button>
            <button class="btn btn-excel" onclick="exporterToutExcel()" style="margin-left:10px;">üìä Exporter TOUT vers Excel</button>
            <button class="btn btn-success" onclick="exportData()" style="margin-left:10px;">üì§ Exporter les donn√©es JSON</button>
            <button class="btn btn-primary" onclick="document.getElementById('importFileInput').click()" style="margin-left:10px;">üì• Importer des donn√©es JSON</button>
            <input type="file" id="importFileInput" accept=".json" style="display:none;" onchange="importData(event)">
            <button class="btn" style="background:#f44336;color:white;margin-left:10px;" onclick="clearData()">üóëÔ∏è Tout effacer</button>
            
            <div class="info-box" style="margin-top:20px;">
                <strong>üíæ Sauvegarde JSON :</strong><br>
                <strong>Export :</strong> T√©l√©charge un fichier JSON avec TOUTES vos donn√©es (r√©sultats + competitions + fusions).<br>
                <strong>Import :</strong> Restaure vos donn√©es depuis un fichier JSON. ‚ö†Ô∏è Cela REMPLACE les donn√©es actuelles !
            </div>
            
            <div class="info-box" style="margin-top:20px;">
                <strong>üí° Export Excel :</strong><br>
                Cliquez sur "üìä Exporter TOUT vers Excel" pour g√©n√©rer un fichier Excel contenant TOUTES vos competitions analys√©es avec :
                <ul style="margin-top:10px;margin-left:20px;">
                    <li>Un onglet "Summary" avec vue d'ensemble</li>
                    <li>Un onglet par comp√©tition avec r√©sultats d√©taill√©s</li>
                    <li>Codes couleur : üü¢ Vert = meilleur que le rang g√©n√©ral, üî¥ Rouge = moins bon</li>
                </ul>
            </div>
            
            <div class="info-box" style="margin-top:20px;">
                <strong>üí° T√©l√©charger la page :</strong><br>
                Cliquez sur "üíæ T√©l√©charger cette page HTML" pour sauvegarder l'application compl√®te sur votre iPad. 
                Vous pourrez ensuite l'ouvrir avec Safari m√™me sans connexion internet !
            </div>
        </div>
    </div>
    
    <div id="modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle"></h2>
                <button class="close-btn" onclick="fermerModal()">‚úï Close</button>
            </div>
            <div id="modalBody"></div>
        </div>
    </div>

    <script>
        function logVisible(msg) {
            const content = document.getElementById('debug-content');
            if (content) {
                const time = new Date().toLocaleTimeString();
                content.innerHTML += `<div>${time} - ${msg}</div>`;
                content.scrollTop = content.scrollHeight;
            }
            console.log(msg);
        }


        // Calculer le score technique pour un juge sp√©cifique
        function calculateTechScoreForJudge(elements, judgeIndex) {
            let total = 0;
            elements.forEach(el => {
                const judgeGOE = el.juges[judgeIndex];
                // √âchelle GOE bas√©e sur le BV
                const goeScale = el.bv * 0.1; // Approximation simple
                const elementScore = el.bv + (judgeGOE * goeScale);
                total += elementScore;
            });
            return total;
        }

        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        const cal = [
            {d:"05-oct",l:"Helsinki",p:"FIN",n:"Synchro Tour - stage 1",t:"National"},
            {d:"22-25 Oct",l:"Boondall",p:"AUS",n:"QFSC 2025",t:"National"},
            {d:"6-9 Nov",l:"Ste-Marie",p:"CAN",n:"Ch. Qu√©bec",t:"Regional"},
            {d:"7-9 Nov",l:"Berlin",p:"GER",n:"GoBer Berliner",t:"National"},
            {d:"7-9 Nov",l:"Irvine",p:"USA",n:"Fall Classic",t:"National"},
            {d:"8-9 Nov",l:"Tikkurila",p:"FIN",n:"Synchro Tour 1st",t:"National"},
            {d:"8-9 Nov",l:"Lyon",p:"FRA",n:"Masters Synchro",t:"National"},
            {d:"8-9 Nov",l:"Kungsbacka",p:"SWE",n:"Synkropokal",t:"National"},
            {d:"10-11 Nov",l:"Trento",p:"ITA",n:"Trento Cup",t:"National"},
            {d:"14-15 Nov",l:"London",p:"GBR",n:"Skate London",t:"National"},
            {d:"15-16 Nov",l:"Budapest",p:"HUN",n:"Test Comp",t:"National"},
            {d:"21-23 Nov",l:"Norwood",p:"USA",n:"Boston Classic",t:"National"},
            {d:"28-29 Nov",l:"Rouen",p:"FRA",n:"French Cup",t:"International"},
            {d:"28-5 Dec",l:"Boondall",p:"AUS",n:"Australian Ch.",t:"National"},
            {d:"5-7 Dec",l:"Dumfries",p:"GBR",n:"Trophy D'Ecosse",t:"National"},
            {d:"6 Dec",l:"Jihlava",p:"CZE",n:"Jihlavsky Jezek",t:"National"},
            {d:"6-7 Dec",l:"Boras",p:"SWE",n:"Knalletrofen",t:"National"},
            {d:"6-7 Dec",l:"Tampere",p:"FIN",n:"Synchro Tour 2nd",t:"National"},
            {d:"8 Dec",l:"Aosta",p:"ITA",n:"1¬∞ Gara Naz",t:"National"},
            {d:"8-13 Dec",l:"Oberstdorf",p:"GER",n:"German Ch.",t:"National"},
            {d:"11-14 Dec",l:"Jaca",p:"ESP",n:"Spain Ch.",t:"National"},
            {d:"11-14 Dec",l:"Innsbruck",p:"AUT",n:"Open Austrian",t:"National"},
            {d:"12-14 Dec",l:"Brno",p:"CZE",n:"Santa Claus Cup",t:"International"},
            {d:"12-14 Dec",l:"Woodstock",p:"CAN",n:"Synchro Series 1",t:"National"},
            {d:"20-21 Dec",l:"Gdansk",p:"POL",n:"Polish Ch.",t:"National"},
            {d:"8-9 Jan",l:"Gatineau",p:"CAN",n:"Canadian Ch.",t:"National"},
            {d:"9-10 Jan",l:"Nottingham",p:"GBR",n:"Britania Cup",t:"Challenger Series"},
            {d:"9-10 Jan",l:"Dresden",p:"GER",n:"Dresden Cup",t:"International"},
            {d:"10-11 Jan",l:"Ankara",p:"TUR",n:"Turkish Ch.",t:"National"},
            {d:"11-12 Jan",l:"Zagreb",p:"CRO",n:"Croatian Ch.",t:"National"},
            {d:"15-18 Jan",l:"Ankara",p:"TUR",n:"Anatolian Cup",t:"International"},
            {d:"15-17 Jan",l:"Gdansk",p:"POL",n:"Hevelius Cup",t:"International"},
            {d:"16-18 Jan",l:"Sesto SG",p:"ITA",n:"Sprint Cup",t:"International"},
            {d:"22-24 Jan",l:"Eindhoven",p:"NED",n:"Lumi√®re Cup",t:"Challenger Series"},
            {d:"23-24 Jan",l:"Salzburg",p:"AUT",n:"Mozartcup",t:"International"},
            {d:"29-30 Jan",l:"Madrid",p:"ESP",n:"Absoluto Open",t:"National"},
            {d:"30-31 Jan",l:"Norwood",p:"USA",n:"US Intl Classic",t:"Challenger Series"},
            {d:"31-1 Feb",l:"Huttwil",p:"SUI",n:"SYS Trophy",t:"International"},
            {d:"31-1 Feb",l:"Gothenburg",p:"SWE",n:"Leon Lurje",t:"International"},
            {d:"1 Feb",l:"Pinerolo",p:"ITA",n:"2¬∞ Gara Naz",t:"National"},
            {d:"7-8 Feb",l:"Turku",p:"FIN",n:"Marie Lundmark",t:"Challenger Series"},
            {d:"7-8 Feb",l:"Budapest",p:"HUN",n:"UTE Cup",t:"International"},
            {d:"12-15 Feb",l:"Riga",p:"LAT",n:"Amber Cup",t:"International"},
            {d:"14-15 Feb",l:"Trento",p:"ITA",n:"Italian Ch.",t:"National"},
            {d:"16 Feb",l:"Helsinki",p:"FIN",n:"Synchro Tour 4",t:"National"},
            {d:"19 Feb",l:"Nottingham",p:"GBR",n:"British Ch.",t:"National"},
            {d:"21-22 Feb",l:"Aby",p:"SWE",n:"Swedish Ch.",t:"National"},
            {d:"28-1 Mar",l:"Koprivnice",p:"CZE",n:"Czech Ch.",t:"National"},
            {d:"28-1 Mar",l:"Budapest",p:"HUN",n:"Budapest Cup",t:"International"},
            {d:"28-1 Mar",l:"Widnau",p:"SUI",n:"SwissCup",t:"International"},
            {d:"28-1 Mar",l:"Turku",p:"FIN",n:"Finnish Ch.",t:"National"},
            {d:"4-7 Mar",l:"Salt Lake",p:"USA",n:"US Ch.",t:"National"},
            {d:"6-7 Mar",l:"Neuchatel",p:"SUI",n:"Neuchatel",t:"International"},
            {d:"7 Mar",l:"Kungalv",p:"SWE",n:"Kungalvspokalen",t:"National"},
            {d:"7-9 Mar",l:"Sheffield",p:"GBR",n:"Steel City",t:"International"},
            {d:"13-14 Mar",l:"Gdansk",p:"POL",n:"ISU WJSYSC",t:"Ch. du Monde J"},
            {d:"21 Mar",l:"Basel",p:"SUI",n:"Basilea",t:"International"},
            {d:"28-29 Mar",l:"Sesto SG",p:"ITA",n:"Easter Trophy",t:"International"},
            {d:"10-11 Apr",l:"Salzburg",p:"AUT",n:"ISU WSYSC",t:"Ch. du Monde"}
        ];

        let liste = [
        {
                "id": "1770193211192.6118",
                "d": "05-oct",
                "l": "Helsinki",
                "p": "FIN",
                "n": "Synchro Tour - stage 1",
                "t": "National"
        },
        {
                "id": "1770193211192.8843",
                "d": "22-25 Oct",
                "l": "Boondall",
                "p": "AUS",
                "n": "QFSC 2025",
                "t": "National"
        },
        {
                "id": "1770193211192.0671",
                "d": "6-9 Nov",
                "l": "Ste-Marie",
                "p": "CAN",
                "n": "Ch. Qu√©bec",
                "t": "Regional"
        }
        ];
        let resultats = [];
        // SUPPRIM√â : Syst√®me de fusions d'√©quipes (plus n√©cessaire gr√¢ce √† la d√©tection intelligente)
        
        const DB_COMPS = 'synchro_v2_comps';
        const DB_RES = 'synchro_v2_resultats';
        
        // BASE DE DONN√âES DES √âQUIPES INTERNATIONALES
        // G√©n√©r√©e automatiquement √† partir de la liste officielle
        const equipesInternationales = {
            // Senior
            "Unique": "FIN",
            "Les Supr√™mes": "CAN",
            "Helsinki Rockettes": "FIN",
            "Nova": "CAN",
            "Haydenettes": "USA",
            "Lumineers": "FIN",
            "Ice On Fire": "ITA",
            "Marigold IceUnity": "FIN",
            "Marigold Ice Unity": "FIN", // Variante avec espace
            "Inspire": "SWE",
            "Nexxice": "CAN",
            "Miami University": "USA",
            "Berlin 1": "GER",
            "Skyliners": "USA",
            "Teams Elite": "USA",
            "Hot Shivers": "ITA",
            "Ice Fire": "POL",
            "Icicles": "GBR",
            "Skating Graces": "GER",
            "United Angels": "GER",
            "Passion": "HUN",
            "Olympia": "CZE",
            "Starlight Elite": "SUI",
            "Ice United": "NED",
            "Unity": "AUS",
            "Cool Dreams": "SUI",
            "Zoulous": "FRA",
            "Ice Storm": "AUS",
            "Trine University": "USA",
            "Hayden Select": "USA",
            "Jeanne d'Arc Elite 12": "FRA",
            "Fusion Elite 12": "ESP",
            "Colibri Vienna": "AUT",
            "Bosphorus": "TUR",
            "Halley Elite 12": "ESP",
            "Celestia": "TUR",
            
            // Junior (sans le suffixe Junior)
            "Helsinki Fintastic": "FIN",
            "Dream Edges": "FIN",
            "Musketeers": "FIN",
            "Valley Bay Synchro": "FIN",
            "Spirit": "SWE",
            "Lexettes": "USA",
            "Mystique": "FIN",
            "Image": "USA",
            "Northernettes": "USA",
            "Seaside": "SWE",
            "Reflections": "FIN",
            "Berlin": "GER", // Team Berlin Juniors
            "Fond Du Lac Blades": "USA",
            "Dc Edge": "USA",
            "Moonlights": "SWE",
            "Ice Ignite": "CAN",
            "Crystallettes": "USA",
            "Prima": "CAN",
            "Festa Aboensia": "FIN",
            "Hockettes": "USA",
            "Gold Ice": "CAN",
            "FireBlades": "FIN",
            "Sun City Swing": "FIN",
            "Stella Polaris": "FIN",
            "Kometa": "CZE",
            "Starlight": "SUI",
            "Ladybirds": "ITA",
            "Ice Steps": "FIN",
            "Jeanne d'Arc": "FRA",
            "Le Soleil": "POL",
            "Harmonia": "CZE",
            "Ice Infinity": "FIN",
            "Ice Fusion": "FIN",
            "Eternity": "SWE",
            "Berlin": "GER",
            "Lower Mainland": "CAN",
            "Estreija": "FIN",
            "UTE Synchro": "HUN",
            "Southern Sky": "AUS",
            "Iceskateers Elite": "AUS",
            "Mirum": "ESP",
            "Ice Diamonds": "FIN",
            "Majestic Ice": "AUS",
            "Elite": "TUR",
            "Solent Storm": "GBR",
            "Odyss√©e": "FRA",
            "Halo": "SWE",
            "Ice Dancing Flames": "POL",
            "Ph≈ìnix": "AUS",
            "Phoenix": "AUS", // Variante sans ≈ì
            "Infusion": "AUS",
            "Munich Destiny": "GER",
            "Vizyon": "TUR",
            "Ice Sparkles": "ITA",
            "Diamonds": "EST",
            "Illuminettes": "NED",
            "Golden Roses": "TUR",
            "Eclipse": "AUS",
            "Sweet Mozart": "AUT",
            "Pingvin": "HUN"
        };
        
        // Mapping des codes clubs nationaux vers codes pays (3 lettres)
        const clubVersPays = {
            // Finlande
            'Kaari': 'FIN', 'HL': 'FIN', 'EsJt': 'FIN', 'HSK': 'FIN', 'ETK': 'FIN', 'TRT': 'FIN', 
            'HTK': 'FIN', 'VG-62': 'FIN', 'EVT': 'FIN', 'TapTL': 'FIN', 'TTK': 'FIN', 'OLK': 'FIN',
            'KuLS': 'FIN', 'LTL': 'FIN', 'JyTLS': 'FIN', 'VSJT': 'FIN', 'TuTS': 'FIN', 'PSS': 'FIN',
            'MJT': 'FIN', 'HSJT': 'FIN', 'PoJT': 'FIN', 'SSL': 'FIN', 'JoJT': 'FIN', 'KTL': 'FIN',
            'MLT': 'FIN', 'EsTL': 'FIN', 'PoriTa': 'FIN', 'Ii': 'FIN', 'RiL': 'FIN',
            'ESS': 'FIN', 'EsS': 'FIN', // Espoo Skating School
            'VG': 'FIN', 'VG62': 'FIN', // Vantaa
            'Tap': 'FIN', 'TapT': 'FIN', 'TapL': 'FIN', // Tampere
            'JTLS': 'FIN', 'JyT': 'FIN', // Jyv√§skyl√§
            'KuL': 'FIN', 'Ku': 'FIN', // Kuopio
            
            // Su√®de
            'SKK': 'SWE', 'Gra': 'SWE', 'Mal': 'SWE', 'G√∂t': 'SWE', 'Lyn': 'SWE',
            'Sto': 'SWE', 'V√§s': 'SWE', 'Lin': 'SWE', 'Upp': 'SWE',
            
            // Allemagne
            'BER': 'GER', 'MUC': 'GER', 'HAM': 'GER', 'DOR': 'GER', 'DRE': 'GER',
            
            // Italie
            'MIL': 'ITA', 'ROM': 'ITA', 'TOR': 'ITA', 'BOL': 'ITA', 'FIR': 'ITA',
            
            // Royaume-Uni
            'LON': 'GBR', 'SOL': 'GBR', 'MAN': 'GBR', 'EDI': 'GBR',
            
            // Codes pays standards (d√©j√† √† 3 lettres)
            'FIN': 'FIN', 'SWE': 'SWE', 'GER': 'GER', 'ITA': 'ITA', 'GBR': 'GBR',
            'FRA': 'FRA', 'ESP': 'ESP', 'SUI': 'SUI', 'AUT': 'AUT', 'NED': 'NED', 
            'POL': 'POL', 'CZE': 'CZE', 'HUN': 'HUN', 'TUR': 'TUR', 'EST': 'EST',
            'USA': 'USA', 'CAN': 'CAN', 'AUS': 'AUS', 'NZL': 'NZL',
            'JPN': 'JPN', 'CHN': 'CHN', 'KOR': 'KOR'
        };
        
        // MAPPING EXHAUSTIF DE TOUS LES √âL√âMENTS - Plus fiable que les regex !
        // Chaque code d'√©l√©ment ‚Üí sa cat√©gorie
        const elementMapping = {
            // AX - √âl√©ments artistiques
            "ABB": "AX", "AB1": "AX", "AB2": "AX",
            "ACB": "AX", "AC1": "AX", "AC2": "AX",
            "ALB": "AX", "AL1": "AX", "AL2": "AX",
            "AWB": "AX", "AW1": "AX", "AW2": "AX",
            
            // CrI - Creative Intersection
            "CrIB": "CrI", "CrI1": "CrI",
            
            // CrL - Creative Line
            "CrLB": "CrL", "CrL1": "CrL",
            
            // GL - Group Lift
            "GLB": "GL", "GL1": "GL", "GL2": "GL", "GL3": "GL", "GL4": "GL",
            
            // I+pi - Intersection (25 combinaisons possibles : 5 niveaux I √ó 5 niveaux pi)
            "IB+piB": "I+pi", "IB+pi1": "I+pi", "IB+pi2": "I+pi", "IB+pi3": "I+pi", "IB+pi4": "I+pi",
            "I1+piB": "I+pi", "I1+pi1": "I+pi", "I1+pi2": "I+pi", "I1+pi3": "I+pi", "I1+pi4": "I+pi",
            "I2+piB": "I+pi", "I2+pi1": "I+pi", "I2+pi2": "I+pi", "I2+pi3": "I+pi", "I2+pi4": "I+pi",
            "I3+piB": "I+pi", "I3+pi1": "I+pi", "I3+pi2": "I+pi", "I3+pi3": "I+pi", "I3+pi4": "I+pi",
            "I4+piB": "I+pi", "I4+pi1": "I+pi", "I4+pi2": "I+pi", "I4+pi3": "I+pi", "I4+pi4": "I+pi",
            
            // ME - Move Element
            "MEB": "ME", "ME1": "ME", "ME2": "ME", "ME3": "ME", "ME4": "ME",
            
            // PB - Pivot Block
            "PBB": "PB", "PB1": "PB", "PB2": "PB", "PB3": "PB", "PB4": "PB",
            
            // Pa - Pair Element
            "PaB": "Pa", "Pa1": "Pa", "Pa2": "Pa", "Pa3": "Pa", "Pa4": "Pa",
            
            // SySp - Synchronized Spin
            "SySpB": "SySp", "SySp1": "SySp", "SySp2": "SySp", "SySp3": "SySp", "SySp4": "SySp",
            
            // TrE - Transitions Element
            "TrEB": "TrE", "TrE1": "TrE", "TrE2": "TrE", "TrE3": "TrE", "TrE4": "TrE",
            
            // TwE - Twizzle Element
            "TwEB": "TwE", "TwE1": "TwE", "TwE2": "TwE", "TwE3": "TwE", "TwE4": "TwE",
            
            // NHE+sB - No Hold Element (step toujours Base, niveau varie sur NHE)
            // Program court juniors + programme long seniors
            "NHEB+sB": "NHE+sB", "NHE1+sB": "NHE+sB", "NHE2+sB": "NHE+sB", "NHE3+sB": "NHE+sB", "NHE4+sB": "NHE+sB",
            
            // NHEB+s - No Hold Element (NHE toujours Base, niveau varie sur step)
            // Program long juniors + programme court seniors
            "NHEB+s1": "NHEB+s", "NHEB+s2": "NHEB+s", "NHEB+s3": "NHEB+s", "NHEB+s4": "NHEB+s"
            // Note : NHEB+sB peut √™tre soit NHE+sB soit NHEB+s selon le programme
        };
        
        // Option de standardisation (peut √™tre activ√©e/d√©sactiv√©e dans les param√®tres)
        // Standardisation toujours active (plus d'option √† cocher)
        const standardiserNoms = true;
        
        /**
         * Extraire le niveau d'un √©l√©ment √† partir de son code
         * IMPORTANT : Pour les intersections, retourne "x+y" (les 2 niveaux)
         * Cette fonction permet d'afficher correctement les niveaux m√™me pour les donn√©es anciennes
         * @param {string} code - Code complet de l'√©l√©ment (ex: "I4+pi3", "SySp2", "NHEB+s3")
         * @param {string} type - Type de l'√©l√©ment (ex: "I+pi", "SySp", "NHE+sB")
         * @returns {string} - Le niveau format√© (ex: "4+3" pour intersection, "2" pour SySp)
         */
        function getNiveauFromCode(code, type) {
            // Pour les intersections : afficher les 2 niveaux "x+y"
            if (type && type.includes('I+pi')) {
                const levelMatchI = code.match(/I([B\d])\+pi/);
                const levelMatchPi = code.match(/\+pi([B\d])/);
                
                let levelI = '1';
                let levelPi = '1';
                
                if (levelMatchI) {
                    levelI = levelMatchI[1] === 'B' ? 'Base' : levelMatchI[1];
                }
                if (levelMatchPi) {
                    levelPi = levelMatchPi[1] === 'B' ? 'Base' : levelMatchPi[1];
                }
                
                return levelI + '+' + levelPi;
            }
            
            // Pour NHE+s : logique sp√©ciale
            if (code.match(/NHE[B\d]?\+s[B\d]?/)) {
                const typeBase = elementMapping[code];
                
                if (typeBase === 'NHE+sB') {
                    const levelMatch = code.match(/NHE([B\d])\+s/);
                    if (levelMatch) {
                        return levelMatch[1] === 'B' ? 'Base' : levelMatch[1];
                    }
                } else if (typeBase === 'NHEB+s') {
                    const levelMatch = code.match(/\+s([B\d])/);
                    if (levelMatch) {
                        return levelMatch[1] === 'B' ? 'Base' : levelMatch[1];
                    }
                    return 'Base';
                }
            }
            
            // Pour les √©l√©ments simples : dernier caract√®re
            const levelMatch = code.match(/([B\d])$/);
            if (levelMatch) {
                return levelMatch[1] === 'B' ? 'Base' : levelMatch[1];
            }
            
            return '1'; // Fallback
        }
        
        /**
         * NOUVELLE APPROCHE INTELLIGENTE : Extraire le nom d'√©quipe en se basant sur la base de donn√©es
         * Au lieu de deviner o√π couper le nom, on cherche dans la base si un nom d'√©quipe connu est pr√©sent
         * @param {string} nomBrut - Nom complet tel qu'extrait du PDF (ex: "Icicles Junior National Ice Centre, Nottingham")
         * @returns {object|null} - {nom: string, pays: string} ou null si non trouv√©
         */
        /**
         * Convertit un nom en Title Case (premi√®re lettre de chaque mot en majuscule)
         * Ex: "TEAM ICE ON FIRE JUNIOR" ‚Üí "Team Ice On Fire Junior"
         * @param {string} texte - Texte √† convertir
         * @returns {string} - Texte en Title Case
         */
        function toTitleCase(texte) {
            if (!texte) return texte;
            
            return texte
                .toLowerCase()
                .split(' ')
                .map(mot => {
                    if (mot.length === 0) return mot;
                    return mot.charAt(0).toUpperCase() + mot.slice(1);
                })
                .join(' ');
        }
        
        function extraireNomEquipeIntelligent(nomBrut) {
            // Nettoyer le nom de base (enlever parenth√®ses, etc.)
            let nomNettoye = nomBrut
                .replace(/\s*\([^)]*\)\s*/g, '')  // Enlever parenth√®ses
                .replace(/^Team\s+/i, '')          // Enlever "Team" au d√©but
                .trim();
            
            // Chercher TOUS les noms d'√©quipes qui matchent (m√™me partiellement)
            const matches = [];
            
            for (const [equipe, pays] of Object.entries(equipesInternationales)) {
                // Cr√©er des variantes du nom d'√©quipe pour matcher
                const variantes = [
                    equipe,
                    equipe.toLowerCase(),
                    equipe + ' Junior',
                    equipe + ' Senior',
                    equipe + ' Juniors',
                ];
                
                const nomLower = nomNettoye.toLowerCase();
                
                for (const variante of variantes) {
                    // Chercher si le nom d'√©quipe est pr√©sent dans le texte (mot complet)
                    const regex = new RegExp('\\b' + variante.toLowerCase().replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'i');
                    if (regex.test(nomNettoye)) {
                        matches.push({
                            nom: equipe,
                            pays: pays,
                            longueur: equipe.length
                        });
                        break; // Passer √† l'√©quipe suivante
                    }
                }
            }
            
            // Si on a trouv√© des matches, prendre le plus long (pour √©viter "Ice" vs "Ice Storm")
            if (matches.length > 0) {
                matches.sort((a, b) => b.longueur - a.longueur);
                const meilleurMatch = matches[0];
                window.debugLog(`üéØ Match trouv√© dans base: "${meilleurMatch.nom}" (${meilleurMatch.pays})`);
                return {
                    nom: meilleurMatch.nom,
                    pays: meilleurMatch.pays
                };
            }
            
            return null;
        }
        
        /**
         * Trouve le pays d'une √©quipe en cherchant dans la base de donn√©es
         * @param {string} nomEquipe - Nom de l'√©quipe (peut contenir "Team", espaces, etc.)
         * @returns {string|null} - Code pays 3 lettres ou null si non trouv√©
         */
        function trouverPaysEquipe(nomEquipe) {
            const resultat = extraireNomEquipeIntelligent(nomEquipe);
            return resultat ? resultat.pays : null;
        }
        
        /**
         * Standardise un nom d'√©quipe au format international ISU
         * Format Senior: "Team [Nom]" avec nation dans champ s√©par√©
         * Format Junior: "Team [Nom] Junior" avec nation dans champ s√©par√©
         * @param {string} nomBrut - Nom de l'√©quipe tel qu'extrait du PDF
         * @param {string} codeBrut - Code club/nation tel qu'extrait du PDF
         * @param {string} categorie - "Senior" ou "Junior"
         * @returns {object} - {nom: string, nation: string} - Nom standardis√© ET code pays
         */
        function standardiserNomEquipe(nomBrut, codeBrut, categorie) {
            // √âTAPE 0 : NOUVELLE APPROCHE INTELLIGENTE - Chercher dans la base de donn√©es FIRST
            // Ceci r√©sout tous les probl√®mes de parsing (australien, su√©dois, britannique, italien, etc.)
            const matchIntelligent = extraireNomEquipeIntelligent(nomBrut);
            
            if (matchIntelligent) {
                // On a trouv√© l'√©quipe dans la base ! Utiliser ce nom propre
                window.debugLog(`‚úÖ Match intelligent: "${matchIntelligent.nom}" ‚Üí ${matchIntelligent.pays}`);
                
                if (!standardiserNoms) {
                    // Mode d√©sactiv√© : garder le nom trouv√© mais ne pas standardiser
                    return {
                        nom: matchIntelligent.nom,
                        nation: matchIntelligent.pays
                    };
                }
                
                // Mode activ√© : construire le nom standardis√©
                let nomStandard = 'Team ' + toTitleCase(matchIntelligent.nom);
                
                // Ajouter "Junior" si c'est une √©quipe junior
                if (categorie && categorie.toLowerCase().includes('junior')) {
                    nomStandard += ' Junior';
                }
                
                return {
                    nom: nomStandard,
                    nation: matchIntelligent.pays
                };
            }
            
            // FALLBACK : Si pas trouv√© dans la base, utiliser l'ancienne m√©thode
            window.debugLog(`‚ö†Ô∏è Pas de match intelligent, fallback sur parsing manuel`);
            
            // √âTAPE 1 : D√©terminer le code pays (ancienne m√©thode)
            let codePays = clubVersPays[codeBrut] || codeBrut;
            
            // Si le code n'est pas reconnu, essayer de le nettoyer
            if (codePays && (codePays.length !== 3 || codePays !== codePays.toUpperCase())) {
                codePays = codePays.toUpperCase().substring(0, 3);
            }
            
            if (!standardiserNoms) {
                // Mode d√©sactiv√© : garder le nom brut mais quand m√™me convertir la nation
                return {
                    nom: nomBrut,
                    nation: codePays || codeBrut
                };
            }
            
            // √âTAPE 2 : Standardiser le nom
            let nom = nomBrut.trim();
            
            // NETTOYAGE UNIVERSEL : Enlever tout ce qui est entre parenth√®ses
            // Ex: "Hot Shivers (Junior ISU synchronized)" ‚Üí "Hot Shivers"
            nom = nom.replace(/\s*\([^)]*\)\s*/g, '').trim();
            
            // NETTOYAGE : Enlever "Team" au d√©but s'il existe d√©j√†
            nom = nom.replace(/^Team\s+/i, '');
            
            // NETTOYAGE : Enlever "Junior" / "Juniors" √† la fin s'il existe d√©j√†
            nom = nom.replace(/\s+Juniors?$/i, '');
            
            // Construire le nom standardis√© (SANS le code pays √† la fin)
            let nomStandard = 'Team ' + nom;
            
            // Ajouter "Junior" si c'est une √©quipe junior
            if (categorie && categorie.toLowerCase().includes('junior')) {
                nomStandard += ' Junior';
            }
            
            // Retourner nom ET nation s√©par√©ment
            return {
                nom: nomStandard,
                nation: codePays || codeBrut
            };
        }

        window.onload = function() {
            logVisible('üöÄ Script d√©marre');
            logVisible('üìä Comp√©titions: ' + liste.length);
            chargerDonnees();
            switchTab('calendar'); // Afficher le calendrier par d√©faut
        };

        function afficherDebug() {
            const debugDiv = document.getElementById('debugInfo');
            const isVisible = debugDiv.style.display !== 'none';
            
            if (isVisible) {
                debugDiv.style.display = 'none';
                return;
            }
            
            let html = '<strong>üîç √âTAT DU SYST√àME</strong><br><br>';
            html += '<strong>Competitions en m√©moire:</strong> ' + liste.length + '<br>';
            html += '<strong>Results en m√©moire:</strong> ' + resultats.length + '<br><br>';
            
            html += '<strong>localStorage:</strong><br>';
            html += '- ' + DB_COMPS + ': ' + (localStorage.getItem(DB_COMPS) ? 'OUI' : 'NON') + '<br>';
            html += '- ' + DB_RES + ': ' + (localStorage.getItem(DB_RES) ? 'OUI' : 'NON') + '<br><br>';
            
            if (resultats.length > 0) {
                html += '<strong>D√âTAIL DES R√âSULTATS:</strong><br>';
                resultats.forEach((r, i) => {
                    const comp = liste.find(c => String(c.id) === String(r.compId));
                    html += `[${i}] compId="${r.compId}" (type: ${typeof r.compId})<br>`;
                    html += `    cat="${r.cat}" prog="${r.prog}"<br>`;
                    html += `    comp trouv√©e: ${comp ? comp.n : 'NON'}<br>`;
                    html += `    √©quipes: ${r.data?.equipes?.length || 0}<br><br>`;
                });
            }
            
            debugDiv.innerHTML = html;
            debugDiv.style.display = 'block';
        }

        /**
         * Applique le format Title Case √† tous les noms d'√©quipes existants
         * Corrige "TEAM ICE ON FIRE" ‚Üí "Team Ice On Fire"
         */
        function appliquerTitleCaseRetroactif() {
            let nbModifications = 0;
            
            // Appliquer sur tous les r√©sultats
            resultats.forEach(resultat => {
                if (resultat.data && resultat.data.equipes) {
                    resultat.data.equipes.forEach(equipe => {
                        const ancienNom = equipe.nom;
                        equipe.nom = toTitleCase(equipe.nom);
                        if (ancienNom !== equipe.nom) {
                            nbModifications++;
                        }
                    });
                }
            });
            
            if (nbModifications > 0) {
                console.log(`‚úÖ Title Case appliqu√© : ${nbModifications} noms corrig√©s`);
                sauvegarderResultats();
            }
        }
        
        function chargerDonnees() {
            try {
                const compsStr = localStorage.getItem(DB_COMPS);
                if (compsStr) {
                    liste = JSON.parse(compsStr);
                    console.log('‚úÖ Competitions charg√©es:', liste.length);
                }
            } catch (e) {
                console.error('Erreur chargement comps:', e);
            }
            
            try {
                const resStr = localStorage.getItem(DB_RES);
                if (resStr) {
                    resultats = JSON.parse(resStr);
                    console.log('‚úÖ R√©sultats charg√©s:', resultats.length);
                    
                    // NETTOYAGE : Supprimer les r√©sultats orphelins (sans comp√©tition associ√©e)
                    const avant = resultats.length;
                    resultats = resultats.filter(r => {
                        const compExiste = liste.some(c => String(c.id) === String(r.compId));
                        if (!compExiste) {
                            console.warn('‚ö†Ô∏è R√©sultat orphelin supprim√©:', r.compId);
                        }
                        return compExiste;
                    });
                    
                    if (resultats.length < avant) {
                        console.log(`üßπ ${avant - resultats.length} r√©sultat(s) orphelin(s) supprim√©(s)`);
                        sauvegarderResultats();
                    }
                }
            } catch (e) {
                console.error('Erreur chargement r√©sultats:', e);
            }
            
            // Charger les √©quipes personnalis√©es
            try {
                const equipesCustomStr = localStorage.getItem('synchro_equipes_custom');
                if (equipesCustomStr) {
                    const equipesCustom = JSON.parse(equipesCustomStr);
                    Object.assign(equipesInternationales, equipesCustom);
                    console.log('‚úÖ √âquipes personnalis√©es charg√©es:', Object.keys(equipesCustom).length);
                }
            } catch (e) {
                console.error('Erreur chargement √©quipes personnalis√©es:', e);
            }
            
            // Charger les fusions d'√©quipes
            try {
                const fusionsStr = localStorage.getItem('synchro_fusions_2025');
                if (fusionsStr) {
                    fusionsEquipes = JSON.parse(fusionsStr);
                    console.log('‚úÖ Fusions d\'√©quipes charg√©es:', fusionsEquipes.length);
                }
            } catch (e) {
                console.error('Erreur chargement fusions:', e);
            }
            
            // Appliquer Title Case r√©troactif (corrige les anciennes donn√©es)
            appliquerTitleCaseRetroactif();
            
            afficher();
        }

        function sauvegarderComps() {
            try {
                localStorage.setItem(DB_COMPS, JSON.stringify(liste));
                console.log('‚úÖ Competitions sauvegard√©es:', liste.length);
            } catch (e) {
                console.error('‚ùå Erreur sauvegarde comps:', e);
                alert('Erreur de sauvegarde des competitions');
            }
        }

        function sauvegarderResultats() {
            try {
                localStorage.setItem(DB_RES, JSON.stringify(resultats));
                console.log('‚úÖ R√©sultats sauvegard√©s:', resultats.length);
                return true;
            } catch (e) {
                console.error('‚ùå Erreur sauvegarde r√©sultats:', e);
                alert('Erreur de sauvegarde des r√©sultats');
                return false;
            }
        }
        
        function supprimerResultat(resId) {
            if (!confirm('√ätes-vous s√ªr de vouloir supprimer ce r√©sultat ?')) {
                return;
            }
            
            const idx = resultats.findIndex(r => r.id === resId);
            if (idx === -1) {
                alert('R√©sultat introuvable');
                return;
            }
            
            const res = resultats[idx];
            
            // Supprimer du tableau
            resultats.splice(idx, 1);
            
            // Sauvegarder
            if (sauvegarderResultats()) {
                alert(`‚úÖ R√©sultat supprim√© : ${res.cat} ${res.prog}`);
                
                // Recharger la page d'upload pour mettre √† jour l'affichage
                ouvrirCompUpload(res.compId);
            }
        }

        function chargerCalendrier() {
            let nb = 0;
            cal.forEach(c => {
                if (!liste.some(x => x.n === c.n)) {
                    liste.push({
                        id: String(Date.now() + Math.random()),
                        d: c.d,
                        l: c.l,
                        p: c.p,
                        n: c.n,
                        t: c.t,
                        annulee: false  // Par d√©faut pas cancelede
                    });
                    nb++;
                }
            });
            sauvegarderComps();
            afficher();
            alert('‚úÖ ' + nb + ' competitions ajout√©es !');
        }
        
        /**
         * Ajouter une comp√©tition manuellement
         */
        function ajouterCompetition() {
            const nom = prompt('üìù Nom de la comp√©tition :');
            if (!nom) return;
            
            const dates = prompt('üìÖ Dates (ex: 12-14 Dec) :');
            if (!dates) return;
            
            const lieu = prompt('üìç Ville :');
            if (!lieu) return;
            
            const pays = prompt('üåç Code pays (3 lettres, ex: FIN, USA, CAN) :');
            if (!pays || pays.length !== 3) {
                alert('‚ùå Le code pays doit faire 3 lettres (ex: FIN, USA, CAN)');
                return;
            }
            
            const type = prompt('üèÜ Competition Type :\n1 = Regional\n2 = National\n3 = International\n4 = Challenger Series\n5 = Ch. du Monde\n6 = Ch. du Monde J\n\nEntrez le num√©ro :');
            
            const types = {
                '1': 'Regional',
                '2': 'National',
                '3': 'International',
                '4': 'Challenger Series',
                '5': 'Ch. du Monde',
                '6': 'Ch. du Monde J'
            };
            
            const typeCompet = types[type];
            if (!typeCompet) {
                alert('‚ùå Type invalide');
                return;
            }
            
            // Cr√©er la comp√©tition
            const nouvelleComp = {
                id: String(Date.now() + Math.random()),
                n: nom,
                d: dates,
                l: lieu,
                p: pays.toUpperCase(),
                t: typeCompet,
                annulee: false
            };
            
            liste.push(nouvelleComp);
            sauvegarderComps();
            afficher();
            
            alert(`‚úÖ Comp√©tition ajout√©e !\n\n${nom}\n${dates} - ${lieu}, ${pays}`);
        }
        
        /**
         * Supprimer une comp√©tition
         */
        function supprimerCompetition(id) {
            const comp = liste.find(c => String(c.id) === String(id));
            if (!comp) return;
            
            // V√©rifier s'il y a des r√©sultats
            const resComp = resultats.filter(r => String(r.compId) === String(id));
            
            let message = `‚ö†Ô∏è Supprimer cette comp√©tition ?\n\n${comp.n}\n${comp.d} - ${comp.l}, ${comp.p}`;
            
            if (resComp.length > 0) {
                message += `\n\nüö® ATTENTION : ${resComp.length} r√©sultat(s) seront √©galement supprim√©s !`;
            }
            
            if (!confirm(message)) return;
            
            // Supprimer la comp√©tition
            liste = liste.filter(c => String(c.id) !== String(id));
            
            // Supprimer les r√©sultats associ√©s
            if (resComp.length > 0) {
                resultats = resultats.filter(r => String(r.compId) !== String(id));
                sauvegarderResultats();
            }
            
            sauvegarderComps();
            afficher();
            fermerModal();
            
            alert(`‚úÖ Comp√©tition supprim√©e !`);
        }
        
        /**
         * Marquer/D√©marquer une comp√©tition comme cancelede
         */
        function toggleAnnulee(id) {
            const comp = liste.find(c => String(c.id) === String(id));
            if (!comp) return;
            
            comp.annulee = !comp.annulee;
            
            sauvegarderComps();
            afficher();
            
            // Rafra√Æchir la modal
            ouvrirCompUpload(id);
            
            const statut = comp.annulee ? 'ANNUL√âE' : 'NON ANNUL√âE';
            alert(`‚úÖ Comp√©tition marqu√©e comme ${statut}`);
        }

        function afficher() {
            logVisible('üé® afficher() appel√©e');
            logVisible('üìã liste.length = ' + liste.length);
            
            const recherche = (document.getElementById('search')?.value || '').toLowerCase();
            const paysFilt = document.getElementById('pays')?.value || '';
            const showAll = document.getElementById('showAllCompetitions')?.checked || false;
            
            logVisible('üîç Filtrage...');
            const filtrees = liste.filter(c => {
                const ok1 = c.n.toLowerCase().includes(recherche) || c.l.toLowerCase().includes(recherche);
                const ok2 = !paysFilt || c.p === paysFilt;
                
                // Filtre par type : par d√©faut, afficher seulement International, Challenger Series, World Championships
                let ok3 = true;
                if (!showAll) {
                    // Afficher seulement les competitions importantes
                    const typesImportants = ['International', 'Challenger Series', 'Junior World Championships', 'World Championships'];
                    ok3 = typesImportants.includes(c.t);
                }
                // Si showAll est true, ok3 reste true (toutes les competitions)
                
                return ok1 && ok2 && ok3;
            });
            
            // document.getElementById('total').textContent = liste.length; // Stats box removed
            // document.getElementById('totalPays').textContent = new Set(liste.map(c => c.p)).size; // Stats box removed
            // document.getElementById('totalResultats').textContent = resultats.length; // Stats box removed
            
            logVisible('‚úÖ Apr√®s filtrage: ' + filtrees.length + ' comp√©titions');
            
            const grid = document.getElementById('grid');
            if (!grid) {
                logVisible('‚ùå Element grid introuvable !');
                return;
            }
            logVisible('‚úÖ Element grid trouv√©');
            grid.innerHTML = '';
            
            logVisible('üîÑ D√©but boucle forEach');
            filtrees.forEach(c => {
                logVisible('  ‚Üí Cr√©ation carte: ' + c.n);
                const aRes = resultats.some(r => String(r.compId) === String(c.id));
                
                // Couleurs par type de comp√©tition (noms EXACTS)
                const typeCouleur = {
                    'Regional': '#9c27b0',           // Violet
                    'National': '#2196F3',           // Bleu
                    'International': '#4CAF50',      // Vert
                    'Challenger Series': '#FF9800',  // Orange
                    'Ch. du Monde': '#f44336',       // Rouge
                    'Ch. du Monde J': '#f44336'      // Rouge (Junior)
                };
                const badgeColor = typeCouleur[c.t] || '#2196F3'; // D√©faut bleu
                
                grid.innerHTML += `
                    <div class="competition-card" onclick="logVisible('üéØ Clic: ' + '${c.id}'); ouvrirComp('${c.id}')" ontouchstart="" style="border-left: 5px solid ${badgeColor} !important; cursor: pointer; -webkit-tap-highlight-color: rgba(0,0,0,0.1);">
                        <div class="competition-name">${c.n}</div>
                        <div style="color:#666;">üìÖ ${c.d}</div>
                        <div style="color:#666;">üìç ${c.l}, ${c.p}</div>
                        <div style="margin-top:10px;">
                            <span style="background:${badgeColor};color:white;padding:4px 10px;border-radius:12px;font-size:0.85em;">${c.t}</span>
                            ${c.annulee ? '<span style="margin-left:5px;background:#f44336;color:white;padding:4px 10px;border-radius:12px;font-size:0.85em;font-weight:bold;">üö´ ANNUL√âE</span>' : ''}
                            ${aRes ? '<span style="margin-left:5px;background:#4CAF50;color:white;padding:4px 10px;border-radius:12px;font-size:0.85em;">‚úì R√©sultats</span>' : ''}
                        </div>
                    </div>
                `;
            });
            
            remplirPays();
        }

        function remplirPays() {
            const select = document.getElementById('pays');
            if (!select || select.options.length > 1) return;
            
            const pays = [...new Set(liste.map(c => c.p))].sort();
            pays.forEach(p => {
                const opt = document.createElement('option');
                opt.value = p;
                opt.textContent = p;
                select.appendChild(opt);
            });
        }

        let currentCompId = null;

        function ouvrirComp(id) {
            currentCompId = String(id);
            chargerDonnees();
            
            const comp = liste.find(c => String(c.id) === String(id));
            if (!comp) {
                console.error('‚ùå Comp√©tition introuvable:', id);
                return;
            }
            
            console.log('üìÇ Ouverture comp√©tition:', comp.n);
            
            // V√©rifier s'il y a des r√©sultats pour cette comp√©tition
            const resultatsComp = resultats.filter(r => String(r.compId) === String(id));
            
            if (resultatsComp.length > 0) {
                // Il y a des r√©sultats ‚Üí afficher la vue sommaire directement
                // Prendre le premier r√©sultat (peu importe lequel, afficherVueSommaire va chercher tous les r√©sultats de la comp)
                afficherVueSommaire(resultatsComp[0].id);
                return;
            }
            
            // Pas de r√©sultats ‚Üí afficher la page d'upload
            ouvrirCompUpload(id);
        }
        
        function ouvrirCompUpload(id) {
            currentCompId = String(id);
            chargerDonnees();
            
            const comp = liste.find(c => String(c.id) === String(id));
            if (!comp) {
                console.error('‚ùå Comp√©tition introuvable:', id);
                return;
            }
            
            document.getElementById('modalTitle').textContent = comp.n;
            
            let html = `
                <div style="background:#f8f9ff;padding:15px;border-radius:8px;margin-bottom:20px;">
                    <p><strong>üìÖ</strong> ${comp.d}</p>
                    <p><strong>üìç</strong> ${comp.l}, ${comp.p}</p>
                    ${comp.annulee ? '<p style="color:#f44336;font-weight:bold;">üö´ COMP√âTITION ANNUL√âE</p>' : ''}
                </div>
                
                <div style="margin-bottom:20px;display:flex;gap:10px;flex-wrap:wrap;">
                    <button class="btn btn-small" style="background:#FF9800;color:white;" onclick="toggleAnnulee('${comp.id}')">
                        ${comp.annulee ? '‚úì Marquer comme NON cancelede' : 'üö´ Marquer comme ANNUL√âE'}
                    </button>
                    <button class="btn btn-small" style="background:#f44336;color:white;" onclick="supprimerCompetition('${comp.id}')">
                        üóëÔ∏è Supprimer cette comp√©tition
                    </button>
                </div>
                
                <h3 style="color:#1e3c72;margin:20px 0;">üìÑ Upload Protocoles</h3>
            `;
            
            ['Senior', 'Junior'].forEach(cat => {
                html += `<div class="cat-section"><div class="cat-title">${cat}</div>`;
                
                ['SP', 'FS'].forEach(prog => {
                    const key = `${comp.id}_${cat}_${prog}`;
                    const res = resultats.find(r => 
                        String(r.compId) === String(comp.id) && 
                        r.cat === cat && 
                        r.prog === prog
                    );
                    
                    html += `<div class="prog-section">
                        <div class="prog-title">${prog === 'SP' ? 'üìã Short Program' : 'üìã Free Program'}</div>
                        <input type="file" id="file_${key}" accept=".pdf" style="padding:8px;width:100%;margin-bottom:10px;border:2px solid #e0e0e0;border-radius:5px;">
                        <button class="btn btn-primary btn-small" onclick="uploadPDF('${comp.id}','${cat}','${prog}')">üì§ Analyze</button>
                        <div id="status_${key}">
                            ${res ? `<div class="success-box">‚úÖ Analys√© le ${new Date(res.date).toLocaleDateString()} - ${res.data.equipes.length} √©quipes</div>
                            <button class="btn btn-primary btn-small" onclick="afficherVueSommaire('${res.id}')" style="margin-right:5px;">üëÅÔ∏è View results</button>
                            <button class="btn btn-excel btn-small" onclick="exporterUnResultat('${res.id}')" style="margin-right:5px;">üìä Excel</button>
                            <button class="btn btn-small" style="background:#f44336;color:white;" onclick="supprimerResultat('${res.id}')">üóëÔ∏è Supprimer</button>` : ''}
                        </div>
                    </div>`;
                });
                
                html += '</div>';
            });
            
            document.getElementById('modalBody').innerHTML = html;
            document.getElementById('modal').classList.add('active');
        }

        function fermerModal() {
            document.getElementById('modal').classList.remove('active');
        }

        /**
         * Demande √† l'utilisateur d'ajouter une √©quipe inconnue √† la base
         * @param {object} equipeInc - {nomOriginal, nomBase, nation}
         * @returns {Promise<object|null>} - {nom, pays} ou null si canceled
         */
        async function ajouterEquipeInconnue(equipeInc) {
            return new Promise((resolve) => {
                const nomCorrect = prompt(
                    `‚ûï Ajouter une nouvelle √©quipe √† la base de donn√©es\n\n` +
                    `Nom d√©tect√© : "${equipeInc.nomOriginal}"\n` +
                    `Code pays : ${equipeInc.nation}\n\n` +
                    `Entrez le nom EXACT de l'√©quipe (sans "Team" ni "Junior") :\n` +
                    `Exemple : "Ice Storm", "Helsinki Rockettes", "Phoenix"`,
                    equipeInc.nomBase
                );
                
                if (!nomCorrect || nomCorrect.trim() === '') {
                    resolve(null);
                    return;
                }
                
                const paysCorrect = prompt(
                    `Confirmez le code pays (3 lettres) pour "${nomCorrect}" :`,
                    equipeInc.nation
                );
                
                if (!paysCorrect || paysCorrect.length !== 3) {
                    alert('‚ùå Code pays invalide (doit faire 3 lettres)');
                    resolve(null);
                    return;
                }
                
                // Ajouter √† la base de donn√©es
                equipesInternationales[nomCorrect.trim()] = paysCorrect.toUpperCase();
                
                // Sauvegarder dans localStorage
                const equipesCustomStr = localStorage.getItem('synchro_equipes_custom') || '{}';
                const equipesCustom = JSON.parse(equipesCustomStr);
                equipesCustom[nomCorrect.trim()] = paysCorrect.toUpperCase();
                localStorage.setItem('synchro_equipes_custom', JSON.stringify(equipesCustom));
                
                resolve({
                    nom: nomCorrect.trim(),
                    pays: paysCorrect.toUpperCase()
                });
            });
        }
        
        async function uploadPDF(compId, cat, prog) {
            compId = String(compId);
            
            const key = `${compId}_${cat}_${prog}`;
            const input = document.getElementById('file_' + key);
            const file = input.files[0];
            
            if (!file) {
                alert('S√©lectionnez un PDF');
                return;
            }
            
            const statusDiv = document.getElementById('status_' + key);
            statusDiv.innerHTML = '<div style="padding:10px;background:#fff3e0;border-radius:5px;margin-top:10px;">‚è≥ Analyse...</div>';
            
            // Zone de debug visible
            let debugLogs = [];
            window.debugLog = function(msg) {
                debugLogs.push(msg);
                console.log(msg);
            };
            
            try {
                debugLog('üìÑ D√©but analyse PDF: ' + file.name);
                
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
                
                debugLog(`üìñ PDF charg√©: ${pdf.numPages} pages`);
                
                let texte = '';
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const textContent = await page.getTextContent();
                    texte += textContent.items.map(item => item.str).join(' ') + '\n';
                }
                
                debugLog('üìù Texte extrait: ' + texte.length + ' caract√®res');
                debugLog('üîç Premiers 500 caract√®res: ' + texte.substring(0, 500));
                
                const proto = analyserTexte(texte, cat);
                
                debugLog('üéØ Protocole analys√©: ' + proto.equipes.length + ' √©quipes');
                
                // D√âTECTION DES √âQUIPES INCONNUES
                const equipesInconnues = [];
                proto.equipes.forEach(eq => {
                    const nomSansTeam = eq.nom.replace(/^Team\s+/i, '').replace(/\s+Junior$/i, '').trim();
                    // V√©rifier si l'√©quipe est dans la base
                    if (!equipesInternationales[nomSansTeam]) {
                        equipesInconnues.push({
                            nomOriginal: eq.nom,
                            nomBase: nomSansTeam,
                            nation: eq.nation
                        });
                    }
                });
                
                // Si des √©quipes inconnues, demander √† l'utilisateur de les ajouter
                if (equipesInconnues.length > 0) {
                    debugLog(`‚ö†Ô∏è ${equipesInconnues.length} √©quipe(s) inconnue(s) d√©tect√©e(s)`);
                    
                    const reponse = confirm(
                        `‚ö†Ô∏è ${equipesInconnues.length} √©quipe(s) inconnue(s) d√©tect√©e(s) :\n\n` +
                        equipesInconnues.map(e => `‚Ä¢ ${e.nomOriginal} (${e.nation})`).join('\n') +
                        `\n\nVoulez-vous les ajouter √† la base de donn√©es ?`
                    );
                    
                    if (reponse) {
                        // Ouvrir popup pour chaque √©quipe inconnue
                        for (const eqInc of equipesInconnues) {
                            const ajout = await ajouterEquipeInconnue(eqInc);
                            if (ajout) {
                                debugLog(`‚úÖ √âquipe ajout√©e: ${ajout.nom} (${ajout.pays})`);
                            }
                        }
                    } else {
                        statusDiv.innerHTML = `<div style="padding:10px;background:#fff3e0;border-radius:5px;margin-top:10px;">
                            ‚ö†Ô∏è Analyse cancelede - √âquipes inconnues non ajout√©es
                        </div>`;
                        return;
                    }
                }
                
                if (proto && proto.equipes && proto.equipes.length > 0) {
                    const res = {
                        id: String(Date.now() + '_' + Math.random()),
                        compId: compId,
                        cat: cat,
                        prog: prog,
                        date: new Date().toISOString(),
                        data: proto
                    };
                    
                    const idx = resultats.findIndex(r => 
                        String(r.compId) === String(compId) && 
                        r.cat === cat && 
                        r.prog === prog
                    );
                    
                    if (idx > -1) {
                        resultats[idx] = res;
                    } else {
                        resultats.push(res);
                    }
                    
                    const ok = sauvegarderResultats();
                    
                    if (ok) {
                        statusDiv.innerHTML = `<div class="success-box">‚úÖ ${proto.equipes.length} √©quipes - SAUVEGARDE OK !</div>
                        <button class="btn btn-primary btn-small" onclick="afficherVueSommaire('${res.id}')" style="margin-right:5px;">üëÅÔ∏è View results</button>
                        <button class="btn btn-excel btn-small" onclick="exporterUnResultat('${res.id}')">üìä Excel</button>`;
                        
                        afficher();
                    }
                } else {
                    // AFFICHER LES LOGS DANS LA PAGE
                    let debugHTML = '<div style="padding:15px;background:#ffebee;border-radius:5px;margin-top:10px;max-height:400px;overflow-y:auto;">';
                    debugHTML += '<h4 style="color:#c62828;margin-bottom:10px;">‚ùå Extraction impossible - Rapport de d√©bogage :</h4>';
                    debugHTML += '<div style="font-family:monospace;font-size:0.85em;white-space:pre-wrap;">';
                    debugLogs.forEach(log => {
                        debugHTML += log + '\n';
                    });
                    debugHTML += '</div></div>';
                    
                    statusDiv.innerHTML = debugHTML;
                }
            } catch (error) {
                debugLog('‚ùå ERREUR: ' + error.message);
                debugLog('Stack: ' + error.stack);
                
                let debugHTML = '<div style="padding:15px;background:#ffebee;border-radius:5px;margin-top:10px;max-height:400px;overflow-y:auto;">';
                debugHTML += '<h4 style="color:#c62828;margin-bottom:10px;">‚ùå Erreur - Rapport de d√©bogage :</h4>';
                debugHTML += '<div style="font-family:monospace;font-size:0.85em;white-space:pre-wrap;">';
                debugLogs.forEach(log => {
                    debugHTML += log + '\n';
                });
                debugHTML += '</div></div>';
                
                statusDiv.innerHTML = debugHTML;
            }
        }

        function analyserTexte(texte, categorie) {
            const proto = { 
                competition: '',
                programme: '',
                facteur: 2.67,
                equipes: [] 
            };
            
            const lines = texte.split('\n');
            
            // D√©tecter comp√©tition et programme
            for (let line of lines) {
                if (line.includes('CUP') || line.includes('CHAMPIONSHIP') || line.includes('TROPHY') || line.includes('SYNCHRO')) {
                    if (!proto.competition) proto.competition = line.trim().substring(0, 80);
                }
                if (line.includes('SHORT PROGRAM')) proto.programme = 'SP';
                else if (line.includes('FREE SKATING') || line.includes('LONG PROGRAM')) proto.programme = 'FS';
            }
            
            // Extraire le facteur
            const factorMatch = texte.match(/Program Components?\s+Factor\s+Composition\s+([\d\.]+)/);
            if (factorMatch) proto.facteur = parseFloat(factorMatch[1]);
            
            // D√©tecter le format : "Club" ou "Nation"
            const hasClubColumn = texte.includes('Rank   Name   Club   Starting') || texte.includes('Rank Name Club Starting');
            
            window.debugLog(`üîç Format d√©tect√©: ${hasClubColumn ? 'CLUB (Australie)' : 'NATION (ISU standard)'}`);
            
            // NOUVELLE STRAT√âGIE : Trouver tous les headers avec leur position
            let headerPattern;
            
            if (hasClubColumn) {
                // Format Club : capturer lettres/espaces/ponctuation INCLUANT / pour les clubs su√©dois
                // Pattern : Rang + Nom+Club + Starting + 4 scores
                headerPattern = /(\d{1,2})\s+([A-Za-z√Ä-√ø\/\s\(\)\-\.',]+?)\s+(\d{1,2})\s+([\d]+\.[\d]{2})\s+([\d]+\.[\d]{2})\s+([\d]+\.[\d]{2})\s+([\-\d]+\.[\d]{2})/gm;
                
                window.debugLog(`üîç Pattern Club (lettres + espaces + ponctuation + /, PAS de deux-points)`);
            } else {
                // Format ISU standard - nom restrictif pour ne pas capturer "Starting"
                // Le nom peut contenir: lettres, chiffres, espaces, tirets, apostrophes, parenth√®ses, points, virgules
                // MAIS on s'arr√™te avant "Starting" en limitant la capture
                // Le code club peut √™tre en majuscules, minuscules, avec tirets ou chiffres (ex: Kaari, EsJt, VG-62, TapTL, KuLS)
                headerPattern = /(\d+)\s+([A-Za-z√Ä-√ø0-9\s\(\)\-\.',]{3,40}?)\s+([A-Za-z0-9\-]{2,6})\s+\d+\s+([\d]+\.[\d]{2})\s+([\d]+\.[\d]{2})\s+([\d]+\.[\d]{2})\s+([\-\d]+\.[\d]{2})/gm;
                
                window.debugLog(`üîç Pattern ISU avec nom restrictif (3-40 caract√®res) + codes club mixtes accept√©s`);
            }
            
            const headers = [];
            let match;
            
            while ((match = headerPattern.exec(texte)) !== null) {
                if (hasClubColumn) {
                    // Pour le format club, on doit s√©parer nom et club dans le groupe captur√©
                    const fullText = match[2].trim();
                    
                    // VALIDATION : rejeter si c'est un faux header (contient des mots du vrai header)
                    if (fullText.match(/Rank|Starting|Total Segment|Total Element|Component Score/i)) {
                        window.debugLog(`‚ö†Ô∏è Rejet√© (faux header): "${fullText.substring(0, 50)}..."`);
                        continue;
                    }
                    
                    // AM√âLIORATION : D√©tecter et enlever les suffixes de clubs australiens/internationaux
                    // Pattern : [Nom √âquipe] [Ville/R√©gion optionalle] [Type de club]
                    // Exemples :
                    // - "Ice Storm Queensland Synchronized Iceskating Club"
                    // - "Phoenix Boondall Synchronized Ice Skating Club"
                    
                    let nom = fullText;
                    let clubSuffix = '';
                    
                    // STRAT√âGIE PRIORITAIRE : Si le texte commence par "Team",
                    // le nom est "Team + 1 √† 2 mots" et le reste est le club.
                    // Cela √©vite de manger des mots du club dans le nom.
                    if (nom.match(/^Team\s+/i)) {
                        const teamMatch = nom.match(/^(Team\s+\S+(?:\s+\S+)?)\s+(.+)$/i);
                        if (teamMatch) {
                            // V√©rifier que le 2√®me mot n'est PAS un mot de club connu
                            const mot2 = nom.split(/\s+/)[2] || '';
                            const motsClub = /^(Konst√•kningsklubb|Team√•kningsklubb|Konst√•kare|Synchronized|Ice|Skating|Club|F√∂reningen|Konst√•karna|Kungsbacka|Tj√∂rns|Nacka|Bor√•s|Queensland|Phoenix|Boondall)/i;
                            
                            if (mot2 && mot2.match(motsClub)) {
                                // Le 2√®me mot est d√©j√† un mot de club ‚Üí nom = "Team mot1"
                                const parts = nom.split(/\s+/);
                                nom = parts.slice(0, 2).join(' ');
                                clubSuffix = parts.slice(2).join(' ');
                            } else {
                                // Nom = "Team mot1 mot2" (si mot2 existe et n'est pas un club)
                                // Puis v√©rifier si mot3 est un mot de club
                                const parts = nom.split(/\s+/);
                                const mot3 = parts[3] || '';
                                if (mot3 && mot3.match(motsClub)) {
                                    nom = parts.slice(0, 3).join(' ');
                                    clubSuffix = parts.slice(3).join(' ');
                                } else if (parts.length > 3) {
                                    // Fallback : nom = 3 premiers mots, reste = club
                                    nom = parts.slice(0, 3).join(' ');
                                    clubSuffix = parts.slice(3).join(' ');
                                }
                            }
                            window.debugLog(`üîç Nom extrait (Team): "${nom}" | Club: "${clubSuffix}"`);
                        }
                    }
                    
                    // Si pas de "Team" au d√©but, utiliser les patterns de suffixes de clubs
                    if (!clubSuffix) {
                        const clubPatterns = [
                        // Formats australiens avec ville
                        /\s+[A-Z][a-z]+\s+Synchronized\s+(Iceskating|Ice\s+Skating)\s+Club$/i,
                        /\s+[A-Z][a-z]+\s+Ice\s+Skating\s+Club$/i,
                        // Formats su√©dois
                        /\s+[A-Z√ñ√Ñ√Ö][a-z√∂√§√•√©]+\s+Konst√•kningsklubb$/i,
                        /\s+[A-Z√ñ√Ñ√Ö][a-z√∂√§√•√©]+\s+Team√•kningsklubb$/i,
                        /\s+[A-Z√ñ√Ñ√Ö][a-z√∂√§√•√©]+(\s+[A-Z√ñ√Ñ√Ö][a-z√∂√§√•√©]+)+\s+Konst√•kare$/i,
                        /\s+[A-Z√ñ√Ñ√Ö][a-z√∂√§√•√©]+\s+Konst√•kare$/i,
                        // Formats g√©n√©riques
                        /\s+Synchronized\s+(Iceskating|Ice\s+Skating)\s+Club$/i,
                        /\s+Ice\s+Skating\s+Club$/i,
                        /\s+Figure\s+Skating\s+Club$/i,
                        /\s+Skating\s+Club$/i,
                        /\s+Konst√•kningsklubb$/i,
                        /\s+Team√•kningsklubb$/i,
                        /\s+Konst√•kare$/i
                        ];
                        for (const pattern of clubPatterns) {
                            const matchClub = nom.match(pattern);
                            if (matchClub) {
                                clubSuffix = matchClub[0];
                                nom = nom.replace(pattern, '').trim();
                                window.debugLog(`üîç Suffixe de club enlev√©: "${clubSuffix.trim()}"`);
                                break;
                            }
                        }
                    } // fin if (!clubSuffix)
                    
                    // Si aucun pattern trouv√©, utiliser l'ancienne m√©thode (chercher "Club", "Skating", etc.)
                    let nation;
                    if (!clubSuffix) {
                        const parts = fullText.split(/\s+/);
                        let clubStartIndex = -1;
                        
                        for (let i = parts.length - 1; i >= 0; i--) {
                            if (parts[i].match(/Club|Skating|Ice|Synchronized|Synchro|Centre|Center/i)) {
                                clubStartIndex = i;
                                while (clubStartIndex > 0 && parts[clubStartIndex - 1].match(/[A-Z√Ä-≈∏]/)) {
                                    clubStartIndex--;
                                }
                                break;
                            }
                        }
                        
                        if (clubStartIndex > 0) {
                            nom = parts.slice(0, clubStartIndex).join(' ');
                            nation = parts.slice(clubStartIndex).join(' ');
                        } else {
                            // Fallback : prendre les 2-3 premiers mots comme nom
                            nom = parts.slice(0, Math.min(3, parts.length - 1)).join(' ');
                            nation = parts.slice(Math.min(3, parts.length - 1)).join(' ');
                        }
                    } else {
                        nation = clubSuffix.trim();
                    }
                    
                    // NETTOYAGE UNIVERSEL : Enlever tout ce qui est entre parenth√®ses
                    // Ex: "Hot Shivers (Junior ISU synchronized)" ‚Üí "Hot Shivers"
                    // Ex: "Ice On Fire (Senior ISU synchronized)" ‚Üí "Ice On Fire"
                    nom = nom.replace(/\s*\([^)]*\)\s*/g, '').trim();
                    
                    window.debugLog(`üîç Header d√©tect√©: ${match[1]} - "${nom}" (${nation})`);
                    
                    headers.push({
                        index: match.index,
                        rang: parseInt(match[1]),
                        nom: nom,
                        nation: nation,
                        total: parseFloat(match[4]),
                        tech: parseFloat(match[5]),
                        pres: parseFloat(match[6])
                    });
                } else {
                    // Format ISU standard
                    let nom = match[2].trim().replace(/\s+/g, ' ');
                    
                    // NETTOYAGE UNIVERSEL : Enlever tout ce qui est entre parenth√®ses
                    nom = nom.replace(/\s*\([^)]*\)\s*/g, '').trim();
                    
                    if (nom && nom.length > 0 && nom.length < 50) {
                        headers.push({
                            index: match.index,
                            rang: parseInt(match[1]),
                            nom: nom,
                            nation: match[3],
                            total: parseFloat(match[4]),
                            tech: parseFloat(match[5]),
                            pres: parseFloat(match[6])
                        });
                        window.debugLog(`üîç Header d√©tect√©: ${match[1]} - "${nom}" (${match[3]})`);
                    }
                }
            }
            
            window.debugLog(`üìã Nombre de headers trouv√©s: ${headers.length}`);
            
            // Valider et corriger les rangs si n√©cessaire
            headers.forEach((header, index) => {
                if (!header.rang || isNaN(header.rang)) {
                    // Si le rang n'est pas valide, utiliser l'index + 1
                    window.debugLog(`‚ö†Ô∏è Rang invalide pour ${header.nom}, utilisation de ${index + 1}`);
                    header.rang = index + 1;
                }
            });
            
            // Pour chaque header, extraire le bloc jusqu'au prochain header
            for (let i = 0; i < headers.length; i++) {
                const start = headers[i].index;
                const end = (i < headers.length - 1) ? headers[i + 1].index : texte.length;
                const blocEquipe = texte.substring(start, end);
                
                window.debugLog(`üîç √âquipe ${headers[i].rang} ${headers[i].nom}: bloc de ${blocEquipe.length} caract√®res`);
                
                try {
                    const equipe = analyserBlocEquipeV2(blocEquipe, headers[i], categorie, proto.equipes);
                    if (equipe && equipe.elements.length > 0) {
                        proto.equipes.push(equipe);
                        window.debugLog(`‚úÖ √âquipe ${equipe.rang}: ${equipe.nom} - ${equipe.elements.length} √©l√©ments`);
                    } else {
                        window.debugLog(`‚ùå Aucun √©l√©ment pour ${headers[i].nom}`);
                    }
                } catch (e) {
                    window.debugLog(`‚ùå Erreur √©quipe ${i}: ${e.message}`);
                }
            }
            
            window.debugLog(`üìä TOTAL: ${proto.equipes.length} √©quipes extraites`);
            
            // Trier les √©quipes par score total (d√©croissant) et recalculer les rangs
            proto.equipes.sort((a, b) => b.total - a.total);
            proto.equipes.forEach((equipe, index) => {
                equipe.rang = index + 1;
            });
            window.debugLog(`üìä Rangs recalcul√©s selon les scores`);
            
            return proto;
        }
        
        function analyserBlocEquipeV2(bloc, header, categorie, equipesPrecedentes = []) {
            window.debugLog(`üîç Analyse √©quipe: ${header.nom}`);
            window.debugLog(`üîç Extrait bloc (300 premiers car): ${bloc.substring(0, 300)}`);
            
            // Appliquer la standardisation du nom si activ√©e
            const standardisation = standardiserNomEquipe(header.nom, header.nation, categorie);
            
            const eq = {
                rang: header.rang,
                nom: standardisation.nom,      // Nom standardis√© (sans code pays)
                nation: standardisation.nation, // Code pays (3 lettres)
                total: header.total,
                tech: header.tech,
                pres: header.pres,
                elements: [],
                composantes: {
                    composition: [], presentation: [], skatingSkills: [],
                    compFinal: 0, presFinal: 0, skatFinal: 0
                }
            };
            
            // EXTRACTION DES √âL√âMENTS
            let intersectionCount = 0;
            const elemPattern = /(\d+)\s+(SySp[B\d]?|TrE[B\d]?|NHEB?\+s[B\d]?|NHE[B\d]?\+s[B\d]?|I[B\d]?\+pi[B\d]?|ME[B\d]?<{0,2}|GL[B\d]?<{0,2}|PB[B\d]?|CrI[B\d]?|TwE[B\d]?|Pa[B\d]?|CrL[B\d]?|AL[B\d]?|AB[B\d]?|AW[B\d]?|AC[B\d]?|CrE[B\d]?|NHE[B\d]?)\s+(?:([<F!][x!<]*)\s+)?([\d\.]+)\s+([\-\+]?[\d\.]+)\s+((?:(?:[\-\+]?\d+|-)\s+)*)([\d\.]+)/g;
            
            window.debugLog(`üîç Pattern √©l√©ments avec AL, AB, CrL, Pa`);
            
            let match;
            while ((match = elemPattern.exec(bloc)) !== null) {
                const numero = parseInt(match[1]);
                const fullCode = match[2];
                const infoCol = match[3] || '';
                const chute = infoCol.includes('F') ? true : false;
                const bv = parseFloat(match[4]);
                const goe = parseFloat(match[5]);
                const jugesStr = match[6];
                const scoreFinal = parseFloat(match[7]);
                
                // Extraire les GOE des juges
                const jugesGOE = [];
                const jugesParts = jugesStr.trim().split(/\s+/);
                for (let part of jugesParts) {
                    const goeVal = parseInt(part);
                    if (!isNaN(goeVal) && goeVal >= -5 && goeVal <= 5) {
                        jugesGOE.push(goeVal);
                    }
                }
                
                window.debugLog(`üîç √âl√©ment ${numero} ${fullCode}: ${jugesGOE.length} juges (${jugesGOE.join(', ')})`);
                
                // Ne pas ignorer les BRN (bv=0, pas de juges)
                if (jugesGOE.length === 0 && scoreFinal > 0) continue;
                
                // NOUVELLE APPROCHE : Utiliser le mapping exhaustif (beaucoup plus fiable !)
                let type = elementMapping[fullCode];
                
                // Si pas trouv√© dans le mapping, normaliser les downgrades GL et ME
                if (!type) {
                    // Downgrades: GL4< ‚Üí type "GL", ME3<< ‚Üí type "ME"
                    if (fullCode.startsWith('GL')) {
                        type = 'GL';
                    } else if (fullCode.startsWith('ME')) {
                        type = 'ME';
                    } else if (fullCode === 'NHE' || fullCode.startsWith('NHE')) {
                        // BRN sur NHE : d√©tecter le bon type via les autres √©quipes du m√™me r√©sultat
                        let nheType = null;
                        for (const autreEq of equipesPrecedentes) {
                            const nheEl = autreEq.elements.find(e => e.type && (e.type === 'NHE+sB' || e.type === 'NHEB+s'));
                            if (nheEl) { nheType = nheEl.type; break; }
                        }
                        type = nheType || 'NHE+sB';
                        window.debugLog(`üîç NHE BRN ‚Üí type d√©tect√©: "${type}"`);
                    } else {
                        // BRN ou inconnu : extraire le type de base (lettres only)
                        const typeBase = fullCode.match(/^([A-Za-z+]+)/);
                        type = typeBase ? typeBase[1] : fullCode;
                        window.debugLog(`‚ö†Ô∏è √âl√©ment sans mapping: ${fullCode} ‚Üí type "${type}"`);
                    }
                }
                
                // CAS SP√âCIAL : NHEB+sB ambigu ‚Üí d√©tecter via les √©quipes pr√©c√©dentes
                if (fullCode === 'NHEB+sB') {
                    let nheType = null;
                    for (const autreEq of equipesPrecedentes) {
                        const nheEl = autreEq.elements.find(e => e.type && (e.type === 'NHE+sB' || e.type === 'NHEB+s'));
                        if (nheEl) { nheType = nheEl.type; break; }
                    }
                    if (nheType) {
                        type = nheType;
                        window.debugLog(`üîç NHEB+sB ambigu ‚Üí type d√©tect√© via autres √©quipes: "${type}"`);
                    }
                    // Si premi√®re √©quipe : garde le type du mapping (NHE+sB par d√©faut)
                }
                
                // INTERSECTION : num√©roter les intersections (1√®re, 2√®me)
                if (type === 'I+pi') {
                    intersectionCount++;
                    type = 'I+pi (' + intersectionCount + (intersectionCount === 1 ? '√®re' : '√®me') + ')';
                }
                
                // Extraire le niveau (B = Base, 1, 2, 3, 4)
                let level = '1';
                
                if (fullCode.match(/I[B\d]\+pi/)) {
                    // Intersection : extraire BOTH niveaux (I et pi) pour afficher "x+y"
                    // Exemples : I4+pi3 ‚Üí "4+3", IB+piB ‚Üí "Base+Base", I2+pi4 ‚Üí "2+4"
                    const levelMatchI = fullCode.match(/I([B\d])\+pi/);
                    const levelMatchPi = fullCode.match(/\+pi([B\d])/);
                    
                    let levelI = '1';
                    let levelPi = '1';
                    
                    if (levelMatchI) {
                        levelI = levelMatchI[1] === 'B' ? 'Base' : levelMatchI[1];
                    }
                    if (levelMatchPi) {
                        levelPi = levelMatchPi[1] === 'B' ? 'Base' : levelMatchPi[1];
                    }
                    
                    // Afficher les 2 niveaux : "x+y"
                    level = levelI + '+' + levelPi;
                    
                } else if (fullCode.match(/NHE[B\d]?\+s[B\d]?/)) {
                    // No Hold Element : logique sp√©ciale selon la cat√©gorie
                    const typeBase = elementMapping[fullCode];
                    
                    if (typeBase === 'NHE+sB') {
                        // Step toujours Base, afficher niveau du NHE
                        const levelMatch = fullCode.match(/NHE([B\d])\+s/);
                        if (levelMatch) {
                            level = levelMatch[1] === 'B' ? 'Base' : levelMatch[1];
                        }
                    } else if (typeBase === 'NHEB+s') {
                        // NHE toujours Base, afficher niveau de la step
                        const levelMatch = fullCode.match(/\+s([B\d])/);
                        if (levelMatch) {
                            level = levelMatch[1] === 'B' ? 'Base' : levelMatch[1];
                        } else {
                            level = 'Base';
                        }
                    } else {
                        // Fallback : prendre le niveau du NHE
                        const levelMatch = fullCode.match(/NHE([B\d])?\+s/);
                        if (levelMatch && levelMatch[1]) {
                            level = levelMatch[1] === 'B' ? 'Base' : levelMatch[1];
                        } else {
                            level = 'Base';
                        }
                    }
                } else {
                    // √âl√©ments simples : prendre le niveau (avec downgrades)
                    // GL4< ‚Üí "4<", ME3<< ‚Üí "3<<", Pa4 ‚Üí "4", CrL (BRN) ‚Üí ""
                    const levelMatch = fullCode.match(/([B\d]<{0,2})$/);
                    if (levelMatch) {
                        level = levelMatch[1] === 'B' ? 'Base' : levelMatch[1];
                    } else {
                        level = ''; // Basic Requirement Not Met : pas de niveau
                    }
                }
                
                eq.elements.push({
                    numero: numero,
                    code: fullCode,
                    type: type,
                    niveau: level,
                    bv: bv,
                    goe: goe,
                    juges: jugesGOE,
                    score: scoreFinal,
                    chute: chute
                });
            }
            
            // EXTRACTION DES COMPOSANTES
            const compPattern = /Composition\s+[\d\.]+\s+([\d\.\s]+?)(?=Presentation|Skating|$)/s;
            const compMatch = bloc.match(compPattern);
            if (compMatch) {
                const scores = compMatch[1].trim().split(/\s+/).map(parseFloat).filter(n => !isNaN(n) && n <= 10);
                if (scores.length > 0) {
                    eq.composantes.compFinal = scores[scores.length - 1];
                    eq.composantes.composition = scores.slice(0, -1);
                }
            }
            
            const presPattern = /Presentation\s+[\d\.]+\s+([\d\.\s]+?)(?=Skating|Judges Total|$)/s;
            const presMatch = bloc.match(presPattern);
            if (presMatch) {
                const scores = presMatch[1].trim().split(/\s+/).map(parseFloat).filter(n => !isNaN(n) && n <= 10);
                if (scores.length > 0) {
                    eq.composantes.presFinal = scores[scores.length - 1];
                    eq.composantes.presentation = scores.slice(0, -1);
                }
            }
            
            const skatPattern = /Skating Skills\s+[\d\.]+\s+([\d\.\s]+?)(?=Judges Total|Deductions|$)/s;
            const skatMatch = bloc.match(skatPattern);
            if (skatMatch) {
                const scores = skatMatch[1].trim().split(/\s+/).map(parseFloat).filter(n => !isNaN(n) && n <= 10);
                if (scores.length > 0) {
                    eq.composantes.skatFinal = scores[scores.length - 1];
                    eq.composantes.skatingSkills = scores.slice(0, -1);
                }
            }
            
            return eq;
        }

        // FONCTIONS DE CALCUL DES RANGS

        function assignRanksWithTies(sortedScores) {
            const ranks = {};
            let currentRank = 1;
            for (let i = 0; i < sortedScores.length; i++) {
                const current = sortedScores[i];
                if (i > 0 && sortedScores[i].score !== sortedScores[i - 1].score) {
                    currentRank = i + 1;
                }
                ranks[current.teamName] = currentRank;
            }
            return ranks;
        }

        function getRankClass(currentRank, generalRank) {
            if (currentRank === undefined || currentRank === null || currentRank === '-' ||
                generalRank === undefined || generalRank === null || generalRank === '-') {
                return 'rank-equal';
            }
            if (currentRank < generalRank) return 'rank-better';
            else if (currentRank > generalRank) return 'rank-worse';
            else return 'rank-equal';
        }

        function getRankClassHeader(currentRank, generalRank) {
            if (currentRank === undefined || currentRank === null || currentRank === '-' ||
                generalRank === undefined || generalRank === null || generalRank === '-') {
                return 'rank-equal-header';
            }
            if (currentRank < generalRank) return 'rank-better-header';
            else if (currentRank > generalRank) return 'rank-worse-header';
            else return 'rank-equal-header';
        }

        function calculateElementRankings(protocol) {
            const elementsByType = {};
            
            protocol.equipes.forEach(team => {
                team.elements.forEach(element => {
                    const type = element.type;
                    if (!elementsByType[type]) elementsByType[type] = [];
                    elementsByType[type].push({
                        teamName: team.nom,
                        teamRank: team.rang,
                        level: getNiveauFromCode(element.code, element.type),
                        baseValue: element.bv,
                        goe: element.goe,
                        score: element.score,
                        judges: element.juges,
                        hasFall: element.chute
                    });
                });
            });
            
            const hasME = elementsByType['ME'] && elementsByType['ME'].length > 0;
            const hasPa = elementsByType['Pa'] && elementsByType['Pa'].length > 0;
            
            if (hasME && hasPa) {
                const teamsWithME = new Set(elementsByType['ME'].map(e => e.teamName));
                const teamsWithPa = new Set(elementsByType['Pa'].map(e => e.teamName));
                const teamsWithBoth = [...teamsWithME].filter(name => teamsWithPa.has(name));
                
                if (teamsWithBoth.length === 0) {
                    elementsByType['ME/Pa'] = [...(elementsByType['ME'] || []), ...(elementsByType['Pa'] || [])];
                    delete elementsByType['ME'];
                    delete elementsByType['Pa'];
                }
            }
            
            Object.keys(elementsByType).forEach(type => {
                elementsByType[type].sort((a, b) => b.score - a.score);
                elementsByType[type].forEach((item, index) => {
                    item.elementRank = index + 1;
                });
            });
            
            return elementsByType;
        }

        function calculateJudgeRanksForElement(elementData, judgeIndex) {
            const judgeScores = elementData.map(item => ({
                teamName: item.teamName,
                judgeGOE: item.judges[judgeIndex],
                score: item.baseValue + (item.baseValue * item.judges[judgeIndex] * 10 / 100)
            }));
            
            judgeScores.sort((a, b) => b.score - a.score);
            return assignRanksWithTies(judgeScores);
        }

        function calculateTechnicalRankings(protocol) {
            const rankings = protocol.equipes.map(team => ({
                teamName: team.nom,
                score: team.tech
            })).sort((a, b) => b.score - a.score);
            
            return assignRanksWithTies(rankings);
        }

        function calculateComponentsRankings(protocol) {
            const rankings = protocol.equipes.map(team => ({
                teamName: team.nom,
                score: team.pres
            })).sort((a, b) => b.score - a.score);
            
            return assignRanksWithTies(rankings);
        }

        function calculateBaseValueRankings(protocol) {
            const rankings = protocol.equipes.map(team => ({
                teamName: team.nom,
                totalBV: team.elements.reduce((sum, el) => sum + el.bv, 0)
            })).sort((a, b) => b.totalBV - a.totalBV);
            
            const ranks = {};
            rankings.forEach((item, index) => {
                ranks[item.teamName] = index + 1;
            });
            return ranks;
        }

        function calculateJudgeTechnicalRankings(protocol, judgeIndex) {
            const scores = protocol.equipes.map(team => {
                let totalScore = 0;
                team.elements.forEach(element => {
                    const judgeGOE = element.juges[judgeIndex] || 0;
                    const goePoints = (element.bv * judgeGOE * 10) / 100;
                    totalScore += element.bv + goePoints;
                });
                return {
                    teamName: team.nom,
                    score: totalScore
                };
            }).sort((a, b) => b.score - a.score);
            
            const ranks = assignRanksWithTies(scores);
            return { ranks, scores };
        }

        function calculateJudgeComponentsRankings(protocol, judgeIndex) {
            const scores = protocol.equipes.map(team => {
                const total = (team.composantes.composition[judgeIndex] || 0) + 
                             (team.composantes.presentation[judgeIndex] || 0) + 
                             (team.composantes.skatingSkills[judgeIndex] || 0);
                return {
                    teamName: team.nom,
                    score: total
                };
            }).sort((a, b) => b.score - a.score);
            
            return assignRanksWithTies(scores);
        }

        // Calculer les rangs totaux pour chaque juge
        function calculateJudgeTotalRankings(protocol, judgeIndex) {
            const scores = [];
            
            protocol.equipes.forEach(team => {
                // Calculer les d√©ductions pour cette √©quipe
                const deductions = team.tech + team.pres - team.total;
                
                // Score technique (identique pour tous les juges)
                const techScore = team.tech;
                
                // Score pr√©sentation du juge
                const presScore = ((team.composantes.composition[judgeIndex] || 0) + 
                                   (team.composantes.presentation[judgeIndex] || 0) + 
                                   (team.composantes.skatingSkills[judgeIndex] || 0)) * protocol.facteur;
                
                // Total du juge
                const totalScore = techScore + presScore - deductions;
                
                scores.push({
                    nom: team.nom,
                    total: totalScore
                });
            });
            
            // Trier par score d√©croissant
            scores.sort((a, b) => b.total - a.total);
            
            // Assigner les rangs
            const rankings = {};
            scores.forEach((score, index) => {
                rankings[score.nom] = index + 1;
            });
            
            return rankings;
        }

        function calculateCompositionRankings(protocol) {
            const rankings = protocol.equipes.map(team => ({
                teamName: team.nom,
                score: team.composantes.compFinal || 0
            })).sort((a, b) => b.score - a.score);
            
            const ranks = {};
            rankings.forEach((item, index) => {
                ranks[item.teamName] = index + 1;
            });
            return ranks;
        }

        function calculateJudgeCompositionRankings(protocol, judgeIndex) {
            const scores = protocol.equipes.map(team => ({
                teamName: team.nom,
                score: team.composantes.composition[judgeIndex] || 0
            })).sort((a, b) => b.score - a.score);
            
            return assignRanksWithTies(scores);
        }

        function calculatePresentationRankings(protocol) {
            const rankings = protocol.equipes.map(team => ({
                teamName: team.nom,
                score: team.composantes.presFinal || 0
            })).sort((a, b) => b.score - a.score);
            
            const ranks = {};
            rankings.forEach((item, index) => {
                ranks[item.teamName] = index + 1;
            });
            return ranks;
        }

        function calculateJudgePresentationRankings(protocol, judgeIndex) {
            const scores = protocol.equipes.map(team => ({
                teamName: team.nom,
                score: team.composantes.presentation[judgeIndex] || 0
            })).sort((a, b) => b.score - a.score);
            
            return assignRanksWithTies(scores);
        }

        function calculateSkatingSkillsRankings(protocol) {
            const rankings = protocol.equipes.map(team => ({
                teamName: team.nom,
                score: team.composantes.skatFinal || 0
            })).sort((a, b) => b.score - a.score);
            
            const ranks = {};
            rankings.forEach((item, index) => {
                ranks[item.teamName] = index + 1;
            });
            return ranks;
        }

        function calculateJudgeSkatingSkillsRankings(protocol, judgeIndex) {
            const scores = protocol.equipes.map(team => ({
                teamName: team.nom,
                score: team.composantes.skatingSkills[judgeIndex] || 0
            })).sort((a, b) => b.score - a.score);
            
            return assignRanksWithTies(scores);
        }

        // EXPORT EXCEL - FONCTION PRINCIPALE

        function exporterToutExcel() {
            if (resultats.length === 0) {
                alert('Aucun r√©sultat √† exporter. Analysez d\'abord des protocoles !');
                return;
            }

            const wb = XLSX.utils.book_new();
            
            // ONGLET 1 : R√âSUM√â
            const resumeData = [
                ['R√âSUM√â G√âN√âRAL - Saison 2025-26'],
                [''],
                ['Comp√©tition', 'Category', 'Program', 'Date analyse', 'Nb √©quipes']
            ];
            
            resultats.forEach(r => {
                const comp = liste.find(c => String(c.id) === String(r.compId));
                resumeData.push([
                    comp ? comp.n : 'Inconnue',
                    r.cat,
                    r.prog === 'SP' ? 'Short Program' : 'Free Program',
                    new Date(r.date).toLocaleDateString(),
                    r.data.equipes.length
                ]);
            });
            
            const wsResume = XLSX.utils.aoa_to_sheet(resumeData);
            wsResume['!cols'] = [{wch: 30}, {wch: 10}, {wch: 18}, {wch: 15}, {wch: 12}];
            XLSX.utils.book_append_sheet(wb, wsResume, 'Summary');
            
            // ONGLETS PAR COMP√âTITION
            resultats.forEach((res, index) => {
                const comp = liste.find(c => String(c.id) === String(res.compId));
                const sheetName = `${index + 1}. ${(comp ? comp.n : 'Comp').substring(0, 20)}`;
                
                const ws = genererFeuilleExcel(res, comp);
                XLSX.utils.book_append_sheet(wb, ws, sheetName);
            });
            
            // T√âL√âCHARGER
            const fileName = `Synchro_Saison_2025-26_${new Date().toISOString().split('T')[0]}.xlsx`;
            XLSX.writeFile(wb, fileName);
            
            alert(`‚úÖ Export Excel termin√© !\n\n${resultats.length} comp√©tition(s) export√©e(s)`);
        }

        function exporterUnResultat(resId) {
            const res = resultats.find(r => r.id === resId);
            if (!res) {
                alert('R√©sultat introuvable');
                return;
            }
            
            const comp = liste.find(c => String(c.id) === String(res.compId));
            const wb = XLSX.utils.book_new();
            const ws = genererFeuilleExcel(res, comp);
            XLSX.utils.book_append_sheet(wb, ws, 'R√©sultats');
            
            const fileName = `${comp ? comp.n.replace(/[^a-zA-Z0-9]/g, '_') : 'Competition'}_${res.cat}_${res.prog}.xlsx`;
            XLSX.writeFile(wb, fileName);
        }

        function genererFeuilleExcel(res, comp) {
            const protocol = res.data;
            const numJudges = protocol.equipes[0]?.elements[0]?.juges.length || 0;
            
            const elementRankings = calculateElementRankings(protocol);
            const technicalRankings = calculateTechnicalRankings(protocol);
            const componentsRankings = calculateComponentsRankings(protocol);
            const baseValueRankings = calculateBaseValueRankings(protocol);
            const compositionRankings = calculateCompositionRankings(protocol);
            const presentationRankings = calculatePresentationRankings(protocol);
            const skatingSkillsRankings = calculateSkatingSkillsRankings(protocol);
            
            const data = [];
            
            // EN-T√äTE
            data.push([comp ? comp.n : 'Comp√©tition', '', '', '', '', '', '']);
            data.push([`${res.cat} - ${res.prog === 'SP' ? 'Short Program' : 'Free Program'}`, '', '', '', '', '', '']);
            data.push([`Analys√© le ${new Date(res.date).toLocaleDateString()}`, '', '', '', '', '', '']);
            data.push(['']);
            
            // CLASSEMENT G√âN√âRAL
            data.push(['CLASSEMENT G√âN√âRAL']);
            data.push(['Rank', 'Team', 'Nation', 'Total', 'Technique', 'Pr√©sentation']);
            
            protocol.equipes.forEach(team => {
                data.push([
                    team.rang,
                    team.nom,
                    team.nation,
                    team.total,
                    team.tech,
                    team.pres
                ]);
            });
            
            data.push(['']);
            data.push(['']);
            
            // POUR CHAQUE √âQUIPE
            protocol.equipes.forEach(team => {
                const techRank = technicalRankings[team.nom];
                const compRank = componentsRankings[team.nom];
                const bvRank = baseValueRankings[team.nom];
                const totalBV = team.elements.reduce((sum, el) => sum + el.bv, 0);
                
                data.push([`${team.rang}. ${team.nom} (${team.nation})`]);
                data.push(['']);
                
                // TECHNICAL ELEMENTS
                data.push(['TECHNICAL ELEMENTS']);
                const headerElements = ['Element', 'Level', 'BV', 'GOE', 'Score', 'Rank'];
                for (let j = 1; j <= numJudges; j++) {
                    headerElements.push(`J${j}`);
                }
                data.push(headerElements);
                
                team.elements.forEach(element => {
                    const elementType = element.type;
                    const niveauCalcule = getNiveauFromCode(element.code, element.type);
                    let teamElementData = elementRankings[elementType] ? 
                        elementRankings[elementType].find(e => e.teamName === team.nom && e.level === niveauCalcule) : null;
                    
                    if (!teamElementData && (elementType === 'ME' || elementType === 'Pa') && elementRankings['ME/Pa']) {
                        teamElementData = elementRankings['ME/Pa'].find(e => e.teamName === team.nom && e.level === niveauCalcule);
                    }
                    
                    const elementRank = teamElementData ? teamElementData.elementRank : '-';
                    
                    const row = [
                        `${elementType}${element.chute ? ' (CHUTE)' : ''}`,
                        `Niv ${getNiveauFromCode(element.code, element.type)}`,
                        element.bv,
                        element.goe,
                        element.score,
                        elementRank
                    ];
                    
                    element.juges.forEach(goe => row.push(goe));
                    data.push(row);
                    
                    // Rangs des juges pour cet √©l√©ment
                    const rankRow = ['Rangs juges', '', '', '', '', ''];
                    for (let j = 0; j < numJudges; j++) {
                        let elementDataForJudge = elementRankings[elementType];
                        if (!elementDataForJudge && (elementType === 'ME' || elementType === 'Pa') && elementRankings['ME/Pa']) {
                            elementDataForJudge = elementRankings['ME/Pa'];
                        }
                        
                        const judgeRanks = calculateJudgeRanksForElement(elementDataForJudge, j);
                        const judgeRank = judgeRanks[team.nom] || '-';
                        rankRow.push(judgeRank);
                    }
                    data.push(rankRow);
                });
                
                // TECHNICAL TOTAL
                const totalTechRow = ['TECHNICAL TOTAL', '', `BV: ${totalBV.toFixed(2)}`, '', `Score: ${team.tech.toFixed(2)}`, techRank];
                for (let j = 0; j < numJudges; j++) {
                    const judgeData = calculateJudgeTechnicalRankings(protocol, j);
                    const judgeScore = judgeData.scores.find(s => s.teamName === team.nom);
                    totalTechRow.push(judgeScore ? judgeScore.score.toFixed(2) : '-');
                }
                data.push(totalTechRow);
                
                const rankTechRow = ['Rangs Tech', '', `BV Rang: ${bvRank}`, '', '', ''];
                for (let j = 0; j < numJudges; j++) {
                    const judgeData = calculateJudgeTechnicalRankings(protocol, j);
                    const judgeRank = judgeData.ranks[team.nom] || '-';
                    rankTechRow.push(judgeRank);
                }
                data.push(rankTechRow);
                
                data.push(['']);
                
                // COMPOSANTES
                data.push(['COMPOSANTES']);
                const headerComp = ['Composante', 'Score'];
                for (let j = 1; j <= numJudges; j++) {
                    headerComp.push(`J${j}`);
                }
                data.push(headerComp);
                
                // Composition
                const compRankFinal = compositionRankings[team.nom];
                const rowComp = ['Composition', team.composantes.compFinal ? team.composantes.compFinal.toFixed(2) : '-'];
                team.composantes.composition.forEach(s => rowComp.push(s.toFixed(2)));
                data.push(rowComp);
                
                const rankCompRow = ['Rangs Comp', compRankFinal];
                for (let j = 0; j < numJudges; j++) {
                    const judgeRanks = calculateJudgeCompositionRankings(protocol, j);
                    const judgeRank = judgeRanks[team.nom] || '-';
                    rankCompRow.push(judgeRank);
                }
                data.push(rankCompRow);
                
                // Presentation
                const presRankFinal = presentationRankings[team.nom];
                const rowPres = ['Presentation', team.composantes.presFinal ? team.composantes.presFinal.toFixed(2) : '-'];
                team.composantes.presentation.forEach(s => rowPres.push(s.toFixed(2)));
                data.push(rowPres);
                
                const rankPresRow = ['Rangs Pr√©s', presRankFinal];
                for (let j = 0; j < numJudges; j++) {
                    const judgeRanks = calculateJudgePresentationRankings(protocol, j);
                    const judgeRank = judgeRanks[team.nom] || '-';
                    rankPresRow.push(judgeRank);
                }
                data.push(rankPresRow);
                
                // Skating Skills
                const skatRankFinal = skatingSkillsRankings[team.nom];
                const rowSkat = ['Skating Skills', team.composantes.skatFinal ? team.composantes.skatFinal.toFixed(2) : '-'];
                team.composantes.skatingSkills.forEach(s => rowSkat.push(s.toFixed(2)));
                data.push(rowSkat);
                
                const rankSkatRow = ['Rangs Skating', skatRankFinal];
                for (let j = 0; j < numJudges; j++) {
                    const judgeRanks = calculateJudgeSkatingSkillsRankings(protocol, j);
                    const judgeRank = judgeRanks[team.nom] || '-';
                    rankSkatRow.push(judgeRank);
                }
                data.push(rankSkatRow);
                
                // TOTAL COMPOSANTES
                const totalCompRow = ['TOTAL', team.pres.toFixed(2)];
                for (let j = 0; j < numJudges; j++) {
                    const sumBeforeFactor = (team.composantes.composition[j] || 0) + 
                                           (team.composantes.presentation[j] || 0) + 
                                           (team.composantes.skatingSkills[j] || 0);
                    const totalWithFactor = sumBeforeFactor * protocol.facteur;
                    totalCompRow.push(totalWithFactor.toFixed(2));
                }
                data.push(totalCompRow);
                
                const rankCompTotalRow = ['Rangs Pr√©s', compRank];
                for (let j = 0; j < numJudges; j++) {
                    const judgeRanks = calculateJudgeComponentsRankings(protocol, j);
                    const judgeRank = judgeRanks[team.nom] || '-';
                    rankCompTotalRow.push(judgeRank);
                }
                data.push(rankCompTotalRow);
                
                data.push(['']);
                data.push(['']);
            });
            
            const ws = XLSX.utils.aoa_to_sheet(data);
            
            // Largeurs des colonnes
            ws['!cols'] = [
                {wch: 20}, // √âl√©ment/Composante
                {wch: 10}, // Niveau/Score
                {wch: 10}, // BV
                {wch: 10}, // GOE
                {wch: 10}, // Score
                {wch: 8}   // Rang
            ];
            for (let j = 0; j < numJudges; j++) {
                ws['!cols'].push({wch: 8});
            }
            
            // Couleurs pour les rangs (optional - n√©cessite xlsx-style)
            // Pour l'instant, on laisse simple
            
            return ws;
        }

        // AFFICHAGE D√âTAILL√â (voirRes - identique √† v42)
        
        // ============================================
        // AFFICHAGE VUE SOMMAIRE DES R√âSULTATS
        // ============================================
        
        function afficherVueSommaire(resId) {
            const res = resultats.find(r => r.id === resId);
            if (!res) {
                alert('R√©sultat introuvable !');
                return;
            }
            
            const comp = liste.find(c => String(c.id) === String(res.compId));
            const titre = `${comp ? comp.n : 'Comp√©tition'}`;
            
            document.getElementById('modalTitle').textContent = titre;
            
            // Chercher toutes les cat√©gories disponibles pour cette comp√©tition
            const resultatsComp = resultats.filter(r => String(r.compId) === String(res.compId));
            const categoriesDisponibles = [...new Set(resultatsComp.map(r => r.cat))];
            
            let html = '<button class="btn btn-primary" onclick="ouvrirCompUpload(\'' + res.compId + '\')">‚Üê Back to competition</button>';
            html += '<button class="btn" style="background:#FF9800;color:white;margin-left:10px;" onclick="ouvrirCompUpload(\'' + res.compId + '\')">üìÑ Manage PDFs</button>';
            html += '<button class="btn btn-excel" onclick="exporterUnResultat(\'' + res.id + '\')" style="margin-left:10px;">üìä Excel</button>';
            
            // ===== INTERFACE DE R√âPARATION AUTO =====
            const problemes = detecterElementsManquantsCompetition(res);
            if (problemes.length > 0) {
                const totalManquants = problemes.reduce((sum, p) => sum + p.manquants.length, 0);
                html += `<div style="background:#fff3cd;border:2px solid #ffc107;border-radius:8px;padding:15px;margin:15px 0;">
                    <div style="display:flex;align-items:center;gap:10px;margin-bottom:10px;">
                        <span style="font-size:24px;">‚ö†Ô∏è</span>
                        <div style="flex:1;">
                            <strong style="color:#856404;">${totalManquants} √©l√©ment(s) manquant(s) d√©tect√©(s)</strong>
                            <div style="font-size:0.9em;color:#856404;margin-top:3px;">
                                ${problemes.map(p => `<strong>${p.equipe}</strong> (#${p.manquants.join(', #')})`).join(', ')}
                            </div>
                        </div>
                    </div>
                    <div style="display:flex;gap:10px;align-items:center;">
                        <label for="repairPdf_${res.id}" style="flex:1;padding:12px;background:#fff;border:2px dashed #ffc107;border-radius:6px;text-align:center;cursor:pointer;transition:all 0.2s;" onmouseover="this.style.background='#fffbf0'" onmouseout="this.style.background='#fff'">
                            <input type="file" id="repairPdf_${res.id}" accept=".pdf" style="display:none;" onchange="handleRepairPdf(event, '${res.id}')">
                            üìÑ D√©posez le PDF ici pour r√©parer automatiquement
                        </label>
                    </div>
                    <div id="repairProgress_${res.id}" style="display:none;margin-top:10px;padding:10px;background:#d4edda;border-radius:4px;"></div>
                </div>`;
            }
            
            // Onglets de cat√©gories
            if (categoriesDisponibles.length > 1) {
                html += '<div style="margin:20px 0;border-bottom:2px solid #e0e0e0;">';
                categoriesDisponibles.forEach(cat => {
                    const isActive = cat === res.cat;
                    html += `<button class="btn" style="background:${isActive ? '#667eea' : '#f5f5f5'};color:${isActive ? 'white' : '#666'};border-radius:8px 8px 0 0;margin-right:5px;" onclick="afficherCategorie('${res.compId}', '${cat}')">${cat}</button>`;
                });
                html += '</div>';
            }
            
            // Afficher le contenu pour la cat√©gorie s√©lectionn√©e
            html += genererContenuCategorie(res.compId, res.cat);
            
            document.getElementById('modalBody').innerHTML = html;
            document.getElementById('modal').classList.add('active');
        }
        
        function afficherCategorie(compId, categorie) {
            // Trouver un r√©sultat pour cette cat√©gorie
            const res = resultats.find(r => String(r.compId) === String(compId) && r.cat === categorie);
            if (res) {
                afficherVueSommaire(res.id);
            }
        }
        
        // Basculer entre les onglets de vue
        function switchViewTab(compId, categorie, tabName) {
            // Cacher tous les contenus
            document.querySelectorAll('.view-content').forEach(el => el.classList.remove('active'));
            // D√©sactiver tous les onglets
            document.querySelectorAll('.view-tab').forEach(el => el.classList.remove('active'));
            
            // Activer l'onglet s√©lectionn√©
            const tab = document.getElementById('view-tab-' + tabName);
            const content = document.getElementById('view-content-' + tabName);
            
            if (tab) tab.classList.add('active');
            if (content) content.classList.add('active');
        }
        // Basculer entre sous-onglets
        
        // ===== FONCTION DE D√âTECTION DES √âL√âMENTS MANQUANTS =====
        function detecterElementsManquants(equipe) {
            if (!equipe.elements || equipe.elements.length === 0) return [];
            
            const numeros = equipe.elements.map(el => el.numero).filter(n => n && n > 0);
            if (numeros.length === 0) return [];
            
            const min = Math.min(...numeros);
            const max = Math.max(...numeros);
            const manquants = [];
            
            for (let i = min; i <= max; i++) {
                if (!numeros.includes(i)) {
                    manquants.push(i);
                }
            }
            
            return manquants;
        }
        
        function detecterElementsManquantsCompetition(res) {
            const problemes = [];
            if (!res || !res.data || !res.data.equipes) return problemes;
            
            res.data.equipes.forEach(eq => {
                const manquants = detecterElementsManquants(eq);
                if (manquants.length > 0) {
                    problemes.push({
                        equipe: eq.nom,
                        manquants: manquants
                    });
                }
            });
            
            return problemes;
        }
        
        // ===== FONCTION DE R√âPARATION AUTOMATIQUE =====
        async function handleRepairPdf(event, resId) {
            console.log('üîß handleRepairPdf appel√©e!');
            console.log('   resId:', resId);
            
            const file = event.target.files[0];
            console.log('   Fichier:', file ? file.name : 'AUCUN');
            
            if (!file) {
                alert('Aucun fichier s√©lectionn√©');
                return;
            }
            
            // Trouver le r√©sultat par son ID
            const res = resultats.find(r => r.id === resId);
            console.log('   R√©sultat trouv√©:', res ? (res.cat + ' ' + res.prog) : 'NON TROUV√â');
            
            if (!res) {
                alert('R√©sultat non trouv√© pour cette comp√©tition');
                return;
            }
            
            const progressDiv = document.getElementById('repairProgress_' + res.id);
            console.log('   ProgressDiv:', progressDiv ? 'TROUV√â' : 'NON TROUV√â');
            
            if (!progressDiv) {
                alert('√âl√©ment de progression non trouv√©');
                return;
            }
            
            progressDiv.style.display = 'block';
            progressDiv.innerHTML = '‚è≥ Lecture du PDF...';
            
            try {
                console.log('   üìÑ Lecture du fichier...');
                const arrayBuffer = await file.arrayBuffer();
                console.log('   ‚úÖ Fichier lu:', arrayBuffer.byteLength, 'bytes');
                
                progressDiv.innerHTML = 'üîç Chargement PDF.js...';
                
                if (typeof pdfjsLib === 'undefined') {
                    throw new Error('PDF.js non charg√©!');
                }
                
                console.log('   üìñ Parsing PDF...');
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                console.log('   ‚úÖ PDF charg√©:', pdf.numPages, 'pages');
                
                progressDiv.innerHTML = 'üîç Extraction du texte (' + pdf.numPages + ' pages)...';
                
                let fullText = '';
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(item => item.str).join(' ');
                    fullText += pageText + '\n';
                    console.log('   Page', i, ':', pageText.length, 'caract√®res');
                }
                
                console.log('   ‚úÖ Texte total:', fullText.length, 'caract√®res');
                progressDiv.innerHTML = 'üîß Recherche des √©l√©ments...';
                
                // Rechercher les √©l√©ments avec le regex
                const elemPattern = /(\d+)\s+(SySp[B\d]?|TrE[B\d]?|NHEB?\+s[B\d]?|NHE[B\d]?\+s[B\d]?|I[B\d]?\+pi[B\d]?|ME[B\d]?<{0,2}|GL[B\d]?<{0,2}|PB[B\d]?|CrI[B\d]?|TwE[B\d]?|Pa[B\d]?|CrL[B\d]?|AL[B\d]?|AB[B\d]?|AW[B\d]?|AC[B\d]?|CrE[B\d]?|NHE[B\d]?)\s+(?:([<F!][x!<]*)\s+)?([\d\.]+)\s+([\-\+]?[\d\.]+)\s+((?:(?:[\-\+]?\d+|-)\s+)*)([\d\.]+)/g;
                
                const elementsTrouves = [];
                let match;
                while ((match = elemPattern.exec(fullText)) !== null) {
                    elementsTrouves.push({
                        numero: parseInt(match[1]),
                        fullCode: match[2]
                    });
                }
                
                console.log('   ‚úÖ √âl√©ments trouv√©s dans PDF:', elementsTrouves.map(e => '#' + e.numero + ' ' + e.fullCode).join(', '));
                
                progressDiv.innerHTML = 'üîß Ajout des √©l√©ments manquants...';
                
                // ===================================================
                // NOUVELLE APPROCHE : Grouper les √©l√©ments par s√©quence
                // (chaque fois que le num√©ro revient √† 1 = nouvelle √©quipe)
                // ===================================================
                const sequences = [];
                let sequenceActuelle = [];
                
                for (let i = 0; i < elementsTrouves.length; i++) {
                    const el = elementsTrouves[i];
                    if (el.numero === 1 && sequenceActuelle.length > 0) {
                        sequences.push(sequenceActuelle);
                        sequenceActuelle = [];
                    }
                    sequenceActuelle.push(el);
                }
                if (sequenceActuelle.length > 0) sequences.push(sequenceActuelle);
                
                console.log('   üìä S√©quences trouv√©es:', sequences.length, '√©quipes dans le PDF');
                
                // D√©tecter les manquants
                const problemes = detecterElementsManquantsCompetition(res);
                let totalAjoutes = 0;
                const erreurs = [];
                
                problemes.forEach(prob => {
                    const equipe = res.data.equipes.find(e => e.nom === prob.equipe);
                    if (!equipe) return;
                    
                    // Chercher la s√©quence du PDF qui correspond √† cette √©quipe
                    // En comparant les √©l√©ments CONNUS (ceux qu'on a d√©j√†)
                    let meilleureSequence = null;
                    let meilleurScore = 0;
                    
                    sequences.forEach(seq => {
                        let correspondances = 0;
                        equipe.elements.forEach(el => {
                            const trouve = seq.find(s => s.numero === el.numero && s.fullCode === el.code);
                            if (trouve) correspondances++;
                        });
                        if (correspondances > meilleurScore) {
                            meilleurScore = correspondances;
                            meilleureSequence = seq;
                        }
                    });
                    
                    console.log(`   üéØ ${prob.equipe}: s√©quence trouv√©e avec ${meilleurScore} correspondances`);
                    
                    if (!meilleureSequence || meilleurScore === 0) {
                        erreurs.push(`√âquipe "${prob.equipe}" non trouv√©e dans le PDF`);
                        return;
                    }
                    
                    prob.manquants.forEach(numManquant => {
                        // Chercher l'√©l√©ment manquant dans la s√©quence identifi√©e
                        const elTrouve = meilleureSequence.find(s => s.numero === numManquant);
                        
                        if (!elTrouve) {
                            erreurs.push(`√âl√©ment #${numManquant} non trouv√© pour ${prob.equipe}`);
                            return;
                        }
                        
                        const fullCode = elTrouve.fullCode;
                        
                        // Normaliser le type
                        let type = elementMapping[fullCode];
                        if (!type) {
                            if (fullCode.startsWith('GL')) type = 'GL';
                            else if (fullCode.startsWith('ME')) type = 'ME';
                            else type = fullCode.replace(/[B\d<]+$/, '');
                        }
                        
                        // Normaliser le niveau (inclut les downgrades: "4<", "3<<")
                        const niveauMatch = fullCode.match(/([B\d]<{0,2})$/);
                        const niveau = niveauMatch ? (niveauMatch[1] === 'B' ? 'Base' : niveauMatch[1]) : '';
                        
                        // R√©cup√©rer BV, GOE, juges, score depuis le texte complet
                        // Chercher dans le bloc de texte associ√© √† la s√©quence
                        const regex3 = new RegExp(
                            numManquant + '\\s+' + fullCode.replace(/[<+]/g, '\\$&') +
                            '\\s+(?:(?:[<F!][x!<]*)\\s+)?([\\d\\.]+)\\s+([\\-\\+]?[\\d\\.]+)\\s+((?:(?:[\\-\\+]?\\d+|-)\\s+)*)([\\d\\.]+)',
                            'g'
                        );
                        
                        let bv = 0, goe = 0, score = 0, jugesGOE = [], chute = false;
                        const matchTexte = regex3.exec(fullText);
                        
                        if (matchTexte) {
                            bv = parseFloat(matchTexte[1]);
                            goe = parseFloat(matchTexte[2]);
                            jugesGOE = matchTexte[3].trim().split(/\s+/)
                                .map(p => parseInt(p))
                                .filter(v => !isNaN(v) && v >= -5 && v <= 5);
                            score = parseFloat(matchTexte[4]);
                        }
                        
                        if (bv === 0 && score !== 0) {
                            erreurs.push(`BV introuvable pour #${numManquant} ${fullCode} de ${prob.equipe}`);
                            return;
                        }
                        
                        // Cr√©er l'√©l√©ment
                        const nouvelElement = {
                            numero: numManquant,
                            code: fullCode,
                            type: type,
                            niveau: niveau,
                            bv: bv,
                            goe: goe,
                            score: score,
                            juges: jugesGOE,
                            chute: chute
                        };
                        
                        // Ins√©rer √† la bonne position
                        const insertIdx = equipe.elements.findIndex(el => el.numero > numManquant);
                        if (insertIdx >= 0) {
                            equipe.elements.splice(insertIdx, 0, nouvelElement);
                        } else {
                            equipe.elements.push(nouvelElement);
                        }
                        
                        totalAjoutes++;
                        console.log(`‚úÖ Ajout√©: ${prob.equipe} #${numManquant} ${fullCode} ‚Üí type="${type}" niveau="${niveau}" bv=${bv} goe=${goe} score=${score}`);
                    });
                });
                
                if (totalAjoutes > 0) {
                    localStorage.setItem(DB_RES, JSON.stringify(resultats));
                    const resIdSauvegarde = res.id;
                    chargerDonnees(); // Recharge resultats depuis localStorage
                    const msg = erreurs.length > 0 
                        ? `‚úÖ ${totalAjoutes} √©l√©ment(s) ajout√©(s) !\n‚ö†Ô∏è ${erreurs.join(', ')}`
                        : `‚úÖ ${totalAjoutes} √©l√©ment(s) ajout√©(s) avec succ√®s !`;
                    progressDiv.innerHTML = msg;
                    setTimeout(() => afficherVueSommaire(resIdSauvegarde), 1500);
                } else {
                    progressDiv.innerHTML = erreurs.length > 0
                        ? '‚ùå ' + erreurs.join(' | ')
                        : '‚ö†Ô∏è Aucun √©l√©ment ajout√©';
                    console.log('Erreurs:', erreurs);
                }
                
            } catch (error) {
                console.error('‚ùå ERREUR:', error);
                progressDiv.innerHTML = '‚ùå Erreur: ' + error.message;
                alert('Erreur: ' + error.message + '\n\nVoir console (F12) pour d√©tails');
            }
        }
function switchSubTab(section, tab) {
            // Cacher tous les contenus de cette section
            document.querySelectorAll(`#${section}-pc, #${section}-pl`).forEach(el => el.classList.remove('active'));
            // D√©sactiver tous les sous-onglets de cette section  
            document.querySelectorAll('.sub-tab').forEach(el => el.classList.remove('active'));
            
            // Activer le contenu s√©lectionn√©
            const content = document.getElementById(`${section}-${tab}`);
            if (content) content.classList.add('active');
            
            // Activer le bouton
            event.target.classList.add('active');
        }


        // ONGLET 1 : R√âSUM√â
        function genererOngletResume(resPC, resPL) {
            let html = '';
            
            if (resPC && resPL) {
                html += '<div style="background:white;padding:20px;border-radius:10px;margin:20px 0;border:2px solid #667eea;">';
                html += '<h2 style="color:#1e3c72;margin-top:0;">üèÜ Total Score (SP+FP)</h2>';
                
                // Calculer les totaux
                const totaux = [];
                const equipesPC = resPC.data.equipes;
                const equipesPL = resPL.data.equipes;
                
                equipesPC.forEach(eqPC => {
                    const nomCanonique = eqPC.nom;
                    const eqPL = equipesPL.find(e => e.nom === nomCanonique);
                    
                    if (eqPL) {
                        const totalPC = eqPC.total || 0;
                        const totalPL = eqPL.total || 0;
                        const totalCombine = totalPC + totalPL;
                        
                        totaux.push({
                            nom: nomCanonique,
                            nation: eqPC.nation,
                            totalPC: totalPC,
                            totalPL: totalPL,
                            total: totalCombine
                        });
                    }
                });
                
                // Trier par total d√©croissant
                totaux.sort((a, b) => b.total - a.total);
                
                // Afficher le tableau
                html += '<table style="width:100%;border-collapse:collapse;margin-top:15px;"><thead><tr style="background:#f5f5f5;">';
                html += '<th style="padding:12px;text-align:left;border:1px solid #ddd;">Rank</th>';
                html += '<th style="padding:12px;text-align:left;border:1px solid #ddd;">Team</th>';
                html += '<th style="padding:12px;text-align:center;border:1px solid #ddd;">SP</th>';
                html += '<th style="padding:12px;text-align:center;border:1px solid #ddd;">FS</th>';
                html += '<th style="padding:12px;text-align:center;border:1px solid #ddd;">Total</th>';
                html += '<th style="padding:12px;text-align:center;border:1px solid #ddd;">Actions</th>';
                html += '</tr></thead><tbody>';
                
                totaux.forEach((eq, idx) => {
                    const rang = idx + 1;
                    let rankBadge = '';
                    const bgClass = rang === 1 ? 'rank-cell-1' : rang === 2 ? 'rank-cell-2' : rang === 3 ? 'rank-cell-3' : rang <= 7 ? 'rank-cell-' + rang : 'rank-cell-8plus';
                    
                    // Calculer le rang au PC
                    const totauxPC = [...totaux].sort((a, b) => b.totalPC - a.totalPC);
                    const rangPC = totauxPC.findIndex(t => t.nom === eq.nom) + 1;
                    const pcClass = rangPC === 1 ? 'rank-cell-1' : rangPC === 2 ? 'rank-cell-2' : rangPC === 3 ? 'rank-cell-3' : rangPC <= 7 ? 'rank-cell-' + rangPC : 'rank-cell-8plus';
                    
                    // Calculer le rang au PL
                    const totauxPL = [...totaux].sort((a, b) => b.totalPL - a.totalPL);
                    const rangPL = totauxPL.findIndex(t => t.nom === eq.nom) + 1;
                    const plClass = rangPL === 1 ? 'rank-cell-1' : rangPL === 2 ? 'rank-cell-2' : rangPL === 3 ? 'rank-cell-3' : rangPL <= 7 ? 'rank-cell-' + rangPL : 'rank-cell-8plus';
                    
                    // scoreClass pour le total (identique √† bgClass)
                    const scoreClass = bgClass;
if (rang === 1) rankBadge = rang;
                    else if (rang === 2) rankBadge = rang;
                    else if (rang === 3) rankBadge = rang;
                    else rankBadge = rang;
                    html += `<tr class="${bgClass}">`;
                    html += '<td style="padding:12px;text-align:center;border:1px solid #ddd;">' + rankBadge + '</td>';
                    html += '<td style="padding:12px;border:1px solid #ddd;"><strong>' + eq.nom + '</strong> (' + eq.nation + ')</td>';
                    html += '<td class="' + pcClass + '" style="padding:12px;text-align:center;border:1px solid #ddd;">' + eq.totalPC.toFixed(2) + '</td>';
                    html += '<td class="' + plClass + '" style="padding:12px;text-align:center;border:1px solid #ddd;">' + eq.totalPL.toFixed(2) + '</td>';
                    html += '<td class="' + scoreClass + '" style="padding:12px;text-align:center;border:1px solid #ddd;font-weight:bold;font-size:1.1em;">' + eq.total.toFixed(2) + '</td>';
                    html += '<td style="padding:12px;text-align:center;border:1px solid #ddd;"><button class="btn btn-small" style="background:#667eea;color:white;" onclick="voirDetailsEquipe(\'' + eq.nom + '\', \'' + resPC.id + '\', \'' + resPL.id + '\')">üîç Details</button></td>';
                    html += '</tr>';
                });
                
                html += '</tbody></table>';
                html += '</div>';
            }
            
            // Afficher PC seul si existe
            if (resPC) {
                const nomProg = resPC.prog === 'SP' ? 'SHORT PROGRAM' : 'SHORT PROGRAM';
                html += '<div style="background:white;padding:20px;border-radius:10px;margin:20px 0;border:2px solid #2196F3;">';
                html += '<h3 style="color:#1e3c72;margin-top:0;">üìò ' + nomProg + '</h3>';
                
                html += '<table style="width:100%;border-collapse:collapse;"><thead><tr style="background:#f5f5f5;">';
                html += '<th style="padding:12px;text-align:left;border:1px solid #ddd;">Rank</th>';
                html += '<th style="padding:12px;text-align:left;border:1px solid #ddd;">Team</th>';
                html += '<th style="padding:12px;text-align:center;border:1px solid #ddd;">Total Score</th>';
                html += '<th style="padding:12px;text-align:center;border:1px solid #ddd;">Tech</th>';
                html += '<th style="padding:12px;text-align:center;border:1px solid #ddd;">Pr√©s</th>';
                html += '<th style="padding:12px;text-align:center;border:1px solid #ddd;">Actions</th>';
                html += '</tr></thead><tbody>';
                
                const equipesPC = [...resPC.data.equipes].sort((a, b) => b.total - a.total);
                equipesPC.forEach((eq, idx) => {
                    const rang = idx + 1;
                    let rankBadge = '';
                    const bgClass = rang === 1 ? 'rank-cell-1' : rang === 2 ? 'rank-cell-2' : rang === 3 ? 'rank-cell-3' : rang <= 7 ? 'rank-cell-' + rang : 'rank-cell-8plus';
                    
                    // Calculer le rang en Tech
                    const equipesPCTech = [...equipesPC].sort((a, b) => b.tech - a.tech);
                    const rangTech = equipesPCTech.findIndex(e => e.nom === eq.nom) + 1;
                    const techClass = rangTech === 1 ? 'rank-cell-1' : rangTech === 2 ? 'rank-cell-2' : rangTech === 3 ? 'rank-cell-3' : rangTech <= 7 ? 'rank-cell-' + rangTech : 'rank-cell-8plus';
                    
                    // Calculer le rang en Pr√©s
                    const equipesPCPres = [...equipesPC].sort((a, b) => b.pres - a.pres);
                    const rangPres = equipesPCPres.findIndex(e => e.nom === eq.nom) + 1;
                    const presClass = rangPres === 1 ? 'rank-cell-1' : rangPres === 2 ? 'rank-cell-2' : rangPres === 3 ? 'rank-cell-3' : rangPres <= 7 ? 'rank-cell-' + rangPres : 'rank-cell-8plus';
                    
                    // scoreClass pour le total PC
                    const scoreClass = bgClass;
if (rang === 1) rankBadge = rang;
                    else if (rang === 2) rankBadge = rang;
                    else if (rang === 3) rankBadge = rang;
                    else rankBadge = rang;
                    
                    // Calculer le rang en Tech
                    
                    // Calculer le rang en Pr√©s
                    
                    
                    html += `<tr class="${bgClass}">`;
                    html += '<td style="padding:12px;text-align:center;border:1px solid #ddd;">' + rankBadge + '</td>';
                    html += '<td style="padding:12px;border:1px solid #ddd;"><strong>' + eq.nom + '</strong> (' + eq.nation + ')</td>';
                    html += '<td class="' + scoreClass + '" style="padding:12px;text-align:center;font-weight:bold;font-size:1.2em;border:1px solid #ddd;">' + eq.total.toFixed(2) + '</td>';
                    html += '<td style="padding:12px;text-align:right;border:1px solid #ddd;">' + eq.tech.toFixed(2) + '</td>';
                    html += '<td style="padding:12px;text-align:right;border:1px solid #ddd;">' + eq.pres.toFixed(2) + '</td>';
                    html += '<td style="padding:12px;text-align:center;border:1px solid #ddd;"><button class="btn btn-small" style="background:#2196F3;color:white;" onclick="voirDetailsEquipe(\'' + eq.nom + '\', \'' + resPC.id + '\', null)">üîç Details</button></td>';
                    html += '</tr>';
                });
                
                html += '</tbody></table>';
                html += '</div>';
            }
            
            // Afficher PL seul si existe
            if (resPL) {
                const nomProg = resPL.prog === 'FS' ? 'FREE PROGRAM' : 'FREE SKATING';
                html += '<div style="background:white;padding:20px;border-radius:10px;margin:20px 0;border:2px solid #4CAF50;">';
                html += '<h3 style="color:#1e3c72;margin-top:0;">üìó ' + nomProg + '</h3>';
                
                html += '<table style="width:100%;border-collapse:collapse;"><thead><tr style="background:#f5f5f5;">';
                html += '<th style="padding:12px;text-align:left;border:1px solid #ddd;">Rank</th>';
                html += '<th style="padding:12px;text-align:left;border:1px solid #ddd;">Team</th>';
                html += '<th style="padding:12px;text-align:center;border:1px solid #ddd;">Total Score</th>';
                html += '<th style="padding:12px;text-align:center;border:1px solid #ddd;">Tech</th>';
                html += '<th style="padding:12px;text-align:center;border:1px solid #ddd;">Pr√©s</th>';
                html += '<th style="padding:12px;text-align:center;border:1px solid #ddd;">Actions</th>';
                html += '</tr></thead><tbody>';
                
                const equipesPL = [...resPL.data.equipes].sort((a, b) => b.total - a.total);
                equipesPL.forEach((eq, idx) => {
                    const rang = idx + 1;
                    let rankBadge = '';
                    const bgClass = rang === 1 ? 'rank-cell-1' : rang === 2 ? 'rank-cell-2' : rang === 3 ? 'rank-cell-3' : rang <= 7 ? 'rank-cell-' + rang : 'rank-cell-8plus';
                    
                    // Calculer le rang en Tech
                    const equipesPLTech = [...equipesPL].sort((a, b) => b.tech - a.tech);
                    const rangTech = equipesPLTech.findIndex(e => e.nom === eq.nom) + 1;
                    const techClass = rangTech === 1 ? 'rank-cell-1' : rangTech === 2 ? 'rank-cell-2' : rangTech === 3 ? 'rank-cell-3' : rangTech <= 7 ? 'rank-cell-' + rangTech : 'rank-cell-8plus';
                    
                    // Calculer le rang en Pr√©s
                    const equipesPLPres = [...equipesPL].sort((a, b) => b.pres - a.pres);
                    const rangPres = equipesPLPres.findIndex(e => e.nom === eq.nom) + 1;
                    const presClass = rangPres === 1 ? 'rank-cell-1' : rangPres === 2 ? 'rank-cell-2' : rangPres === 3 ? 'rank-cell-3' : rangPres <= 7 ? 'rank-cell-' + rangPres : 'rank-cell-8plus';
                    
                    // scoreClass pour le total PL
                    const scoreClass = bgClass;
                    if (rang === 1) rankBadge = rang;
                    else if (rang === 2) rankBadge = rang;
                    else if (rang === 3) rankBadge = rang;
                    else rankBadge = rang;
                    
                    // Calculer le rang en Tech
                    
                    // Calculer le rang en Pr√©s
                    html += `<tr class="${bgClass}">`;
                    html += '<td style="padding:12px;text-align:center;border:1px solid #ddd;">' + rankBadge + '</td>';
                    html += '<td style="padding:12px;border:1px solid #ddd;"><strong>' + eq.nom + '</strong> (' + eq.nation + ')</td>';
                    html += '<td class="' + scoreClass + '" style="padding:12px;text-align:center;font-weight:bold;font-size:1.1em;border:1px solid #ddd;">' + eq.total.toFixed(2) + '</td>';
                    html += '<td style="padding:12px;text-align:right;border:1px solid #ddd;">' + eq.tech.toFixed(2) + '</td>';
                    html += '<td style="padding:12px;text-align:right;border:1px solid #ddd;">' + eq.pres.toFixed(2) + '</td>';
                    html += '<td style="padding:12px;text-align:center;border:1px solid #ddd;"><button class="btn btn-small" style="background:#4CAF50;color:white;" onclick="voirDetailsEquipe(\'' + eq.nom + '\', null, \'' + resPL.id + '\')">üîç Details</button></td>';
                    html += '</tr>';
                });
                
                html += '</tbody></table>';
                html += '</div>';
            }
            
            return html;
        }

                // ONGLET 2 : TABLEAU DES JUGES
        function genererTableauJuges(resPC, resPL) {
            let html = '<div style="background:white;padding:20px;border-radius:10px;margin:20px 0;">';
            html += '<h2 style="color:#1e3c72;margin-top:0;">üë®‚Äç‚öñÔ∏è Judges</h2>';
            html += '<p style="margin-bottom:15px;">Total score by judge for each team (Tech + Pres - Deductions)</p>';
            
            // Sous-onglets PC / PL
            html += '<div class="sub-tabs">';
            if (resPC) html += '<button class="sub-tab active" onclick="switchSubTab(\'judges\', \'pc\')">üìò Short Program</button>';
            if (resPL) html += `<button class="sub-tab ${!resPC ? 'active' : ''}" onclick="switchSubTab('judges', 'pl')">üìó Free Program</button>`;
            html += '</div>';
            
            // Contenu PC
            if (resPC) {
                html += '<div class="sub-content active" id="judges-pc">';
                html += genererTableauJugesSimple(resPC);
                html += '</div>';
            }
            
            // Contenu PL
            if (resPL) {
                html += `<div class="sub-content ${!resPC ? 'active' : ''}" id="judges-pl">`;
                html += genererTableauJugesSimple(resPL);
                html += '</div>';
            }
            
            html += '</div>';
            return html;
        }
        
        // Fonction helper pour g√©n√©rer un tableau de juges
        function genererTableauJugesSimple(res) {
            const equipesTriees = [...res.data.equipes].sort((a, b) => b.total - a.total);
            const nbJuges = equipesTriees[0]?.composantes?.composition?.length || 0;
            
            let html = '<div style="overflow-x:auto;"><table style="width:100%;border-collapse:collapse;min-width:800px;">';
            html += '<thead><tr style="background:#f5f5f5;">';
            html += '<th style="padding:12px;border:1px solid #ddd;position:sticky;left:0;background:#f5f5f5;z-index:2;">Rank</th>';
            html += '<th style="padding:12px;border:1px solid #ddd;position:sticky;left:60px;background:#f5f5f5;z-index:2;">Team</th>';
            
            for (let j = 1; j <= nbJuges; j++) {
                html += `<th style="padding:12px;border:1px solid #ddd;text-align:center;">J${j}</th>`;
            }
            html += '</tr></thead><tbody>';
            
            equipesTriees.forEach((eq, idx) => {
                const rang = idx + 1;
                const bgClass = rang === 1 ? 'rank-cell-1' : rang === 2 ? 'rank-cell-2' : rang === 3 ? 'rank-cell-3' : rang <= 7 ? 'rank-cell-' + rang : 'rank-cell-8plus';
                const deductions = eq.tech + eq.pres - eq.total;
                
                html += `<tr>`;
                html += `<td class="${bgClass}" style="padding:12px;border:1px solid #ddd;text-align:center;position:sticky;left:0;z-index:1;">${rang}</td>`;
                html += `<td class="${bgClass}" style="padding:12px;border:1px solid #ddd;position:sticky;left:60px;z-index:1;"><strong>${eq.nom}</strong></td>`;
                
                // Pour chaque juge
                for (let j = 0; j < nbJuges; j++) {
                    const presScoreJuge = ((eq.composantes.composition[j] || 0) + 
                                          (eq.composantes.presentation[j] || 0) + 
                                          (eq.composantes.skatingSkills[j] || 0)) * res.data.facteur;
                    const totalJuge = eq.tech + presScoreJuge - deductions;
                    
                    // Calculer le rang
                    const rangsJuge = [];
                    equipesTriees.forEach(team => {
                        const teamDeductions = team.tech + team.pres - team.total;
                        const teamPresJuge = ((team.composantes.composition[j] || 0) + 
                                             (team.composantes.presentation[j] || 0) + 
                                             (team.composantes.skatingSkills[j] || 0)) * res.data.facteur;
                        const teamTotalJuge = team.tech + teamPresJuge - teamDeductions;
                        rangsJuge.push({ nom: team.nom, score: teamTotalJuge });
                    });
                    rangsJuge.sort((a, b) => b.score - a.score);
                    const rangJuge = rangsJuge.findIndex(r => r.nom === eq.nom) + 1;
                    
                    const cellClass = rangJuge === 1 ? 'rank-cell-1' : rangJuge === 2 ? 'rank-cell-2' : rangJuge === 3 ? 'rank-cell-3' : rangJuge <= 7 ? 'rank-cell-' + rangJuge : 'rank-cell-8plus';
                    
                    html += `<td class="${cellClass}" style="padding:12px;border:1px solid #ddd;text-align:center;">`;
                    html += `<div><strong>${totalJuge.toFixed(2)}</strong></div>`;
                    html += `<div style="font-size:0.85em;font-weight:600;">(${rangJuge})</div>`;
                    html += `</td>`;
                }
                
                html += `</tr>`;
            });
            
            html += '</tbody></table></div>';
            html += '<div style="margin-top:15px;padding:10px;background:#f5f5f5;border-radius:5px;font-size:0.9em;">';
            html += '<strong>Legend :</strong> Colors indicate the rank given by each judge. Gold = 1st, Silver = 2nd, Bronze = 3rd, Purple = 4th-7th.';
            html += '</div>';
            
            return html;
        }

                // ONGLET 3 : TABLEAU DES √âL√âMENTS
        function genererTableauElements(resPC, resPL) {
            let html = '<div style="background:white;padding:20px;border-radius:10px;margin:20px 0;">';
            html += '<h2 style="color:#1e3c72;margin-top:0;">üéØ Elements</h2>';
            html += '<p style="margin-bottom:15px;">Performance of each team by element (Level | Score | Rank)</p>';
            
            // Sous-onglets PC / PL
            html += '<div class="sub-tabs">';
            if (resPC) html += '<button class="sub-tab active" onclick="switchSubTab(\'elements\', \'pc\')">üìò Short Program</button>';
            if (resPL) html += `<button class="sub-tab ${!resPC ? 'active' : ''}" onclick="switchSubTab('elements', 'pl')">üìó Free Program</button>`;
            html += '</div>';
            
            // Contenu PC
            if (resPC) {
                html += '<div class="sub-content active" id="elements-pc">';
                html += genererTableauElementsSimple(resPC);
                html += '</div>';
            }
            
            // Contenu PL
            if (resPL) {
                html += `<div class="sub-content ${!resPC ? 'active' : ''}" id="elements-pl">`;
                html += genererTableauElementsSimple(resPL);
                html += '</div>';
            }
            
            html += '</div>';
            return html;
        }
        
        // Fonction helper pour g√©n√©rer un tableau d'√©l√©ments
        function genererTableauElementsSimple(res) {
            const equipesTriees = [...res.data.equipes].sort((a, b) => b.total - a.total);
            
            // Collecter tous les types d'√©l√©ments
            const typesElements = new Set();
            equipesTriees.forEach(eq => {
                eq.elements.forEach(el => {
                    typesElements.add(el.type);
                });
            });
            
            // FUSION ME/Pa : si aucune √©quipe n'a les deux en m√™me temps ‚Üí 1 seule colonne
            const hasME = typesElements.has('ME');
            const hasPa = typesElements.has('Pa');
            let fusionMEPa = false;
            if (hasME && hasPa) {
                const teamsWithBoth = equipesTriees.filter(eq =>
                    eq.elements.some(el => el.type === 'ME') &&
                    eq.elements.some(el => el.type === 'Pa')
                );
                if (teamsWithBoth.length === 0) {
                    fusionMEPa = true;
                    typesElements.delete('ME');
                    typesElements.delete('Pa');
                    typesElements.add('ME/Pa');
                }
            }
            
            const elementsOrdonnes = Array.from(typesElements).sort();
            
            let html = '<div style="overflow-x:auto;"><table style="width:100%;border-collapse:collapse;min-width:1000px;">';
            html += '<thead><tr style="background:#f5f5f5;">';
            html += '<th style="padding:12px;border:1px solid #ddd;position:sticky;left:0;background:#f5f5f5;z-index:2;">Rank</th>';
            html += '<th style="padding:12px;border:1px solid #ddd;position:sticky;left:60px;background:#f5f5f5;z-index:2;">Team</th>';
            
            elementsOrdonnes.forEach(type => {
                html += `<th style="padding:12px;border:1px solid #ddd;text-align:center;">${type}</th>`;
            });
            html += '</tr></thead><tbody>';
            
            equipesTriees.forEach((eq, idx) => {
                const rang = idx + 1;
                const bgClass = rang === 1 ? 'rank-cell-1' : rang === 2 ? 'rank-cell-2' : rang === 3 ? 'rank-cell-3' : rang <= 7 ? 'rank-cell-' + rang : 'rank-cell-8plus';
                
                html += `<tr>`;
                html += `<td class="${bgClass}" style="padding:12px;border:1px solid #ddd;text-align:center;position:sticky;left:0;z-index:1;">${rang}</td>`;
                html += `<td class="${bgClass}" style="padding:12px;border:1px solid #ddd;position:sticky;left:60px;z-index:1;"><strong>${eq.nom}</strong></td>`;
                
                elementsOrdonnes.forEach(type => {
                    // Pour ME/Pa, chercher ME ou Pa selon ce que l'√©quipe a
                    const typesAChercher = (type === 'ME/Pa') ? ['ME', 'Pa'] : [type];
                    const element = eq.elements.find(el => typesAChercher.includes(el.type));
                    
                    if (element) {
                        // Calcul du rang en tenant compte de la fusion ME/Pa
                        const scoresElement = [];
                        equipesTriees.forEach(team => {
                            const teamEl = team.elements.find(el => typesAChercher.includes(el.type));
                            if (teamEl) {
                                scoresElement.push({ nom: team.nom, score: teamEl.score });
                            }
                        });
                        scoresElement.sort((a, b) => b.score - a.score);
                        const rangElement = scoresElement.findIndex(s => s.nom === eq.nom) + 1;
                        
                        const cellClass = rangElement === 1 ? 'rank-cell-1' : rangElement === 2 ? 'rank-cell-2' : rangElement === 3 ? 'rank-cell-3' : rangElement <= 7 ? 'rank-cell-' + rangElement : 'rank-cell-8plus';
                        
                        // Afficher le vrai type si fusion (ME ou Pa)
                        const labelNiveau = fusionMEPa && type === 'ME/Pa' 
                            ? `${element.type}${element.niveau || ''}` 
                            : (element.niveau || '');
                        
                        html += `<td class="${cellClass}" style="padding:12px;border:1px solid #ddd;text-align:center;">`;
                        html += `<div style="font-weight:600;">${labelNiveau}</div>`;
                        html += `<div><strong>${element.score.toFixed(2)}</strong></div>`;
                        html += `<div style="font-size:0.85em;font-weight:600;">(${rangElement})</div>`;
                        html += `</td>`;
                    } else {
                        html += `<td style="padding:12px;border:1px solid #ddd;text-align:center;background:#f5f5f5;">-</td>`;
                    }
                });
                
                html += `</tr>`;
            });
            
            html += '</tbody></table></div>';
            html += '<div style="margin-top:15px;padding:10px;background:#f5f5f5;border-radius:5px;font-size:0.9em;">';
            html += '<strong>Legend :</strong> Colors indicate the rank for this element. Gold = 1st, Silver = 2nd, Bronze = 3rd, Purple = 4th-7th.';
            if (fusionMEPa) html += ' <em>ME/Pa = colonne fusionn√©e (Junior PL)</em>';
            html += '</div>';
            
            return html;
        }
                // ONGLET 4 : D√âTAILS (avec sous-onglets)
        function genererDetailsAvecSousOnglets(resPC, resPL) {
            let html = '<div style="background:white;padding:20px;border-radius:10px;margin:20px 0;">';
            html += '<h2 style="color:#1e3c72;margin-top:0;">üìã Complete Detailed Analysis</h2>';
            
            // Sous-onglets PC / PL
            html += '<div class="sub-tabs">';
            if (resPC) html += `<button class="sub-tab active" onclick="switchSubTab('details', 'pc')">üìò Short Program</button>`;
            if (resPL) html += `<button class="sub-tab ${!resPC ? 'active' : ''}" onclick="switchSubTab('details', 'pl')">üìó Free Program</button>`;
            html += '</div>';
            
            // Contenu PC
            if (resPC) {
                html += '<div class="sub-content active" id="details-pc">';
                html += genererContenuDetailleInline(resPC);
                html += '</div>';
            }
            
            // Contenu PL
            if (resPL) {
                html += `<div class="sub-content ${!resPC ? 'active' : ''}" id="details-pl">`;
                html += genererContenuDetailleInline(resPL);
                html += '</div>';
            }
            
            html += '</div>';
            return html;
        }
        
                                                // G√©n√©rer le contenu d√©taill√© pour un programme (version finale corrig√©e)
        function genererContenuDetailleInline(res) {
            const protocol = res.data;
            const numJudges = protocol.equipes[0]?.elements[0]?.juges?.length || 0;
            const facteur = protocol.facteur;
            
            const equipesSorted = [...protocol.equipes].sort((a, b) => (a.rang || 999) - (b.rang || 999));
            
            let html = '<div style="margin-top:20px;">';
            
            equipesSorted.forEach(team => {
                const displayRang = team.rang !== undefined && team.rang !== null ? team.rang : '-';
                const officialRank = team.rang || 999;
                const deductions = team.tech + team.pres - team.total;
                
                // Calculer les rangs technique et pr√©sentation
                const scoresTech = [];
                const scoresPres = [];
                equipesSorted.forEach(eq => {
                    scoresTech.push({ nom: eq.nom, score: eq.tech });
                    scoresPres.push({ nom: eq.nom, score: eq.pres });
                });
                scoresTech.sort((a, b) => b.score - a.score);
                scoresPres.sort((a, b) => b.score - a.score);
                const rangTech = scoresTech.findIndex(s => s.nom === team.nom) + 1;
                const rangPres = scoresPres.findIndex(s => s.nom === team.nom) + 1;
                
                html += `<div class="team-section" style="margin-bottom:40px;border:2px solid #667eea;border-radius:10px;padding:20px;background:white;box-shadow:0 4px 6px rgba(0,0,0,0.1);">`;
                
                // En-t√™te avec rangs technique et pr√©sentation
                html += `<div class="team-header-detailed">
                    <div class="team-title-detailed">${displayRang}. ${team.nom} (${team.nation})</div>
                    <div class="team-scores">
                        <div class="score-box">
                            <div class="label">Total Score</div>
                            <div class="value">${team.total.toFixed(2)}</div>
                            <div class="rank">Rang: ${displayRang}</div>
                        </div>
                        <div class="score-box">
                            <div class="label">Technical Score</div>
                            <div class="value">${team.tech.toFixed(2)}</div>
                            <div class="rank">Rang: ${rangTech}</div>
                        </div>
                        <div class="score-box">
                            <div class="label">Presentation Score</div>
                            <div class="value">${team.pres.toFixed(2)}</div>
                            <div class="rank">Rang: ${rangPres}</div>
                        </div>
                        <div class="score-box">
                            <div class="label">Deductions</div>
                            <div class="value" style="color: white;">${deductions > 0 ? '-' : ''}${Math.abs(deductions).toFixed(2)}</div>
                            <div class="rank" style="opacity: 0.7; font-size: 0.85em;">${deductions > 0 ? 'Penalties' : 'Aucune'}</div>
                        </div>
                    </div>
                </div>`;
                
                html += `<div style="overflow-x:auto;margin-top:20px;">
                    <table class="detailed-table" style="width:100%;min-width:800px;border-collapse:collapse;">
                        <thead>
                            <tr style="background:#f5f5f5;">
                                <th style="padding:10px;border:1px solid #ddd;text-align:left;">Element</th>
                                <th style="padding:10px;border:1px solid #ddd;">Level</th>
                                <th style="padding:10px;border:1px solid #ddd;">BV</th>
                                <th style="padding:10px;border:1px solid #ddd;">GOE</th>
                                <th style="padding:10px;border:1px solid #ddd;">Score</th>
                                <th style="padding:10px;border:1px solid #ddd;border-right:3px solid #999;">Rank</th>`;
                
                for (let j = 1; j <= numJudges; j++) {
                    html += `<th style="padding:10px;border:1px solid #ddd;">J${j}<br><span style="font-size:0.8em;font-weight:normal;">(GOE/Rang)</span></th>`;
                }
                html += `</tr></thead><tbody>`;
                
                // √âl√©ments techniques
                team.elements.forEach((el, elIdx) => {
                    const scoresElements = [];
                    equipesSorted.forEach(eq => {
                        // Comparer par TYPE only (chaque √©quipe place ses √©l√©ments dans un ordre diff√©rent)
                        // Pour I+pi on prend le m√™me index d'intersection (1√®re, 2√®me...)
                        const matchingEl = eq.elements.find(e => e.type === el.type);
                        if (matchingEl) {
                            scoresElements.push({ nom: eq.nom, score: matchingEl.score });
                        }
                    });
                    scoresElements.sort((a, b) => b.score - a.score);
                    const rangElement = scoresElements.findIndex(s => s.nom === team.nom) + 1;
                    
                    const elementColorClass = rangElement === 1 ? 'rank-cell-1-transparent' : 
                                             rangElement === 2 ? 'rank-cell-2-transparent' : 
                                             rangElement === 3 ? 'rank-cell-3-transparent' : 
                                             rangElement <= 7 ? `rank-cell-${rangElement}-transparent` : 'rank-cell-8plus-transparent';
                    
                    const rangsJugesElement = [];
                    for (let j = 0; j < numJudges; j++) {
                        const scoresJuge = [];
                        equipesSorted.forEach(eq => {
                            // Comparer par TYPE only
                            const matchingEl = eq.elements.find(e => e.type === el.type);
                            if (matchingEl && matchingEl.juges && matchingEl.juges[j] !== undefined) {
                                const scoreJuge = matchingEl.bv + matchingEl.juges[j];
                                scoresJuge.push({ nom: eq.nom, score: scoreJuge });
                            }
                        });
                        scoresJuge.sort((a, b) => b.score - a.score);
                        rangsJugesElement.push(scoresJuge.findIndex(s => s.nom === team.nom) + 1);
                    }
                    
                    html += `<tr>
                        <td class="${elementColorClass}" style="padding:10px;border:1px solid #ddd;text-align:left;"><strong>${el.type}${el.niveau || ''}</strong>${el.chute ? ' <span style="color:red;font-weight:bold;">F</span>' : ''}${el.bv === 0 && !el.niveau ? ' <span style="color:#f44336;font-size:0.75em;font-weight:bold;">NV</span>' : ''}</td>
                        <td class="${elementColorClass}" style="padding:10px;border:1px solid #ddd;text-align:center;">${el.bv === 0 && !el.niveau ? '<span style="color:#f44336;font-weight:bold;">NV</span>' : (el.niveau || '-')}</td>
                        <td class="${elementColorClass}" style="padding:10px;border:1px solid #ddd;text-align:center;">${el.bv.toFixed(2)}</td>
                        <td class="${elementColorClass}" style="padding:10px;border:1px solid #ddd;text-align:center;font-weight:bold;">${el.goe >= 0 ? '+' : ''}${el.goe.toFixed(2)}</td>
                        <td class="${elementColorClass}" style="padding:10px;border:1px solid #ddd;text-align:center;font-weight:bold;">${el.score.toFixed(2)}</td>
                        <td class="${elementColorClass}" style="padding:10px;border:1px solid #ddd;border-right:3px solid #999;text-align:center;font-weight:bold;">${rangElement}</td>`;
                    
                    el.juges.forEach((goe, jIdx) => {
                        const rangJuge = rangsJugesElement[jIdx];
                        let rangColor = rangJuge < rangElement ? '#2e7d32' : rangJuge > rangElement ? '#c62828' : '#000';
                        
                        html += `<td style="padding:8px;border:1px solid #ddd;text-align:center;background:white;">
                            <div style="font-weight:bold;">${goe > 0 ? '+' : ''}${goe}</div>
                            <div style="font-size:0.85em;color:${rangColor};margin-top:2px;font-weight:600;">(${rangJuge})</div>
                        </td>`;
                    });
                    html += `</tr>`;
                });
                
                // S√âPARATEUR FIN (2px)
                html += `<tr style="height:2px;"><td colspan="${6 + numJudges}" style="background:#e0e0e0;border:none;padding:0;"></td></tr>`;
                
                // TECHNICAL TOTAL - sans rowspan, avec couleur opaque sur colonnes 1-6
                html += `<tr style="font-weight:bold;">
                    <td colspan="4" class="rank-cell-${rangTech}-opaque" style="padding:15px;border:1px solid #ddd;font-size:1.1em;">TECHNICAL TOTAL</td>
                    <td class="rank-cell-${rangTech}-opaque" style="padding:15px;border:1px solid #ddd;text-align:center;font-size:1.3em;font-weight:bold;">${team.tech.toFixed(2)}</td>
                    <td class="rank-cell-${rangTech}-opaque" style="padding:15px;border:1px solid #ddd;border-right:3px solid #999;text-align:center;font-size:1.1em;font-weight:bold;">${rangTech}</td>`;
                
                for (let j = 0; j < numJudges; j++) {
                    let techScoreJuge = 0;
                    team.elements.forEach(el => {
                        if (el.juges && el.juges[j] !== undefined) {
                            techScoreJuge += el.bv + el.juges[j];
                        }
                    });
                    
                    const scoresTechJuge = [];
                    equipesSorted.forEach(eq => {
                        let techScore = 0;
                        eq.elements.forEach(el => {
                            if (el.juges && el.juges[j] !== undefined) {
                                techScore += el.bv + el.juges[j];
                            }
                        });
                        scoresTechJuge.push({ nom: eq.nom, score: techScore });
                    });
                    scoresTechJuge.sort((a, b) => b.score - a.score);
                    const rangTechJuge = scoresTechJuge.findIndex(s => s.nom === team.nom) + 1;
                    
                    let rangColor = rangTechJuge < officialRank ? '#2e7d32' : rangTechJuge > officialRank ? '#c62828' : '#000';
                    const colorClass = rangTechJuge === 1 ? 'rank-cell-1-transparent' : 
                                      rangTechJuge === 2 ? 'rank-cell-2-transparent' : 
                                      rangTechJuge === 3 ? 'rank-cell-3-transparent' : 
                                      rangTechJuge <= 7 ? `rank-cell-${rangTechJuge}-transparent` : 'rank-cell-8plus-transparent';
                    
                    html += `<td class="${colorClass}" style="padding:8px;border:1px solid #ddd;text-align:center;">
                        <div style="font-weight:bold;">${techScoreJuge.toFixed(2)}</div>
                        <div style="font-size:0.85em;color:${rangColor};margin-top:2px;font-weight:600;">(${rangTechJuge})</div>
                    </td>`;
                }
                html += `</tr>`;
                
                // S√âPARATEUR √âPAIS (5px) entre technique et pr√©sentation
                html += `<tr style="height:5px;"><td colspan="${6 + numJudges}" style="background:#bdbdbd;border:none;padding:0;"></td></tr>`;
                
                // COMPOSANTES
                ['composition', 'presentation', 'skatingSkills'].forEach(comp => {
                    const nomComp = comp === 'composition' ? 'Composition' : comp === 'presentation' ? 'Presentation' : 'Skating Skills';
                    
                    const scoreMoyenComp = team.composantes[comp].reduce((a, b) => a + b, 0) / team.composantes[comp].length;
                    const scoresComp = [];
                    equipesSorted.forEach(eq => {
                        const moyenne = eq.composantes[comp].reduce((a, b) => a + b, 0) / eq.composantes[comp].length;
                        scoresComp.push({ nom: eq.nom, score: moyenne });
                    });
                    scoresComp.sort((a, b) => b.score - a.score);
                    const rangComp = scoresComp.findIndex(s => s.nom === team.nom) + 1;
                    
                    const compColorClass = rangComp === 1 ? 'rank-cell-1-transparent' : 
                                          rangComp === 2 ? 'rank-cell-2-transparent' : 
                                          rangComp === 3 ? 'rank-cell-3-transparent' : 
                                          rangComp <= 7 ? `rank-cell-${rangComp}-transparent` : 'rank-cell-8plus-transparent';
                    
                    html += `<tr>
                        <td colspan="4" class="${compColorClass}" style="padding:10px;border:1px solid #ddd;font-weight:bold;">${nomComp}</td>
                        <td class="${compColorClass}" style="padding:10px;border:1px solid #ddd;text-align:center;font-weight:bold;">${scoreMoyenComp.toFixed(2)}</td>
                        <td class="${compColorClass}" style="padding:10px;border:1px solid #ddd;border-right:3px solid #999;text-align:center;font-weight:bold;">${rangComp}</td>`;
                    
                    team.composantes[comp].forEach((note, jIdx) => {
                        const scoresCompJuge = [];
                        equipesSorted.forEach(eq => {
                            scoresCompJuge.push({ nom: eq.nom, score: eq.composantes[comp][jIdx] });
                        });
                        scoresCompJuge.sort((a, b) => b.score - a.score);
                        const rangCompJuge = scoresCompJuge.findIndex(s => s.nom === team.nom) + 1;
                        
                        let rangColor = rangCompJuge < rangComp ? '#2e7d32' : rangCompJuge > rangComp ? '#c62828' : '#000';
                        
                        html += `<td style="padding:8px;border:1px solid #ddd;text-align:center;background:white;">
                            <div style="font-weight:bold;">${note.toFixed(2)}</div>
                            <div style="font-size:0.85em;color:${rangColor};margin-top:2px;font-weight:600;">(${rangCompJuge})</div>
                        </td>`;
                    });
                    html += `</tr>`;
                });
                
                // S√âPARATEUR FIN (2px)
                html += `<tr style="height:2px;"><td colspan="${6 + numJudges}" style="background:#e0e0e0;border:none;padding:0;"></td></tr>`;
                
                // PRESENTATION TOTAL - avec couleur opaque sur colonnes 1-6
                html += `<tr style="font-weight:bold;">
                    <td colspan="4" class="rank-cell-${rangPres}-opaque" style="padding:15px;border:1px solid #ddd;font-size:1.1em;">PRESENTATION TOTAL</td>
                    <td class="rank-cell-${rangPres}-opaque" style="padding:15px;border:1px solid #ddd;text-align:center;font-size:1.3em;font-weight:bold;">${team.pres.toFixed(2)}</td>
                    <td class="rank-cell-${rangPres}-opaque" style="padding:15px;border:1px solid #ddd;border-right:3px solid #999;text-align:center;font-size:1.1em;font-weight:bold;">${rangPres}</td>`;
                
                for (let j = 0; j < numJudges; j++) {
                    const presScore = (team.composantes.composition[j] + team.composantes.presentation[j] + team.composantes.skatingSkills[j]) * facteur;
                    
                    const scoresPresJuge = [];
                    equipesSorted.forEach(eq => {
                        const pScore = (eq.composantes.composition[j] + eq.composantes.presentation[j] + eq.composantes.skatingSkills[j]) * facteur;
                        scoresPresJuge.push({ nom: eq.nom, score: pScore });
                    });
                    scoresPresJuge.sort((a, b) => b.score - a.score);
                    const rangPresJuge = scoresPresJuge.findIndex(s => s.nom === team.nom) + 1;
                    
                    let rangColor = rangPresJuge < officialRank ? '#2e7d32' : rangPresJuge > officialRank ? '#c62828' : '#000';
                    const colorClass = rangPresJuge === 1 ? 'rank-cell-1-transparent' : 
                                      rangPresJuge === 2 ? 'rank-cell-2-transparent' : 
                                      rangPresJuge === 3 ? 'rank-cell-3-transparent' : 
                                      rangPresJuge <= 7 ? `rank-cell-${rangPresJuge}-transparent` : 'rank-cell-8plus-transparent';
                    
                    html += `<td class="${colorClass}" style="padding:8px;border:1px solid #ddd;text-align:center;">
                        <div style="font-weight:bold;">${presScore.toFixed(2)}</div>
                        <div style="font-size:0.85em;color:${rangColor};margin-top:2px;font-weight:600;">(${rangPresJuge})</div>
                    </td>`;
                }
                html += `</tr>`;
                
                // S√âPARATEUR √âPAIS (5px) avant total final
                html += `<tr style="height:5px;"><td colspan="${6 + numJudges}" style="background:#bdbdbd;border:none;padding:0;"></td></tr>`;
                
                // TOTAL PAR JUGE - avec couleur TR√àS opaque
                html += `<tr style="font-weight:bold;">
                    <td colspan="4" class="rank-cell-${officialRank}-very-opaque" style="padding:15px;border:1px solid #ddd;font-size:1.1em;">TOTAL PAR JUGE</td>
                    <td class="rank-cell-${officialRank}-very-opaque" style="padding:15px;border:1px solid #ddd;text-align:center;font-size:1.3em;font-weight:bold;">${team.total.toFixed(2)}</td>
                    <td class="rank-cell-${officialRank}-very-opaque" style="padding:15px;border:1px solid #ddd;border-right:3px solid #999;text-align:center;font-size:1.1em;font-weight:bold;">${displayRang}</td>`;
                
                for (let j = 0; j < numJudges; j++) {
                    let techScore = 0;
                    team.elements.forEach(el => {
                        if (el.juges && el.juges[j] !== undefined) {
                            techScore += el.bv + el.juges[j];
                        }
                    });
                    const presScore = (team.composantes.composition[j] + team.composantes.presentation[j] + team.composantes.skatingSkills[j]) * facteur;
                    const totalJuge = techScore + presScore - deductions;
                    
                    const scoresTotalJuge = [];
                    equipesSorted.forEach(eq => {
                        let tScore = 0;
                        eq.elements.forEach(el => {
                            if (el.juges && el.juges[j] !== undefined) {
                                tScore += el.bv + el.juges[j];
                            }
                        });
                        const pScore = (eq.composantes.composition[j] + eq.composantes.presentation[j] + eq.composantes.skatingSkills[j]) * facteur;
                        const eqDeductions = eq.tech + eq.pres - eq.total;
                        scoresTotalJuge.push({ nom: eq.nom, score: tScore + pScore - eqDeductions });
                    });
                    scoresTotalJuge.sort((a, b) => b.score - a.score);
                    const rangTotalJuge = scoresTotalJuge.findIndex(s => s.nom === team.nom) + 1;
                    
                    let rangColor = rangTotalJuge < officialRank ? '#2e7d32' : rangTotalJuge > officialRank ? '#c62828' : '#000';
                    const colorClass = rangTotalJuge === 1 ? 'rank-cell-1-very-opaque' : 
                                      rangTotalJuge === 2 ? 'rank-cell-2-very-opaque' : 
                                      rangTotalJuge === 3 ? 'rank-cell-3-very-opaque' : 
                                      rangTotalJuge <= 7 ? `rank-cell-${rangTotalJuge}-very-opaque` : 'rank-cell-8plus-very-opaque';
                    
                    html += `<td class="${colorClass}" style="padding:8px;border:1px solid #ddd;text-align:center;">
                        <div style="font-weight:bold;">${totalJuge.toFixed(2)}</div>
                        <div style="font-size:0.85em;color:${rangColor};margin-top:2px;font-weight:600;">(${rangTotalJuge})</div>
                    </td>`;
                }
                html += `</tr>`;
                
                html += `</tbody></table></div></div>`;
            });
            
            html += '</div>';
            return html;
        }

                        // ONGLET 4 et 5 : D√âTAILS COMPLET
        function genererDetailsComplet(res) {
            // Afficher directement le bouton voirRes qui montre tout
            let html = '<div style="padding:20px;">';
            html += `<div style="background:#e3f2fd;padding:20px;border-radius:10px;margin-bottom:20px;">`;
            html += `<h3 style="margin-top:0;">Pour voir l'analyse compl√®te avec tous les d√©tails :</h3>`;
            html += `<p style="margin:15px 0;">All les √©l√©ments techniques, composantes, rangs des juges, et comparaisons d√©taill√©es.</p>`;
            html += `<button class="btn" style="background:#4CAF50;color:white;font-size:1.1em;padding:15px 30px;" onclick="voirRes('${res.id}')">üëÅÔ∏è Voir Detailed Analysis Compl√®te</button>`;
            html += `</div></div>`;
            return html;
        }


        
                function genererContenuCategorie(compId, categorie) {
            // Chercher les 2 programmes (PC et PL) pour cette cat√©gorie
            const resultatsComp = resultats.filter(r => 
                String(r.compId) === String(compId) && 
                r.cat === categorie
            );
            
            // Chercher les programmes dans la base (PC/PL)
            const resPC = resultatsComp.find(r => r.prog === 'PC' || r.prog === 'SP');
            const resPL = resultatsComp.find(r => r.prog === 'PL' || r.prog === 'FS');
            
            let html = '';
            
            // CR√âATION DES ONGLETS DE VUE
            html += '<div class="view-tabs">';
            html += `<button class="view-tab active" id="view-tab-summary" onclick="switchViewTab('${compId}', '${categorie}', 'summary')">üìä Summary</button>`;
            html += `<button class="view-tab" id="view-tab-judges" onclick="switchViewTab('${compId}', '${categorie}', 'judges')">Judges</button>`;
            html += `<button class="view-tab" id="view-tab-elements" onclick="switchViewTab('${compId}', '${categorie}', 'elements')">Elements</button>`;
            if (resPC || resPL) html += `<button class="view-tab" id="view-tab-details" onclick="switchViewTab('${compId}', '${categorie}', 'details')">üìã Details</button>`;
            html += '</div>';
            
            // ONGLET 1: R√âSUM√â (contenu actuel)
            html += '<div class="view-content active" id="view-content-summary">';
            html += genererOngletResume(resPC, resPL);
            html += '</div>';
            
            // ONGLET 2: TABLEAU JUGES
            html += '<div class="view-content" id="view-content-judges">';
            html += genererTableauJuges(resPC, resPL);
            html += '</div>';
            
            // ONGLET 3: TABLEAU √âL√âMENTS
            html += '<div class="view-content" id="view-content-elements">';
            html += genererTableauElements(resPC, resPL);
            html += '</div>';
            
            // ONGLET 4: D√âTAILS (avec sous-onglets PC/PL)
            if (resPC || resPL) {
                html += '<div class="view-content" id="view-content-details">';
                html += genererDetailsAvecSousOnglets(resPC, resPL);
                html += '</div>';
            }
            
            return html;
        }
        
        function voirDetailsEquipe(nomEquipe, idPC, idPL) {
            // D√©terminer le compId et la cat√©gorie √† partir de l'un des r√©sultats
            let compId = null;
            let categorie = null;
            
            if (idPC) {
                const resPC = resultats.find(r => r.id === idPC);
                if (resPC) {
                    compId = resPC.compId;
                    categorie = resPC.cat;
                }
            } else if (idPL) {
                const resPL = resultats.find(r => r.id === idPL);
                if (resPL) {
                    compId = resPL.compId;
                    categorie = resPL.cat;
                }
            }
            
            let html = `<button class="btn btn-primary" onclick="afficherCategorie('${compId}', '${categorie}')">‚Üê Retour au classement</button>`;
            html += `<h2 style="color:#1e3c72;margin:20px 0;">${nomEquipe}</h2>`;
            
            // Afficher le PC si existe
            if (idPC) {
                const resPC = resultats.find(r => r.id === idPC);
                if (resPC) {
                    const nomCanonique = nomEquipe;
                    const equipePC = resPC.data.equipes.find(e => e.nom === nomCanonique);
                    
                    if (equipePC) {
                        // Calculer le rang bas√© sur le score
                        const equipesTriees = [...resPC.data.equipes].sort((a, b) => b.total - a.total);
                        const rangPC = equipesTriees.findIndex(e => e.nom === nomCanonique) + 1;
                        
                        html += '<div style="background:white;padding:20px;border-radius:10px;margin:20px 0;border:2px solid #2196F3;">';
                        html += '<h3 style="color:#1e3c72;margin-top:0;">üìò SHORT PROGRAM</h3>';
                        html += `<div style="margin-bottom:20px;"><strong>Total Score:</strong> ${equipePC.total.toFixed(2)} | <strong>Rang:</strong> ${rangPC}</div>`;
                        
                        // Tableau des √©l√©ments - AVEC SCROLL HORIZONTAL POUR MOBILE
                        html += '<h4>Elements Techniques</h4>';
                        html += '<div style="overflow-x: auto; -webkit-overflow-scrolling: touch; margin-bottom: 20px;">';
                        html += '<table style="width:100%;min-width:700px;border-collapse:collapse;"><thead><tr style="background:#f5f5f5;">';
                        html += '<th style="padding:8px;border:1px solid #ddd;">#</th>';
                        html += '<th style="padding:8px;border:1px solid #ddd;">Element</th>';
                        html += '<th style="padding:8px;border:1px solid #ddd;">BV</th>';
                        html += '<th style="padding:8px;border:1px solid #ddd;">GOE</th>';
                        html += '<th style="padding:8px;border:1px solid #ddd;">Score</th>';
                        
                        const nbJuges = equipePC.elements[0]?.juges.length || 0;
                        for (let j = 1; j <= nbJuges; j++) {
                            html += `<th style="padding:8px;border:1px solid #ddd;">J${j}</th>`;
                        }
                        html += '</tr></thead><tbody>';
                        
                        equipePC.elements.forEach((el, idx) => {
                            html += '<tr>';
                            html += `<td style="padding:8px;border:1px solid #ddd;">${idx + 1}</td>`;
                            html += `<td style="padding:8px;border:1px solid #ddd;"><strong>${el.type}${el.niveau || ''}</strong>${el.chute ? ' <span style="background:#f44336;color:white;padding:2px 6px;border-radius:4px;font-size:0.75em;">F</span>' : ''}${el.bv === 0 && !el.niveau ? ' <span style="background:#f44336;color:white;padding:2px 4px;border-radius:3px;font-size:0.7em;">NV</span>' : ''}</td>`;
                            html += `<td style="padding:8px;border:1px solid #ddd;">${el.bv.toFixed(2)}</td>`;
                            html += `<td style="padding:8px;border:1px solid #ddd;color:${el.goe >= 0 ? '#4caf50' : '#f44336'};">${el.goe >= 0 ? '+' : ''}${el.goe.toFixed(2)}</td>`;
                            html += `<td style="padding:8px;border:1px solid #ddd;"><strong>${el.score.toFixed(2)}</strong></td>`;
                            
                            el.juges.forEach(j => {
                                html += `<td style="padding:8px;border:1px solid #ddd;color:${j > 0 ? '#4caf50' : (j < 0 ? '#f44336' : '#666')};">${j > 0 ? '+' : ''}${j}</td>`;
                            });
                            html += '</tr>';
                        });
                        
                        html += `<tr style="background:#f5f5f5;font-weight:bold;">`;
                        html += `<td colspan="2" style="padding:8px;border:1px solid #ddd;">TECHNICAL TOTAL</td>`;
                        html += `<td colspan="${3 + nbJuges}" style="padding:8px;border:1px solid #ddd;text-align:right;">${equipePC.tech.toFixed(2)}</td>`;
                        html += '</tr></tbody></table></div>'; // Fermeture du wrapper scroll
                        
                        // Composantes - AVEC SCROLL HORIZONTAL POUR MOBILE
                        html += '<h4 style="margin-top:20px;">Composantes de Program</h4>';
                        html += '<div style="overflow-x: auto; -webkit-overflow-scrolling: touch; margin-bottom: 20px;">';
                        html += '<table style="width:100%;min-width:600px;border-collapse:collapse;"><thead><tr style="background:#f5f5f5;">';
                        html += '<th style="padding:8px;border:1px solid #ddd;">Composante</th>';
                        html += '<th style="padding:8px;border:1px solid #ddd;">Score Final</th>';
                        for (let j = 1; j <= nbJuges; j++) {
                            html += `<th style="padding:8px;border:1px solid #ddd;">J${j}</th>`;
                        }
                        html += '</tr></thead><tbody>';
                        
                        html += '<tr>';
                        html += '<td style="padding:8px;border:1px solid #ddd;">Composition</td>';
                        html += `<td style="padding:8px;border:1px solid #ddd;"><strong>${equipePC.composantes.compFinal.toFixed(2)}</strong></td>`;
                        equipePC.composantes.composition.forEach(s => {
                            html += `<td style="padding:8px;border:1px solid #ddd;">${s.toFixed(2)}</td>`;
                        });
                        html += '</tr>';
                        
                        html += '<tr>';
                        html += '<td style="padding:8px;border:1px solid #ddd;">Presentation</td>';
                        html += `<td style="padding:8px;border:1px solid #ddd;"><strong>${equipePC.composantes.presFinal.toFixed(2)}</strong></td>`;
                        equipePC.composantes.presentation.forEach(s => {
                            html += `<td style="padding:8px;border:1px solid #ddd;">${s.toFixed(2)}</td>`;
                        });
                        html += '</tr>';
                        
                        html += '<tr>';
                        html += '<td style="padding:8px;border:1px solid #ddd;">Skating Skills</td>';
                        html += `<td style="padding:8px;border:1px solid #ddd;"><strong>${equipePC.composantes.skatFinal.toFixed(2)}</strong></td>`;
                        equipePC.composantes.skatingSkills.forEach(s => {
                            html += `<td style="padding:8px;border:1px solid #ddd;">${s.toFixed(2)}</td>`;
                        });
                        html += '</tr>';
                        
                        html += `<tr style="background:#f5f5f5;font-weight:bold;">`;
                        html += `<td colspan="1" style="padding:8px;border:1px solid #ddd;">TOTAL COMPOSANTES</td>`;
                        html += `<td colspan="${1 + nbJuges}" style="padding:8px;border:1px solid #ddd;text-align:right;">${equipePC.pres.toFixed(2)}</td>`;
                        html += '</tr>';
                        
                        html += '</tbody></table></div>';
                    }
                }
            }
            
            // Afficher le PL si existe (m√™me structure)
            if (idPL) {
                const resPL = resultats.find(r => r.id === idPL);
                if (resPL) {
                    const nomCanonique = nomEquipe;
                    const equipePL = resPL.data.equipes.find(e => e.nom === nomCanonique);
                    
                    if (equipePL) {
                        // Calculer le rang bas√© sur le score
                        const equipesTriees = [...resPL.data.equipes].sort((a, b) => b.total - a.total);
                        const rangPL = equipesTriees.findIndex(e => e.nom === nomCanonique) + 1;
                        
                        html += '<div style="background:white;padding:20px;border-radius:10px;margin:20px 0;border:2px solid #4CAF50;">';
                        html += '<h3 style="color:#1e3c72;margin-top:0;">üìó FREE PROGRAM</h3>';
                        html += `<div style="margin-bottom:20px;"><strong>Total Score:</strong> ${equipePL.total.toFixed(2)} | <strong>Rang:</strong> ${rangPL}</div>`;
                        
                        // M√™me structure que PC - AVEC SCROLL HORIZONTAL POUR MOBILE
                        html += '<h4>Elements Techniques</h4>';
                        html += '<div style="overflow-x: auto; -webkit-overflow-scrolling: touch; margin-bottom: 20px;">';
                        html += '<table style="width:100%;min-width:700px;border-collapse:collapse;"><thead><tr style="background:#f5f5f5;">';
                        html += '<th style="padding:8px;border:1px solid #ddd;">#</th>';
                        html += '<th style="padding:8px;border:1px solid #ddd;">Element</th>';
                        html += '<th style="padding:8px;border:1px solid #ddd;">BV</th>';
                        html += '<th style="padding:8px;border:1px solid #ddd;">GOE</th>';
                        html += '<th style="padding:8px;border:1px solid #ddd;">Score</th>';
                        
                        const nbJuges = equipePL.elements[0]?.juges.length || 0;
                        for (let j = 1; j <= nbJuges; j++) {
                            html += `<th style="padding:8px;border:1px solid #ddd;">J${j}</th>`;
                        }
                        html += '</tr></thead><tbody>';
                        
                        equipePL.elements.forEach((el, idx) => {
                            html += '<tr>';
                            html += `<td style="padding:8px;border:1px solid #ddd;">${idx + 1}</td>`;
                            html += `<td style="padding:8px;border:1px solid #ddd;"><strong>${el.type}${el.niveau || ''}</strong>${el.chute ? ' <span style="background:#f44336;color:white;padding:2px 6px;border-radius:4px;font-size:0.75em;">F</span>' : ''}${el.bv === 0 && !el.niveau ? ' <span style="background:#f44336;color:white;padding:2px 4px;border-radius:3px;font-size:0.7em;">NV</span>' : ''}</td>`;
                            html += `<td style="padding:8px;border:1px solid #ddd;">${el.bv.toFixed(2)}</td>`;
                            html += `<td style="padding:8px;border:1px solid #ddd;color:${el.goe >= 0 ? '#4caf50' : '#f44336'};">${el.goe >= 0 ? '+' : ''}${el.goe.toFixed(2)}</td>`;
                            html += `<td style="padding:8px;border:1px solid #ddd;"><strong>${el.score.toFixed(2)}</strong></td>`;
                            
                            el.juges.forEach(j => {
                                html += `<td style="padding:8px;border:1px solid #ddd;color:${j > 0 ? '#4caf50' : (j < 0 ? '#f44336' : '#666')};">${j > 0 ? '+' : ''}${j}</td>`;
                            });
                            html += '</tr>';
                        });
                        
                        html += `<tr style="background:#f5f5f5;font-weight:bold;">`;
                        html += `<td colspan="2" style="padding:8px;border:1px solid #ddd;">TECHNICAL TOTAL</td>`;
                        html += `<td colspan="${3 + nbJuges}" style="padding:8px;border:1px solid #ddd;text-align:right;">${equipePL.tech.toFixed(2)}</td>`;
                        html += '</tr></tbody></table></div>'; // Fermeture du wrapper scroll
                        
                        // Composantes PL (m√™me structure) - AVEC SCROLL HORIZONTAL POUR MOBILE
                        html += '<h4 style="margin-top:20px;">Composantes de Program</h4>';
                        html += '<div style="overflow-x: auto; -webkit-overflow-scrolling: touch; margin-bottom: 20px;">';
                        html += '<table style="width:100%;min-width:600px;border-collapse:collapse;"><thead><tr style="background:#f5f5f5;">';
                        html += '<th style="padding:8px;border:1px solid #ddd;">Composante</th>';
                        html += '<th style="padding:8px;border:1px solid #ddd;">Score Final</th>';
                        for (let j = 1; j <= nbJuges; j++) {
                            html += `<th style="padding:8px;border:1px solid #ddd;">J${j}</th>`;
                        }
                        html += '</tr></thead><tbody>';
                        
                        html += '<tr>';
                        html += '<td style="padding:8px;border:1px solid #ddd;">Composition</td>';
                        html += `<td style="padding:8px;border:1px solid #ddd;"><strong>${equipePL.composantes.compFinal.toFixed(2)}</strong></td>`;
                        equipePL.composantes.composition.forEach(s => {
                            html += `<td style="padding:8px;border:1px solid #ddd;">${s.toFixed(2)}</td>`;
                        });
                        html += '</tr>';
                        
                        html += '<tr>';
                        html += '<td style="padding:8px;border:1px solid #ddd;">Presentation</td>';
                        html += `<td style="padding:8px;border:1px solid #ddd;"><strong>${equipePL.composantes.presFinal.toFixed(2)}</strong></td>`;
                        equipePL.composantes.presentation.forEach(s => {
                            html += `<td style="padding:8px;border:1px solid #ddd;">${s.toFixed(2)}</td>`;
                        });
                        html += '</tr>';
                        
                        html += '<tr>';
                        html += '<td style="padding:8px;border:1px solid #ddd;">Skating Skills</td>';
                        html += `<td style="padding:8px;border:1px solid #ddd;"><strong>${equipePL.composantes.skatFinal.toFixed(2)}</strong></td>`;
                        equipePL.composantes.skatingSkills.forEach(s => {
                            html += `<td style="padding:8px;border:1px solid #ddd;">${s.toFixed(2)}</td>`;
                        });
                        html += '</tr>';
                        
                        html += `<tr style="background:#f5f5f5;font-weight:bold;">`;
                        html += `<td colspan="1" style="padding:8px;border:1px solid #ddd;">TOTAL COMPOSANTES</td>`;
                        html += `<td colspan="${1 + nbJuges}" style="padding:8px;border:1px solid #ddd;text-align:right;">${equipePL.pres.toFixed(2)}</td>`;
                        html += '</tr>';
                        
                        html += '</tbody></table></div>';
                    }
                }
            }
            
            document.getElementById('modalBody').innerHTML = html;
            document.getElementById('modal').classList.add('active');
        }
        
        function voirRes(resId) {
            const res = resultats.find(r => r.id === resId);
            if (!res) {
                alert('R√©sultat introuvable !');
                return;
            }
            
            const comp = liste.find(c => String(c.id) === String(res.compId));
            const titre = `${comp ? comp.n : 'Comp√©tition'} - ${res.cat} ${res.prog}`;
            
            document.getElementById('modalTitle').textContent = titre;
            
            const protocol = res.data;
            const elementRankings = calculateElementRankings(protocol);
            const numJudges = protocol.equipes[0]?.elements[0]?.juges.length || 0;
            const technicalRankings = calculateTechnicalRankings(protocol);
            const componentsRankings = calculateComponentsRankings(protocol);
            const baseValueRankings = calculateBaseValueRankings(protocol);
            
            const compositionRankings = calculateCompositionRankings(protocol);
            const presentationRankings = calculatePresentationRankings(protocol);
            const skatingSkillsRankings = calculateSkatingSkillsRankings(protocol);
            
            let html = '<button class="btn btn-primary" onclick="ouvrirComp(\'' + res.compId + '\')">‚Üê Back to competition</button>';
            html += '<button class="btn btn-excel" onclick="exporterUnResultat(\'' + res.id + '\')" style="margin-left:10px;">üìä Exporter Excel</button>';
            html += '<div style="margin:20px 0;padding:15px;background:#e8f5e9;border-radius:8px;"><strong>‚úÖ Detailed Analysis</strong> - ' + protocol.equipes.length + ' √©quipes - ' + numJudges + ' juges</div>';
            
            protocol.equipes.forEach(team => {
                const displayRang = team.rang !== undefined && team.rang !== null ? team.rang : '-';
                // Calculer les d√©ductions
                const deductions = team.tech + team.pres - team.total;
                
                const techRank = technicalRankings[team.nom];
                const compRank = componentsRankings[team.nom];
                const bvRank = baseValueRankings[team.nom];
                const totalBV = team.elements.reduce((sum, el) => sum + el.bv, 0);
                
                const techRankHeaderClass = getRankClassHeader(techRank, displayRang);
                const compRankHeaderClass = getRankClassHeader(compRank, displayRang);
                
                html += `
                    <div class="team-section">
                        <div class="team-header-detailed">
                            <div class="team-title-detailed">${displayRang}. ${team.nom} (${team.nation})</div>
                            <div class="team-scores">
                                <div class="score-box">
                                    <div class="label">Total Score</div>
                                    <div class="value">${team.total.toFixed(2)}</div>
                                    <div class="rank">Rang: ${displayRang}</div>
                                </div>
                                <div class="score-box">
                                    <div class="label">Technical Score</div>
                                    <div class="value">${team.tech.toFixed(2)}</div>
                                    <div class="rank ${techRankHeaderClass}">Rang: ${techRank}</div>
                                </div>
                                <div class="score-box">
                                    <div class="label">Presentation Score</div>
                                    <div class="value">${team.pres.toFixed(2)}</div>
                                    <div class="rank ${compRankHeaderClass}">Rang: ${compRank}</div>
                                </div>
                                <div class="score-box">
                                    <div class="label">Deductions</div>
                                    <div class="value" style="color: white;">${deductions > 0 ? '-' : ''}${Math.abs(deductions).toFixed(2)}</div>
                                    <div class="rank" style="opacity: 0.7; font-size: 0.85em;">${deductions > 0 ? 'Penalties' : 'Aucune'}</div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="section-title">üéØ √âl√©ments Techniques</div>
                        <div style="overflow-x: auto; -webkit-overflow-scrolling: touch; margin-bottom: 20px;">
                        <table style="min-width: 800px;">
                            <thead>
                                <tr>
                                    <th class="text-left">Element</th>
                                    <th>Level</th>
                                    <th>BV</th>
                                    <th>GOE</th>
                                    <th>Score</th>
                                    <th>Rank</th>
                `;
                
                for (let j = 1; j <= numJudges; j++) {
                    html += `<th>J${j}</th>`;
                }
                
                html += `</tr></thead><tbody>`;
                
                team.elements.forEach(element => {
                    const elementType = element.type;
                    const niveauCalcule = getNiveauFromCode(element.code, element.type);
                    let teamElementData = elementRankings[elementType] ? 
                        elementRankings[elementType].find(e => e.teamName === team.nom && e.level === niveauCalcule) : null;
                    
                    if (!teamElementData && (elementType === 'ME' || elementType === 'Pa') && elementRankings['ME/Pa']) {
                        teamElementData = elementRankings['ME/Pa'].find(e => e.teamName === team.nom && e.level === niveauCalcule);
                    }
                    
                    const elementRank = teamElementData ? teamElementData.elementRank : '-';
                    const rankClass = elementRank <= 3 && elementRank !== '-' ? `rank-${elementRank}` : '';
                    
                    html += `
                        <tr class="element-row ${rankClass}">
                            <td class="text-left">
                                <span class="element-code">${elementType}</span>
                                ${element.chute ? '<span class="fall-badge">CHUTE</span>' : ''}
                            </td>
                            <td><span class="level-badge">Niv ${getNiveauFromCode(element.code, element.type)}</span></td>
                            <td class="number">${element.bv.toFixed(2)}</td>
                            <td class="number ${element.goe >= 0 ? 'positive' : 'negative'}">
                                ${element.goe >= 0 ? '+' : ''}${element.goe.toFixed(2)}
                            </td>
                            <td class="number"><strong>${element.score.toFixed(2)}</strong></td>
                            <td><span class="rank-badge ${elementRank <= 3 && elementRank !== '-' ? 'rank-'+elementRank : ''}">${elementRank}</span></td>
                    `;
                    
                    element.juges.forEach(judgeGOE => {
                        const goeClass = judgeGOE > 0 ? 'positive' : (judgeGOE < 0 ? 'negative' : 'goe-zero');
                        const goeSign = judgeGOE > 0 ? '+' : '';
                        html += `<td class="number ${goeClass}">${goeSign}${judgeGOE}</td>`;
                    });
                    
                    html += `</tr>`;
                    
                    html += `<tr class="judge-rank-row"><td class="text-left" colspan="6" style="text-align: left; padding-left: 20px;">Rangs des juges :</td>`;
                    
                    for (let j = 0; j < numJudges; j++) {
                        let elementDataForJudge = elementRankings[elementType];
                        if (!elementDataForJudge && (elementType === 'ME' || elementType === 'Pa') && elementRankings['ME/Pa']) {
                            elementDataForJudge = elementRankings['ME/Pa'];
                        }
                        
                        const judgeRanks = calculateJudgeRanksForElement(elementDataForJudge, j);
                        const judgeRank = judgeRanks[team.nom] || '-';
                        const rankCompClass = (judgeRank !== '-') ? getRankClass(judgeRank, displayRang) : '';
                        html += `<td class="${rankCompClass}">${judgeRank}</td>`;
                    }
                    
                    html += `</tr>`;
                });
                
                html += `<tr class="total-row">
                    <td class="text-left">TECHNICAL TOTAL</td>
                    <td colspan="2" class="number"><strong>BV: ${totalBV.toFixed(2)}</strong></td>
                    <td colspan="2" class="number"><strong>Score: ${team.tech.toFixed(2)}</strong></td>
                    <td><span class="rank-badge">${techRank}</span></td>
                `;
                
                for (let j = 0; j < numJudges; j++) {
                    const judgeData = calculateJudgeTechnicalRankings(protocol, j);
                    const judgeScore = judgeData.scores.find(s => s.teamName === team.nom);
                    html += `<td class="number"><strong>${judgeScore ? judgeScore.score.toFixed(2) : '-'}</strong></td>`;
                }
                html += `</tr>`;
                
                html += `<tr class="rank-row">
                    <td class="text-left">Rangs Technique</td>
                    <td colspan="2">BV Rang: ${bvRank}</td>
                    <td colspan="3"></td>
                `;
                
                for (let j = 0; j < numJudges; j++) {
                    const judgeData = calculateJudgeTechnicalRankings(protocol, j);
                    const judgeRank = judgeData.ranks[team.nom] || '-';
                    const rankCompClass = (judgeRank !== '-') ? getRankClass(judgeRank, displayRang) : '';
                    html += `<td class="${rankCompClass}"><strong>${judgeRank}</strong></td>`;
                }
                html += `</tr>`;
                
                html += `</tbody></table></div>`; // Fermeture du wrapper scroll
                
                html += `
                    <div class="section-title">üé® Composantes de Program</div>
                    <div style="overflow-x: auto; -webkit-overflow-scrolling: touch; margin-bottom: 20px;">
                    <table style="min-width: 600px;">
                        <thead>
                            <tr>
                                <th class="text-left">Composante</th>
                                <th>Score</th>
                `;
                
                for (let j = 1; j <= numJudges; j++) {
                    html += `<th>J${j}</th>`;
                }
                
                html += `</tr></thead><tbody>`;
                
                const compRankFinal = compositionRankings[team.nom];
                const compRankClass = getRankClass(compRankFinal, displayRang);
                html += `<tr><td class="text-left">Composition</td><td class="number"><strong>${team.composantes.compFinal ? team.composantes.compFinal.toFixed(2) : '-'}</strong></td>`;
                team.composantes.composition.forEach(score => {
                    html += `<td class="number">${score.toFixed(2)}</td>`;
                });
                html += `</tr>`;
                
                html += `<tr class="judge-rank-row"><td class="text-left" colspan="1" style="text-align: left; padding-left: 20px;">Rangs Comp.:</td><td class="${compRankClass}">${compRankFinal}</td>`;
                for (let j = 0; j < numJudges; j++) {
                    const judgeRanks = calculateJudgeCompositionRankings(protocol, j);
                    const judgeRank = judgeRanks[team.nom] || '-';
                    const rankCompClass = (judgeRank !== '-') ? getRankClass(judgeRank, displayRang) : '';
                    html += `<td class="${rankCompClass}">${judgeRank}</td>`;
                }
                html += `</tr>`;
                
                const presRankFinal = presentationRankings[team.nom];
                const presRankClass = getRankClass(presRankFinal, displayRang);
                html += `<tr><td class="text-left">Presentation</td><td class="number"><strong>${team.composantes.presFinal ? team.composantes.presFinal.toFixed(2) : '-'}</strong></td>`;
                team.composantes.presentation.forEach(score => {
                    html += `<td class="number">${score.toFixed(2)}</td>`;
                });
                html += `</tr>`;
                
                html += `<tr class="judge-rank-row"><td class="text-left" colspan="1" style="text-align: left; padding-left: 20px;">Rangs Pr√©s.:</td><td class="${presRankClass}">${presRankFinal}</td>`;
                for (let j = 0; j < numJudges; j++) {
                    const judgeRanks = calculateJudgePresentationRankings(protocol, j);
                    const judgeRank = judgeRanks[team.nom] || '-';
                    const rankCompClass = (judgeRank !== '-') ? getRankClass(judgeRank, displayRang) : '';
                    html += `<td class="${rankCompClass}">${judgeRank}</td>`;
                }
                html += `</tr>`;
                
                const skatRankFinal = skatingSkillsRankings[team.nom];
                const skatRankClass = getRankClass(skatRankFinal, displayRang);
                html += `<tr><td class="text-left">Skating Skills</td><td class="number"><strong>${team.composantes.skatFinal ? team.composantes.skatFinal.toFixed(2) : '-'}</strong></td>`;
                team.composantes.skatingSkills.forEach(score => {
                    html += `<td class="number">${score.toFixed(2)}</td>`;
                });
                html += `</tr>`;
                
                html += `<tr class="judge-rank-row"><td class="text-left" colspan="1" style="text-align: left; padding-left: 20px;">Rangs Skating:</td><td class="${skatRankClass}">${skatRankFinal}</td>`;
                for (let j = 0; j < numJudges; j++) {
                    const judgeRanks = calculateJudgeSkatingSkillsRankings(protocol, j);
                    const judgeRank = judgeRanks[team.nom] || '-';
                    const rankCompClass = (judgeRank !== '-') ? getRankClass(judgeRank, displayRang) : '';
                    html += `<td class="${rankCompClass}">${judgeRank}</td>`;
                }
                html += `</tr>`;
                
                html += `<tr class="total-row"><td class="text-left">TOTAL</td><td class="number"><strong>${team.pres.toFixed(2)}</strong></td>`;
                for (let j = 0; j < numJudges; j++) {
                    const sumBeforeFactor = (team.composantes.composition[j] || 0) + 
                                           (team.composantes.presentation[j] || 0) + 
                                           (team.composantes.skatingSkills[j] || 0);
                    const totalWithFactor = sumBeforeFactor * protocol.facteur;
                    html += `<td class="number"><strong>${totalWithFactor.toFixed(2)}</strong></td>`;
                }
                html += `</tr>`;
                
                const compRankClass2 = getRankClass(compRank, displayRang);
                html += `<tr class="rank-row"><td class="text-left">Rangs Pr√©sentation</td><td class="${compRankClass2}"><strong>${compRank}</strong></td>`;
                for (let j = 0; j < numJudges; j++) {
                    const judgeRanks = calculateJudgeComponentsRankings(protocol, j);
                    const judgeRank = judgeRanks[team.nom] || '-';
                    const rankCompClass = (judgeRank !== '-') ? getRankClass(judgeRank, displayRang) : '';
                    html += `<td class="${rankCompClass}"><strong>${judgeRank}</strong></td>`;
                }
                html += `</tr>`;
                
                // TOTAL PAR JUGE (Tech + Pres)
                html += `<tr class="total-row" style="background:#fff3e0;"><td class="text-left">TOTAL PAR JUGE</td><td class="number"><strong>${team.total.toFixed(2)}</strong></td>`;
                for (let j = 0; j < numJudges; j++) {
                    const techScore = team.tech;
                    const presScore = ((team.composantes.composition[j] || 0) + 
                                       (team.composantes.presentation[j] || 0) + 
                                       (team.composantes.skatingSkills[j] || 0)) * protocol.facteur;
                    const totalJuge = techScore + presScore - deductions;
                    html += `<td class="number"><strong>${totalJuge.toFixed(2)}</strong></td>`;
                }
                html += `</tr>`;
                
                // RANGS TOTAL
                html += `<tr class="rank-row"><td class="text-left">Rangs Total</td><td class="rank-equal"><strong>${displayRang}</strong></td>`;
                for (let j = 0; j < numJudges; j++) {
                    const judgeTotalRanks = calculateJudgeTotalRankings(protocol, j);
                    const judgeRank = judgeTotalRanks[team.nom] || '-';
                    const rankTotalClass = (judgeRank !== '-') ? getRankClass(judgeRank, displayRang) : '';
                    html += `<td class="${rankTotalClass}"><strong>${judgeRank}</strong></td>`;
                }
                html += `</tr>`;
                
                html += `</tbody></table></div>`;
            });
            
            document.getElementById('modalBody').innerHTML = html;
        }
        
        // ============================================
        // NORMALISATION DES NOMS D'√âQUIPES
        // ============================================
        
        function normaliserNomEquipe(nom, nation) {
            let nomNormalise = nom.trim();
            
            // Retirer le code nation/club √† la fin si pr√©sent
            const suffixesARetirer = [
                nation, // Le code nation lui-m√™me
                /\b(Senior|Junior|Intermediate|Novice|Advanced Novice|Basic Novice)\b/gi,
                /\b\d{1,2}\b$/, // Num√©ros √† la fin (1, 2, etc.)
                /\b[A-Z]{2,6}\b$/, // Codes pays/clubs √† la fin
                /\-\s*(Senior|Junior|PC|PL|SP|FS)$/i // Suffixes avec tiret
            ];
            
            for (let pattern of suffixesARetirer) {
                if (typeof pattern === 'string') {
                    const regex = new RegExp('\\s+' + pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '$', 'i');
                    nomNormalise = nomNormalise.replace(regex, '');
                } else {
                    nomNormalise = nomNormalise.replace(pattern, '');
                }
            }
            
            nomNormalise = nomNormalise.replace(/\s+/g, ' ').trim();
            return nomNormalise;
        }
        
        // ============================================
        // SYST√àME DE FUSION SUPPRIM√â (v107)
        // Remplac√© par la d√©tection intelligente + ajout d'√©quipes inconnues
        // ============================================
        
        function toggleStandardisation() {
            const checkbox = document.getElementById('standardiserCheckbox');
            standardiserNoms = checkbox.checked;
            localStorage.setItem('synchro_standardiser', standardiserNoms.toString());
            
            if (standardiserNoms) {
                alert('‚úÖ Standardisation activ√©e !\n\nLes nouveaux protocoles PDF seront analys√©s avec les noms au format ISU international.\n\nPour appliquer aux protocoles d√©j√† charg√©s, rechargez-les.');
            } else {
                alert('‚ÑπÔ∏è Standardisation d√©sactiv√©e.\n\nLes noms d\'√©quipes seront conserv√©s tels qu\'extraits des PDFs.');
            }
        }
        
        function afficherListeEquipes() {
            const div = document.getElementById('liste-equipes');
            const isVisible = div.style.display !== 'none';
            
            if (isVisible) {
                div.style.display = 'none';
                return;
            }
            
            // Grouper par pays
            const parPays = {};
            for (const [equipe, pays] of Object.entries(equipesInternationales)) {
                if (!parPays[pays]) parPays[pays] = [];
                parPays[pays].push(equipe);
            }
            
            // Trier les pays
            const paysTri√©s = Object.keys(parPays).sort();
            
            let html = '<div style="background:white;padding:15px;border-radius:8px;">';
            html += '<h4 style="margin-bottom:15px;">üìã Liste des √©quipes par pays</h4>';
            
            paysTri√©s.forEach(pays => {
                const equipes = parPays[pays].sort();
                html += `<div style="margin-bottom:15px;">`;
                html += `<strong style="color:#667eea;">${pays}</strong> (${equipes.length} √©quipe${equipes.length > 1 ? 's' : ''})<br>`;
                html += `<div style="margin-left:20px;margin-top:5px;font-size:0.9em;">`;
                equipes.forEach(eq => {
                    html += `${eq}<br>`;
                });
                html += '</div></div>';
            });
            
            html += '</div>';
            div.innerHTML = html;
            div.style.display = 'block';
            
            // Mettre √† jour le compteur
            document.getElementById('nbEquipesDB').textContent = Object.keys(equipesInternationales).length;
        }
        
        function modifierEquipe(ancienNom) {
            const equipe = resultats.flatMap(r => r.data.equipes).find(e => e.nom === ancienNom);
            const ancienPays = equipe ? equipe.nation : '';
            
            const nouveauNom = prompt(`Nouveau nom pour "${ancienNom}" :`, ancienNom);
            if (!nouveauNom || nouveauNom === ancienNom) {
                // Juste modifier le pays ?
                const nouveauPays = prompt(`Nouveau code pays (3 lettres) pour "${ancienNom}" :`, ancienPays);
                if (!nouveauPays) return;
                const paysUpper = nouveauPays.toUpperCase();
                // Mettre √† jour le pays dans tous les r√©sultats
                let count = 0;
                resultats.forEach(res => {
                    res.data.equipes.forEach(eq => {
                        if (eq.nom === ancienNom) {
                            eq.nation = paysUpper;
                            count++;
                        }
                    });
                });
                localStorage.setItem(DB_RES, JSON.stringify(resultats));
                chargerDonnees();
                alert(`‚úÖ Pays mis √† jour : ${ancienNom} ‚Üí ${paysUpper} (${count} r√©sultat(s))`);
                afficherGestionEquipes();
                return;
            }
            
            const nouveauPays = prompt(`Code pays (3 lettres) :`, ancienPays);
            if (!nouveauPays) return;
            const paysUpper = nouveauPays.toUpperCase();
            
            // Mettre √† jour dans TOUS les r√©sultats
            let count = 0;
            resultats.forEach(res => {
                res.data.equipes.forEach(eq => {
                    if (eq.nom === ancienNom) {
                        eq.nom = nouveauNom.trim();
                        eq.nation = paysUpper;
                        count++;
                    }
                });
            });
            
            localStorage.setItem(DB_RES, JSON.stringify(resultats));
            
            // Mettre √† jour aussi dans la DB √©quipes
            if (equipesInternationales[ancienNom]) {
                delete equipesInternationales[ancienNom];
                equipesInternationales[nouveauNom.trim()] = paysUpper;
            }
            
            chargerDonnees();
            alert(`‚úÖ √âquipe modifi√©e dans ${count} r√©sultat(s) :\n"${ancienNom}" ‚Üí "${nouveauNom.trim()}" (${paysUpper})`);
            afficherGestionEquipes();
        }
        
        function supprimerEquipe(nom) {
            // Compter dans combien de r√©sultats elle appara√Æt
            let count = 0;
            resultats.forEach(res => {
                if (res.data.equipes.some(e => e.nom === nom)) count++;
            });
            
            if (!confirm(`‚ö†Ô∏è Supprimer "${nom}" ?\n\nCette √©quipe sera retir√©e de ${count} r√©sultat(s).\nCette action est IRR√âVERSIBLE.`)) return;
            
            // Supprimer dans tous les r√©sultats
            resultats.forEach(res => {
                res.data.equipes = res.data.equipes.filter(e => e.nom !== nom);
                // Recalculer les rangs
                res.data.equipes.sort((a, b) => b.total - a.total);
                res.data.equipes.forEach((eq, idx) => eq.rang = idx + 1);
            });
            
            localStorage.setItem(DB_RES, JSON.stringify(resultats));
            chargerDonnees();
            alert(`‚úÖ "${nom}" supprim√©e de ${count} r√©sultat(s)`);
            afficherGestionEquipes();
        }
        
        function ajouterEquipeManuelle() {
            const nom = prompt('Nom de l\'√©quipe (sans "Team" ni "Junior") :');
            if (!nom) return;
            
            const pays = prompt('Code pays (3 lettres, ex: FIN, USA, CAN, AUS) :');
            if (!pays || pays.length !== 3) {
                alert('‚ùå Code pays invalide. Doit √™tre 3 lettres (ex: FIN, USA, CAN)');
                return;
            }
            
            const paysUpper = pays.toUpperCase();
            
            // Ajouter √† la base
            equipesInternationales[nom.trim()] = paysUpper;
            
            // Sauvegarder dans localStorage
            const equipesPersonnalisees = JSON.parse(localStorage.getItem('synchro_equipes_custom') || '{}');
            equipesPersonnalisees[nom.trim()] = paysUpper;
            localStorage.setItem('synchro_equipes_custom', JSON.stringify(equipesPersonnalisees));
            
            alert(`‚úÖ √âquipe ajout√©e !\n\n${nom} ‚Üí ${paysUpper}\n\nCette √©quipe sera maintenant reconnue automatiquement.`);
            
            // Rafra√Æchir l'affichage si visible
            const div = document.getElementById('liste-equipes');
            if (div.style.display !== 'none') {
                afficherListeEquipes();
                afficherListeEquipes(); // Double appel pour forcer le rafra√Æchissement
            }
        }
        
        function afficherGestionEquipes() {
            // Initialiser la checkbox de standardisation
            const checkbox = document.getElementById('standardiserCheckbox');
            if (checkbox) {
                checkbox.checked = standardiserNoms;
            }
            
            // Mettre √† jour le compteur d'√©quipes
            const nbEquipesSpan = document.getElementById('nbEquipesDB');
            if (nbEquipesSpan) {
                nbEquipesSpan.textContent = Object.keys(equipesInternationales).length;
            }
            
            if (resultats.length === 0) {
                document.getElementById('gestion-equipes').innerHTML = `
                    <div class="info-box">
                        <strong>‚ÑπÔ∏è No data available</strong><br>
                        Uploadez des protocoles PDF pour commencer.
                    </div>`;
                return;
            }
            
            // Extraire toutes les √©quipes uniques utilis√©es dans les r√©sultats
            const nomsEquipes = new Set();
            resultats.forEach(res => {
                res.data.equipes.forEach(team => {
                    nomsEquipes.add(team.nom);
                });
            });
            
            const equipesArray = Array.from(nomsEquipes).sort();
            
            let html = '<div class="info-box">';
            html += '<strong>üìä √âquipes d√©tect√©es dans vos r√©sultats</strong><br>';
            html += `${equipesArray.length} √©quipe(s) unique(s) trouv√©e(s) dans vos protocoles analys√©s`;
            html += '</div>';
            
            // Liste des √©quipes
            html += '<div style="margin-top:20px;">';
            html += '<h4 style="color:#1e3c72;">üìã Liste des √©quipes</h4>';
            html += '<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(300px,1fr));gap:10px;margin-top:15px;">';
            
            equipesArray.forEach(nom => {
                // Trouver le pays
                const equipe = resultats.flatMap(r => r.data.equipes).find(e => e.nom === nom);
                const nation = equipe ? equipe.nation : '?';
                
                html += `<div style="padding:10px;background:#f8f9ff;border-radius:5px;border-left:3px solid #667eea;display:flex;align-items:center;justify-content:space-between;gap:8px;">`;
                html += `<span><strong>${nom}</strong> <span style="color:#666;">(${nation})</span></span>`;
                html += `<div style="display:flex;gap:4px;flex-shrink:0;">`;
                html += `<button onclick="modifierEquipe('${nom.replace(/'/g, "\\'")}')" style="padding:3px 8px;font-size:0.75em;background:#667eea;color:white;border:none;border-radius:3px;cursor:pointer;">‚úèÔ∏è</button>`;
                html += `<button onclick="supprimerEquipe('${nom.replace(/'/g, "\\'")}')" style="padding:3px 8px;font-size:0.75em;background:#f44336;color:white;border:none;border-radius:3px;cursor:pointer;">üóëÔ∏è</button>`;
                html += `</div></div>`;
            });
            
            html += '</div></div>';
            
            document.getElementById('gestion-equipes').innerHTML = html;
        }
        
        function extraireEquipes() {
            const equipes = new Map();
            
            resultats.forEach(res => {
                const comp = liste.find(c => String(c.id) === String(res.compId));
                
                res.data.equipes.forEach(team => {
                    // Appliquer les fusions manuelles si elles existent
                    const nomCanonique = team.nom;
                    const key = nomCanonique;
                    
                    if (!equipes.has(key)) {
                        equipes.set(key, {
                            nom: nomCanonique,
                            nomsOriginaux: new Set([team.nom]),
                            nation: team.nation,
                            apparitions: []
                        });
                    }
                    
                    // Ajouter le nom original √† la liste
                    equipes.get(key).nomsOriginaux.add(team.nom);
                    
                    equipes.get(key).apparitions.push({
                        compId: res.compId,
                        compNom: comp ? comp.n : 'Inconnu',
                        compDate: comp ? comp.d : '',
                        cat: res.cat,
                        prog: res.prog,
                        rang: team.rang,
                        total: team.total,
                        tech: team.tech,
                        pres: team.pres,
                        elements: team.elements,
                        composantes: team.composantes
                    });
                });
            });
            
            return Array.from(equipes.values()).sort((a, b) => a.nom.localeCompare(b.nom));
        }

        function afficherComparaisons() {
            if (resultats.length === 0) {
                document.getElementById('tab-comparaisons').innerHTML = `
                    <div class="info-box">
                        <strong>‚ÑπÔ∏è No data available</strong><br>
                        Analysez d'abord des protocoles pour utiliser les comparaisons.
                    </div>
                `;
                return;
            }
            
            const equipes = extraireEquipes();
            
            let html = `
                <h2 style="color: #1e3c72; margin-bottom: 20px;">üìà Team Comparison</h2>
                
                <div style="background: white; padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                    <h3 style="color: #667eea; margin-bottom: 15px;">Progression Tracking</h3>
                    <p style="margin-bottom: 15px;">Select a team to see its evolution during the season:</p>
                    
                    <div style="margin-bottom: 15px;">
                        <input type="text" id="rechercheEquipeComparaison" placeholder="üîç Search for a team..." 
                            style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; margin-bottom: 10px;"
                            onkeyup="filtrerEquipesComparaison()">
                    </div>
                    
                    <select id="equipeSelect" size="10" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; margin-bottom: 15px;" onchange="afficherProgressionEquipe()">
                        <option value="">-- Choose a team --</option>
            `;
            
            equipes.forEach(eq => {
                html += `<option value="${eq.nom}">${eq.nom} (${eq.nation}) - ${eq.apparitions.length} comp√©tition(s)</option>`;
            });
            
            html += `
                    </select>
                    
                    <div style="margin: 15px 0;">
                        <label style="font-weight: 600; color: #1e3c72; margin-right: 20px;">Analysis Type:</label>
                        <label style="margin-right: 15px;">
                            <input type="radio" name="typeProgression" value="total" checked onchange="afficherProgressionEquipe()">
                            Total Competition (SP+FP)
                        </label>
                        <label style="margin-right: 15px;">
                            <input type="radio" name="typeProgression" value="PC" onchange="afficherProgressionEquipe()">
                            Short Program only
                        </label>
                        <label>
                            <input type="radio" name="typeProgression" value="PL" onchange="afficherProgressionEquipe()">
                            Free Program only
                        </label>
                    </div>
                    
                    <button class="btn btn-primary" onclick="afficherProgressionEquipe()">üìä View progression</button>
                </div>
                
                <div id="progressionResult"></div>
            `;
            
            document.getElementById('tab-comparaisons').innerHTML = html;
        }

        function filtrerEquipesComparaison() {
            const recherche = document.getElementById('rechercheEquipeComparaison').value.toLowerCase();
            const select = document.getElementById('equipeSelect');
            const options = select.options;
            
            for (let i = 1; i < options.length; i++) { // Skip first option (placeholder)
                const option = options[i];
                const texte = option.textContent.toLowerCase();
                
                if (texte.includes(recherche)) {
                    option.style.display = '';
                } else {
                    option.style.display = 'none';
                }
            }
        }
        
        function afficherProgressionEquipe() {
            const select = document.getElementById('equipeSelect');
            const nomEquipe = select.value;
            
            if (!nomEquipe) {
                alert('Select a team');
                return;
            }
            
            const typeRadio = document.querySelector('input[name="typeProgression"]:checked');
            const type = typeRadio ? typeRadio.value : 'total';
            
            const equipes = extraireEquipes();
            const equipe = equipes.find(eq => eq.nom === nomEquipe);
            
            if (!equipe || equipe.apparitions.length === 0) {
                alert('Aucune donn√©e trouv√©e');
                return;
            }
            
            // Filtrer selon le type
            let apparitionsFiltrees = [];
            
            if (type === 'total') {
                // Regrouper par comp√©tition + cat√©gorie pour calculer les totaux
                const parComp = new Map();
                
                equipe.apparitions.forEach(app => {
                    const key = `${app.compId}_${app.cat}`;
                    if (!parComp.has(key)) {
                        parComp.set(key, {
                            compId: app.compId,
                            compNom: app.compNom,
                            compDate: app.compDate,
                            cat: app.cat,
                            PC: null,
                            PL: null
                        });
                    }
                    
                    // G√©rer √† la fois PC/PL (nouveau format) et SP/FS (ancien format)
                    if (app.prog === 'PC' || app.prog === 'SP') {
                        parComp.get(key).PC = app;
                    } else if (app.prog === 'PL' || app.prog === 'FS') {
                        parComp.get(key).PL = app;
                    }
                });
                
                // Calculer les totaux ET stocker PC/PL s√©par√©s
                parComp.forEach(comp => {
                    if (comp.PC && comp.PL) {
                        apparitionsFiltrees.push({
                            compId: comp.compId,
                            compNom: comp.compNom,
                            compDate: comp.compDate,
                            cat: comp.cat,
                            prog: 'Total',
                            rang: Math.min(comp.PC.rang, comp.PL.rang),
                            total: comp.PC.total + comp.PL.total,
                            tech: comp.PC.total,  // PC s√©par√© pour le graphique
                            pres: comp.PL.total   // PL s√©par√© pour le graphique
                        });
                    }
                });
            } else {
                // Filtrer PC ou PL only (g√©rer aussi SP/FS)
                if (type === 'PC') {
                    apparitionsFiltrees = equipe.apparitions.filter(app => app.prog === 'PC' || app.prog === 'SP');
                } else if (type === 'PL') {
                    apparitionsFiltrees = equipe.apparitions.filter(app => app.prog === 'PL' || app.prog === 'FS');
                }
            }
            
            if (apparitionsFiltrees.length === 0) {
                document.getElementById('progressionResult').innerHTML = `
                    <div class="info-box">
                        <strong>‚ÑπÔ∏è Aucune donn√©e pour ce type</strong><br>
                        This team has no results in ${type === 'PC' ? 'Short Program' : type === 'PL' ? 'Free Program' : 'Total Competition'}.
                    </div>
                `;
                return;
            }
            
            // Trier par ordre chronologique (ordre du calendrier)
            apparitionsFiltrees.sort((a, b) => {
                const compA = liste.find(c => String(c.id) === String(a.compId));
                const compB = liste.find(c => String(c.id) === String(b.compId));
                const indexA = liste.indexOf(compA);
                const indexB = liste.indexOf(compB);
                return indexA - indexB;
            });
            
            const typeLabel = type === 'total' ? 'Total Competition (SP + FP)' : 
                             type === 'PC' ? 'Short Program' : 'Free Program';
            
            const col1Header = type === 'total' ? 'SP' : 'Technique';
            const col2Header = type === 'total' ? 'FS' : 'Pr√©sentation';
            
            let html = `
                <div style="background: white; padding: 20px; border-radius: 10px; margin-top: 20px;">
                    <h3 style="color: #1e3c72; margin-bottom: 10px;">${equipe.nom} (${equipe.nation})</h3>
                    <p style="color: #667eea; margin-bottom: 20px;"><strong>${typeLabel}</strong> - ${apparitionsFiltrees.length} comp√©tition(s)</p>
                    
                    <div style="margin-bottom: 30px; overflow-x: auto;">
                        ${genererGraphiqueProgression(apparitionsFiltrees, type)}
                    </div>
                    
                    <h4 style="color: #667eea; margin-bottom: 15px;">üìã D√©tail des Competitions</h4>
                    <table style="width:100%; border-collapse: collapse;">
                        <thead style="background: #f5f5f5;">
                            <tr>
                                <th style="padding: 12px; text-align: left; border-bottom: 2px solid #667eea;">Competition</th>
                                <th style="padding: 12px; text-align: center; border-bottom: 2px solid #667eea;">Program</th>
                                <th style="padding: 12px; text-align: center; border-bottom: 2px solid #667eea;">Rank</th>
                                <th style="padding: 12px; text-align: center; border-bottom: 2px solid #667eea;">Total</th>
                                <th style="padding: 12px; text-align: center; border-bottom: 2px solid #667eea;">${col1Header}</th>
                                <th style="padding: 12px; text-align: center; border-bottom: 2px solid #667eea;">${col2Header}</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            apparitionsFiltrees.forEach((app, index) => {
                const evolTotal = index > 0 ? app.total - apparitionsFiltrees[index-1].total : 0;
                const evolClass = evolTotal > 0 ? 'positive' : (evolTotal < 0 ? 'negative' : '');
                const evolSign = evolTotal > 0 ? '+' : '';
                
                // En mode Total : afficher PC et PL au lieu de Tech/Pres
                const col1Label = type === 'total' ? 'SP' : 'Technique';
                const col2Label = type === 'total' ? 'FS' : 'Pr√©sentation';
                const col1Value = app.tech;
                const col2Value = app.pres;
                
                html += `
                    <tr style="border-bottom: 1px solid #f0f0f0;">
                        <td style="padding: 12px;">${app.compNom}</td>
                        <td style="padding: 12px; text-align: center;">${app.cat} ${app.prog}</td>
                        <td style="padding: 12px; text-align: center;"><strong>${app.rang}</strong></td>
                        <td style="padding: 12px; text-align: center;">
                            <strong>${app.total.toFixed(2)}</strong>
                            ${index > 0 ? `<span class="${evolClass}" style="font-size: 0.85em; margin-left: 5px;">(${evolSign}${evolTotal.toFixed(2)})</span>` : ''}
                        </td>
                        <td style="padding: 12px; text-align: center;">${col1Value.toFixed(2)}</td>
                        <td style="padding: 12px; text-align: center;">${col2Value.toFixed(2)}</td>
                    </tr>
                `;
            });
            
            html += `
                        </tbody>
                    </table>
                </div>
            `;
            
            document.getElementById('progressionResult').innerHTML = html;
        }

        function genererGraphiqueProgression(apparitions, type) {
            const width = 800;
            const height = 300;
            const padding = 50;
            
            // D√©terminer les valeurs √† afficher selon le type
            let series = [];
            
            if (type === 'total') {
                // Mode Total : afficher Total, PC, PL
                const maxScore = Math.max(...apparitions.map(a => a.total));
                const minScore = Math.min(...apparitions.map(a => a.total));
                
                series = [
                    { 
                        name: 'Total (PC + PL)', 
                        color: '#667eea', 
                        width: 3,
                        data: apparitions.map(a => a.total),
                        dasharray: ''
                    },
                    { 
                        name: 'PC seul', 
                        color: '#4CAF50', 
                        width: 2,
                        data: apparitions.map(a => a.tech), // On r√©utilise tech pour PC
                        dasharray: '5,5'
                    },
                    { 
                        name: 'PL seul', 
                        color: '#FF9800', 
                        width: 2,
                        data: apparitions.map(a => a.pres), // On r√©utilise pres pour PL
                        dasharray: '5,5'
                    }
                ];
            } else {
                // Mode PC ou PL : afficher Score, Technique, Pr√©sentation
                const maxScore = Math.max(...apparitions.map(a => a.total));
                const minScore = Math.min(
                    Math.min(...apparitions.map(a => a.tech)),
                    Math.min(...apparitions.map(a => a.pres))
                );
                
                series = [
                    { 
                        name: 'Total Score', 
                        color: '#667eea', 
                        width: 3,
                        data: apparitions.map(a => a.total),
                        dasharray: ''
                    },
                    { 
                        name: 'Technique', 
                        color: '#4CAF50', 
                        width: 2,
                        data: apparitions.map(a => a.tech),
                        dasharray: '5,5'
                    },
                    { 
                        name: 'Pr√©sentation', 
                        color: '#FF9800', 
                        width: 2,
                        data: apparitions.map(a => a.pres),
                        dasharray: '5,5'
                    }
                ];
            }
            
            // Calculer min/max global pour toutes les s√©ries
            const allValues = series.flatMap(s => s.data);
            const maxScore = Math.max(...allValues);
            const minScore = Math.min(...allValues);
            const scoreRange = maxScore - minScore || 10;
            const yScale = (height - 2 * padding) / scoreRange;
            const xScale = (width - 2 * padding) / Math.max(1, apparitions.length - 1);
            
            // G√©n√©rer les paths pour chaque s√©rie
            const paths = series.map(serie => {
                let path = '';
                serie.data.forEach((value, i) => {
                    const x = padding + i * xScale;
                    const y = height - padding - (value - minScore) * yScale;
                    path += (i === 0 ? 'M' : 'L') + x + ',' + y + ' ';
                });
                return { ...serie, path };
            });
            
            const typeLabel = type === 'total' ? 'Total Competition' : 
                             type === 'PC' ? 'Short Program' : 'Free Program';
            
            let svg = `
                <svg width="${width}" height="${height}" style="border: 1px solid #e0e0e0; border-radius: 8px; background: white;">
                    <!-- Titre -->
                    <text x="${width/2}" y="25" text-anchor="middle" font-size="14" font-weight="bold" fill="#1e3c72">√âvolution ${typeLabel}</text>
                    
                    <!-- Grille -->
                    <line x1="${padding}" y1="${padding + 15}" x2="${padding}" y2="${height - padding}" stroke="#ccc" stroke-width="2"/>
                    <line x1="${padding}" y1="${height - padding}" x2="${width - padding}" y2="${height - padding}" stroke="#ccc" stroke-width="2"/>
                    
                    <!-- Lignes horizontales (grille) -->
                    <line x1="${padding}" y1="${padding + 15 + (height - 2*padding - 15) * 0.25}" x2="${width - padding}" y2="${padding + 15 + (height - 2*padding - 15) * 0.25}" stroke="#eee" stroke-width="1"/>
                    <line x1="${padding}" y1="${padding + 15 + (height - 2*padding - 15) * 0.5}" x2="${width - padding}" y2="${padding + 15 + (height - 2*padding - 15) * 0.5}" stroke="#eee" stroke-width="1"/>
                    <line x1="${padding}" y1="${padding + 15 + (height - 2*padding - 15) * 0.75}" x2="${width - padding}" y2="${padding + 15 + (height - 2*padding - 15) * 0.75}" stroke="#eee" stroke-width="1"/>
                    
                    <!-- Lignes de donn√©es -->
            `;
            
            // Dessiner toutes les courbes
            paths.forEach(p => {
                svg += `<path d="${p.path}" fill="none" stroke="${p.color}" stroke-width="${p.width}" stroke-dasharray="${p.dasharray}"/>`;
            });
            
            svg += `
                    <!-- Points sur la courbe principale (Total) -->
            `;
            
            apparitions.forEach((app, i) => {
                const x = padding + i * xScale;
                const yTotal = height - padding - (paths[0].data[i] - minScore) * yScale;
                
                svg += `<circle cx="${x}" cy="${yTotal}" r="5" fill="${paths[0].color}"/>`;
                svg += `<text x="${x}" y="${height - padding + 20}" text-anchor="middle" font-size="10" fill="#666">${app.compNom.substring(0, 10)}</text>`;
                if (type !== 'total') {
                    svg += `<text x="${x}" y="${height - padding + 33}" text-anchor="middle" font-size="9" fill="#999">${app.cat}</text>`;
                }
            });
            
            // L√©gende
            svg += `
                    <text x="${padding}" y="${padding}" font-size="11" fill="${paths[0].color}" font-weight="bold">‚Äî ${paths[0].name}</text>
                    <text x="${padding + 140}" y="${padding}" font-size="11" fill="${paths[1].color}">--- ${paths[1].name}</text>
                    <text x="${padding + 260}" y="${padding}" font-size="11" fill="${paths[2].color}">--- ${paths[2].name}</text>
                    
                    <!-- Valeurs min/max -->
                    <text x="${padding - 40}" y="${height - padding + 5}" font-size="10" fill="#666">${minScore.toFixed(0)}</text>
                    <text x="${padding - 40}" y="${padding + 20}" font-size="10" fill="#666">${maxScore.toFixed(0)}</text>
                </svg>
            `;
            
            return svg;
        }
        
        // ============================================
        // FONCTIONS DE STATISTIQUES PAR √âL√âMENT
        // ============================================
        
        function extraireTousElements() {
            const elements = [];
            
            resultats.forEach(res => {
                const comp = liste.find(c => String(c.id) === String(res.compId));
                
                res.data.equipes.forEach(team => {
                    // Appliquer les fusions manuelles
                    const nomCanonique = team.nom;
                    
                    team.elements.forEach(elem => {
                        elements.push({
                            type: elem.type,
                            niveau: getNiveauFromCode(elem.code, elem.type),
                            bv: elem.bv,
                            goe: elem.goe,
                            score: elem.score,
                            juges: elem.juges,
                            chute: elem.chute,
                            equipe: nomCanonique,
                            equipeOriginal: team.nom,
                            nation: team.nation,
                            compNom: comp ? comp.n : 'Inconnu',
                            cat: res.cat,
                            prog: res.prog
                        });
                    });
                });
            });
            
            return elements;
        }

        function afficherStatistiques() {
            if (resultats.length === 0) {
                document.getElementById('tab-statistiques').innerHTML = `
                    <div class="info-box">
                        <strong>‚ÑπÔ∏è No data available</strong><br>
                        Analysez d'abord des protocoles pour utiliser les statistiques.
                    </div>
                `;
                return;
            }
            
            const tousElements = extraireTousElements();
            const typesElements = [...new Set(tousElements.map(e => e.type))].sort();
            
            // Cr√©er la liste des √©quipes avec nation
            const equipesMap = new Map();
            tousElements.forEach(e => {
                equipesMap.set(e.equipe, e.nation);
            });
            const equipesTriees = Array.from(equipesMap.entries()).sort((a, b) => a[0].localeCompare(b[0]));
            const equipes = [...new Set(tousElements.map(e => e.equipe))].sort();
            
            let html = `
                <h2 style="color: #1e3c72; margin-bottom: 20px;">üìä Statistics by Element</h2>
                
                <div style="background: white; padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                    <h3 style="color: #667eea; margin-bottom: 15px;">Element Selection</h3>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                        <div>
                            <label style="display: block; font-weight: 600; margin-bottom: 5px;">Element Type</label>
                            <select id="statElementType" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px;">
                                <option value="">-- Choose --</option>
            `;
            
            typesElements.forEach(type => {
                const count = tousElements.filter(e => e.type === type).length;
                html += `<option value="${type}">${type} (${count})</option>`;
            });
            
            html += `
                            </select>
                        </div>
                        
                        <div>
                            <label style="display: block; font-weight: 600; margin-bottom: 5px;">Level (optional)</label>
                            <select id="statNiveau" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px;">
                                <option value="">All</option>
                                <option value="Base">Base</option>
                                <option value="1">1</option>
                                <option value="2">2</option>
                                <option value="3">3</option>
                                <option value="4">4</option>
                            </select>
                        </div>
                        
                        <div>
                            <label style="display: block; font-weight: 600; margin-bottom: 5px;">Category</label>
                            <select id="statCategorie" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px;">
                                <option value="">All</option>
                                <option value="Senior">Senior</option>
                                <option value="Junior">Junior</option>
                            </select>
                        </div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                        <div>
                            <label style="display: block; font-weight: 600; margin-bottom: 5px;">Program</label>
                            <select id="statProgram" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px;">
                                <option value="">All</option>
                                <option value="PC">Short Program</option>
                                <option value="PL">Free Program</option>
                            </select>
                        </div>
                        
                        <div>
                            <label style="display: block; font-weight: 600; margin-bottom: 5px;">Team (optional)</label>
                            <input type="text" id="rechercheEquipeStats" placeholder="üîç Rechercher..." 
                                style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 8px; margin-bottom: 5px;"
                                onkeyup="filtrerEquipesStats()">
                            <select id="statEquipe" size="8" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px;">
                                <option value="">All</option>
            `;
            
            equipesTriees.forEach(([nom, nation]) => {
                html += `<option value="${nom}">${nom} (${nation})</option>`;
            });
            
            html += `
                            </select>
                        </div>
                    </div>
                    
                    <div style="margin: 15px 0; padding: 10px; background: #f8f9ff; border-radius: 8px;">
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="statMeilleurParEquipe" style="width: 18px; height: 18px; margin-right: 10px;">
                            <span style="font-weight: 600;">üèÜ Show only best result per team</span>
                        </label>
                        <p style="margin: 5px 0 0 28px; font-size: 0.9em; color: #666;">Useful to compare best performances of each team</p>
                    </div>
                    
                    <button class="btn btn-primary" onclick="analyserElement()">üìä Analyze</button>
                </div>
                
                <div id="statsResult"></div>
            `;
            
            document.getElementById('tab-statistiques').innerHTML = html;
        }
        
        function filtrerEquipesStats() {
            const recherche = document.getElementById('rechercheEquipeStats').value.toLowerCase();
            const select = document.getElementById('statEquipe');
            const options = select.options;
            
            for (let i = 1; i < options.length; i++) { // Skip first option (placeholder)
                const option = options[i];
                const texte = option.textContent.toLowerCase();
                
                if (texte.includes(recherche)) {
                    option.style.display = '';
                } else {
                    option.style.display = 'none';
                }
            }
        }
        
        // ============================================
        // CLASSEMENT DE LA SAISON
        // ============================================
        
        function afficherClassement() {
            if (resultats.length === 0) {
                document.getElementById('classement-content').innerHTML = `
                    <div class="info-box">
                        <strong>‚ÑπÔ∏è No data available</strong><br>
                        Upload PDF protocols to see rankings.
                    </div>`;
                return;
            }
            
            // R√©cup√©rer les filtres
            const inclureSenior = document.getElementById('filter-senior').checked;
            const inclureJunior = document.getElementById('filter-junior').checked;
            const inclureRegional = document.getElementById('filter-regional').checked;
            const inclureNational = document.getElementById('filter-national').checked;
            const inclureChallenger = document.getElementById('filter-challenger').checked;
            const inclureInternational = document.getElementById('filter-international').checked;
            const filtreProgramEl = document.querySelector('input[name="classement-programme"]:checked');
            const filtreProgram = filtreProgramEl ? filtreProgramEl.value : 'total';
            console.log('üîç Filtre programme:', filtreProgram);
            const mode = document.querySelector('input[name="classement-mode"]:checked').value;
            
            // Si mode "total", calculer les totaux par comp√©tition
            if (filtreProgram === 'total') {
                // Regrouper par √©quipe + comp√©tition
                const totauxParComp = {};
                
                resultats.forEach(res => {
                    const comp = liste.find(c => String(c.id) === String(res.compId));
                    if (!comp) return;
                    
                    // Filtre cat√©gorie
                    if (res.cat === 'Senior' && !inclureSenior) return;
                    if (res.cat === 'Junior' && !inclureJunior) return;
                    
                    const typeComp = comp.t;
                    if (typeComp === 'Regional' && !inclureRegional) return;
                    if (typeComp === 'National' && !inclureNational) return;
                    if (typeComp === 'Challenger Series' && !inclureChallenger) return;
                    if (typeComp === 'International' && !inclureInternational) return;
                    
                    res.data.equipes.forEach(team => {
                        const nomCanonique = team.nom;
                        const cle = `${nomCanonique}_${res.compId}_${res.cat}`;
                        
                        if (!totauxParComp[cle]) {
                            totauxParComp[cle] = {
                                equipe: nomCanonique,
                                nation: team.nation,
                                compId: res.compId,
                                compNom: comp.n,
                                compType: typeComp,
                                cat: res.cat,
                                resultats: []
                            };
                        }
                        
                        totauxParComp[cle].resultats.push({
                            prog: res.prog,
                            rang: team.rang,
                            total: team.total,
                            tech: team.tech,
                            pres: team.pres
                        });
                    });
                });
                
                // Calculer les totaux
                const tousLesResultats = Object.values(totauxParComp).map(item => {
                    const totalScore = item.resultats.reduce((sum, r) => sum + r.total, 0);
                    const totalTech = item.resultats.reduce((sum, r) => sum + r.tech, 0);
                    const totalPres = item.resultats.reduce((sum, r) => sum + r.pres, 0);
                    const meilleurRang = Math.min(...item.resultats.map(r => r.rang));
                    const programmes = item.resultats.map(r => r.prog).join(' + ');
                    
                    return {
                        equipe: item.equipe,
                        nation: item.nation,
                        compNom: item.compNom,
                        compType: item.compType,
                        cat: item.cat,
                        prog: programmes,
                        rang: meilleurRang,
                        total: totalScore,
                        tech: totalTech,
                        pres: totalPres
                    };
                });
                
                // Appliquer le mode (meilleur/tous)
                let classement;
                if (mode === 'best') {
                    const meilleursParEquipe = {};
                    tousLesResultats.forEach(r => {
                        if (!meilleursParEquipe[r.equipe] || r.total > meilleursParEquipe[r.equipe].total) {
                            meilleursParEquipe[r.equipe] = r;
                        }
                    });
                    classement = Object.values(meilleursParEquipe);
                } else {
                    classement = tousLesResultats;
                }
                
                classement.sort((a, b) => b.total - a.total);
                afficherTableauClassement(classement);
                
            } else {
                // Mode programme unique (SP ou FS)
                const tousLesResultats = [];
                let nbIgnores = 0;
                const programmesVus = new Set();
                
                resultats.forEach(res => {
                    programmesVus.add(res.prog); // Logger tous les programmes vus
                    
                    if (res.prog !== filtreProgram) {
                        nbIgnores++;
                        return; // Filtrer par programme
                    }
                    
                    // Filtre cat√©gorie
                    if (res.cat === 'Senior' && !inclureSenior) return;
                    if (res.cat === 'Junior' && !inclureJunior) return;
                    
                    const comp = liste.find(c => String(c.id) === String(res.compId));
                    const typeComp = comp ? comp.t : 'Unknown';
                    
                    if (!comp) return;
                    if (typeComp === 'Regional' && !inclureRegional) return;
                    if (typeComp === 'National' && !inclureNational) return;
                    if (typeComp === 'Challenger Series' && !inclureChallenger) return;
                    if (typeComp === 'International' && !inclureInternational) return;
                    
                    res.data.equipes.forEach(team => {
                        const nomCanonique = team.nom;
                        tousLesResultats.push({
                            equipe: nomCanonique,
                            nation: team.nation,
                            compNom: comp.n,
                            compType: typeComp,
                            cat: res.cat,
                            prog: res.prog,
                            rang: team.rang,
                            total: team.total,
                            tech: team.tech,
                            pres: team.pres
                        });
                    });
                });
                
                                                                
                let classement;
                if (mode === 'best') {
                    const meilleursParEquipe = {};
                    tousLesResultats.forEach(r => {
                        if (!meilleursParEquipe[r.equipe] || r.total > meilleursParEquipe[r.equipe].total) {
                            meilleursParEquipe[r.equipe] = r;
                        }
                    });
                    classement = Object.values(meilleursParEquipe);
                } else {
                    classement = tousLesResultats;
                }
                
                classement.sort((a, b) => b.total - a.total);
                afficherTableauClassement(classement);
            }
        }
        
        function afficherTableauClassement(classement) {
            // Afficher
            let html = '<div style="background:white;padding:20px;border-radius:10px;">';
            html += `<p style="color:#666;margin-bottom:20px;">üìä ${classement.length} r√©sultat(s) affich√©(s)</p>`;
            html += '<table style="width:100%;border-collapse:collapse;">';
            html += '<thead><tr style="background:#f5f5f5;text-align:left;">';
            html += '<th style="padding:12px;border-bottom:2px solid #ddd;">#</th>';
            html += '<th style="padding:12px;border-bottom:2px solid #ddd;">Team</th>';
            html += '<th style="padding:12px;border-bottom:2px solid #ddd;">Nation</th>';
            html += '<th style="padding:12px;border-bottom:2px solid #ddd;">Competition</th>';
            html += '<th style="padding:12px;border-bottom:2px solid #ddd;">Cat.</th>';
            html += '<th style="padding:12px;border-bottom:2px solid #ddd;">Prog.</th>';
            html += '<th style="padding:12px;border-bottom:2px solid #ddd;text-align:center;">Rank</th>';
            html += '<th style="padding:12px;border-bottom:2px solid #ddd;text-align:right;"><strong>Total</strong></th>';
            html += '<th style="padding:12px;border-bottom:2px solid #ddd;text-align:right;">Tech</th>';
            html += '<th style="padding:12px;border-bottom:2px solid #ddd;text-align:right;">Pres</th>';
            html += '</tr></thead><tbody>';
            
            classement.forEach((r, idx) => {
                const typeCouleur = {
                    'Regional': '#9c27b0',           // Violet
                    'National': '#2196F3',           // Bleu
                    'International': '#4CAF50',      // Vert
                    'Challenger Series': '#FF9800',  // Orange
                    'Ch. du Monde': '#f44336',       // Rouge
                    'Ch. du Monde J': '#f44336'      // Rouge (Junior)
                };
                const badgeColor = typeCouleur[r.compType] || '#666';
                
                html += `<tr style="border-bottom:1px solid #eee;border-left: 4px solid ${badgeColor};">`;
                html += `<td style="padding:12px;font-weight:bold;">${idx + 1}</td>`;
                html += `<td style="padding:12px;"><strong>${r.equipe}</strong></td>`;
                html += `<td style="padding:12px;">${r.nation}</td>`;
                html += `<td style="padding:12px;"><span style="background:${badgeColor};color:white;padding:2px 8px;border-radius:8px;font-size:0.8em;">${r.compType}</span> ${r.compNom}</td>`;
                html += `<td style="padding:12px;">${r.cat}</td>`;
                html += `<td style="padding:12px;">${r.prog}</td>`;
                html += `<td style="padding:12px;text-align:center;">${r.rang}</td>`;
                html += `<td style="padding:12px;text-align:right;font-weight:bold;font-size:1.1em;">${r.total.toFixed(2)}</td>`;
                html += `<td style="padding:12px;text-align:right;">${r.tech.toFixed(2)}</td>`;
                html += `<td style="padding:12px;text-align:right;">${r.pres.toFixed(2)}</td>`;
                html += '</tr>';
            });
            
            html += '</tbody></table></div>';
            
            document.getElementById('classement-content').innerHTML = html;
        }

        function analyserElement() {
            const typeSelect = document.getElementById('statElementType');
            const niveauSelect = document.getElementById('statNiveau');
            const catSelect = document.getElementById('statCategorie');
            const progSelect = document.getElementById('statProgram');
            const equipeSelect = document.getElementById('statEquipe');
            const statsResult = document.getElementById('statsResult');
            
            if (!typeSelect || !statsResult) {
                alert('Erreur: √âl√©ments non trouv√©s. Essayez de recharger la page.');
                return;
            }
            
            if (!typeSelect.value) {
                alert('S√©lectionnez un type d\'√©l√©ment');
                return;
            }
            
            const tousElements = extraireTousElements();
            
            // Filtrer
            let elementsFilters = tousElements.filter(e => e.type === typeSelect.value);
            
            if (niveauSelect && niveauSelect.value) {
                elementsFilters = elementsFilters.filter(e => e.niveau === niveauSelect.value);
            }
            if (catSelect && catSelect.value) {
                elementsFilters = elementsFilters.filter(e => e.cat === catSelect.value);
            }
            if (progSelect && progSelect.value) {
                elementsFilters = elementsFilters.filter(e => e.prog === progSelect.value);
            }
            if (equipeSelect && equipeSelect.value) {
                elementsFilters = elementsFilters.filter(e => e.equipe === equipeSelect.value);
            }
            
            if (elementsFilters.length === 0) {
                document.getElementById('statsResult').innerHTML = `
                    <div class="info-box">
                        <strong>‚ÑπÔ∏è Aucun √©l√©ment trouv√©</strong><br>
                        Aucun √©l√©ment ne correspond √† ces crit√®res.
                    </div>
                `;
                return;
            }
            
            // Calculer les stats
            const nbTotal = elementsFilters.length;
            const scoreMax = Math.max(...elementsFilters.map(e => e.score));
            const scoreMin = Math.min(...elementsFilters.map(e => e.score));
            const scoreMoyen = elementsFilters.reduce((sum, e) => sum + e.score, 0) / nbTotal;
            const goeMoyen = elementsFilters.reduce((sum, e) => sum + e.goe, 0) / nbTotal;
            const bvMoyen = elementsFilters.reduce((sum, e) => sum + e.bv, 0) / nbTotal;
            const nbChutes = elementsFilters.filter(e => e.chute).length;
            
            // Distribution des niveaux
            const niveaux = {};
            elementsFilters.forEach(e => {
                niveaux[e.niveau] = (niveaux[e.niveau] || 0) + 1;
            });
            
            // Distribution des GOE
            const goeDistribution = {};
            for (let i = -5; i <= 5; i++) {
                goeDistribution[i] = 0;
            }
            elementsFilters.forEach(e => {
                e.juges.forEach(goe => {
                    if (goe >= -5 && goe <= 5) {
                        goeDistribution[goe]++;
                    }
                });
            });
            
            // Top 50 (ou meilleur par √©quipe)
            let topElements = [...elementsFilters].sort((a, b) => b.score - a.score);
            
            // Option : meilleur par √©quipe
            const meilleurParEquipe = document.getElementById('statMeilleurParEquipe')?.checked || false;
            
            if (meilleurParEquipe) {
                // Garder seulement le meilleur score of each team
                const meilleursParEquipe = new Map();
                topElements.forEach(elem => {
                    const equipeKey = elem.equipe;
                    if (!meilleursParEquipe.has(equipeKey) || meilleursParEquipe.get(equipeKey).score < elem.score) {
                        meilleursParEquipe.set(equipeKey, elem);
                    }
                });
                topElements = Array.from(meilleursParEquipe.values()).sort((a, b) => b.score - a.score);
            }
            
            // Limiter √† 50
            const top10 = topElements.slice(0, 50);
            
            // Filters actifs
            const filtresActifs = [];
            if (niveauSelect) filtresActifs.push(`Niveau ${niveauSelect}`);
            if (catSelect) filtresActifs.push(catSelect);
            if (progSelect) filtresActifs.push(progSelect === 'SP' ? 'Short Program' : 'Free Program');
            if (equipeSelect) filtresActifs.push(equipeSelect);
            
            let html = `
                <div style="background: white; padding: 20px; border-radius: 10px; margin-top: 20px;">
                    <h3 style="color: #1e3c72; margin-bottom: 10px;">Analyse : ${typeSelect}</h3>
                    ${filtresActifs.length > 0 ? `<p style="color: #667eea; margin-bottom: 20px;">Filters : ${filtresActifs.join(', ')}</p>` : ''}
                    
                    <!-- Vue d'ensemble -->
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 30px;">
                        <div style="background: #e8eaf6; padding: 15px; border-radius: 8px;">
                            <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">Nb d'ex√©cutions</div>
                            <div style="font-size: 1.8em; font-weight: bold; color: #1e3c72;">${nbTotal}</div>
                        </div>
                        <div style="background: #e8f5e9; padding: 15px; border-radius: 8px;">
                            <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">Score moyen</div>
                            <div style="font-size: 1.8em; font-weight: bold; color: #4CAF50;">${scoreMoyen.toFixed(2)}</div>
                        </div>
                        <div style="background: #fff3e0; padding: 15px; border-radius: 8px;">
                            <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">GOE moyen</div>
                            <div style="font-size: 1.8em; font-weight: bold; color: #FF9800;">${goeMoyen >= 0 ? '+' : ''}${goeMoyen.toFixed(2)}</div>
                        </div>
                        <div style="background: #fce4ec; padding: 15px; border-radius: 8px;">
                            <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">BV moyen</div>
                            <div style="font-size: 1.8em; font-weight: bold; color: #c2185b;">${bvMoyen.toFixed(2)}</div>
                        </div>
                        <div style="background: #ffebee; padding: 15px; border-radius: 8px;">
                            <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">Chutes</div>
                            <div style="font-size: 1.8em; font-weight: bold; color: #f44336;">${nbChutes}</div>
                        </div>
                        <div style="background: #e0f2f1; padding: 15px; border-radius: 8px;">
                            <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">Meilleur score</div>
                            <div style="font-size: 1.8em; font-weight: bold; color: #00796b;">${scoreMax.toFixed(2)}</div>
                        </div>
                    </div>
                    
                    <!-- Distribution des GOE -->
                    <h4 style="color: #667eea; margin-bottom: 15px;">üìä Distribution des GOE (tous juges confondus)</h4>
                    <div style="margin-bottom: 30px;">
                        ${genererGraphiqueGOE(goeDistribution)}
                    </div>
                    
                    <!-- Distribution des niveaux -->
                    ${!niveauSelect ? `
                    <h4 style="color: #667eea; margin-bottom: 15px;">üéØ R√©partition par niveau</h4>
                    <div style="margin-bottom: 30px;">
                        ${genererGraphiqueNiveaux(niveaux, nbTotal)}
                    </div>
                    ` : ''}
                    
                    <!-- Top 50 (ou meilleur par √©quipe) -->
                    <h4 style="color: #667eea; margin-bottom: 15px;">
                        üèÜ Top ${top10.length} 
                        ${meilleurParEquipe ? '(meilleur par √©quipe)' : equipeSelect ? 'des ex√©cutions' : 'des meilleures ex√©cutions'}
                    </h4>
                    <table style="width:100%; border-collapse: collapse;">
                        <thead style="background: #f5f5f5;">
                            <tr>
                                <th style="padding: 12px; text-align: center; border-bottom: 2px solid #667eea;">Rank</th>
                                <th style="padding: 12px; text-align: left; border-bottom: 2px solid #667eea;">Team</th>
                                <th style="padding: 12px; text-align: left; border-bottom: 2px solid #667eea;">Competition</th>
                                <th style="padding: 12px; text-align: center; border-bottom: 2px solid #667eea;">Level</th>
                                <th style="padding: 12px; text-align: center; border-bottom: 2px solid #667eea;">BV</th>
                                <th style="padding: 12px; text-align: center; border-bottom: 2px solid #667eea;">GOE</th>
                                <th style="padding: 12px; text-align: center; border-bottom: 2px solid #667eea;">Score</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            top10.forEach((elem, index) => {
                const rankClass = index < 3 ? `rank-${index + 1}` : '';
                html += `
                    <tr class="${rankClass}" style="border-bottom: 1px solid #f0f0f0;">
                        <td style="padding: 12px; text-align: center;"><strong>${index + 1}</strong></td>
                        <td style="padding: 12px;">${elem.equipe} (${elem.nation})</td>
                        <td style="padding: 12px;">${elem.compNom} - ${elem.cat} ${elem.prog}</td>
                        <td style="padding: 12px; text-align: center;"><span class="level-badge">Niv ${elem.niveau}</span></td>
                        <td style="padding: 12px; text-align: center; font-family: monospace;">${elem.bv.toFixed(2)}</td>
                        <td style="padding: 12px; text-align: center; font-family: monospace; color: ${elem.goe >= 0 ? '#4caf50' : '#f44336'};">${elem.goe >= 0 ? '+' : ''}${elem.goe.toFixed(2)}</td>
                        <td style="padding: 12px; text-align: center; font-family: monospace;"><strong>${elem.score.toFixed(2)}</strong></td>
                    </tr>
                `;
            });
            
            html += `
                        </tbody>
                    </table>
                </div>
            `;
            
            document.getElementById('statsResult').innerHTML = html;
        }

        function genererGraphiqueGOE(distribution) {
            const width = 800;
            const height = 250;
            const padding = 40;
            
            const maxCount = Math.max(...Object.values(distribution));
            const yScale = (height - 2 * padding) / (maxCount || 1);
            const barWidth = (width - 2 * padding) / 11; // -5 √† +5 = 11 valeurs
            
            let svg = `
                <svg width="${width}" height="${height}" style="border: 1px solid #e0e0e0; border-radius: 8px; background: white;">
                    <!-- Titre -->
                    <text x="${width/2}" y="20" text-anchor="middle" font-size="14" font-weight="bold" fill="#1e3c72">Distribution des GOE</text>
                    
                    <!-- Axes -->
                    <line x1="${padding}" y1="${height - padding}" x2="${width - padding}" y2="${height - padding}" stroke="#ccc" stroke-width="2"/>
                    <line x1="${padding}" y1="${padding + 10}" x2="${padding}" y2="${height - padding}" stroke="#ccc" stroke-width="2"/>
                    
                    <!-- Barres -->
            `;
            
            for (let goe = -5; goe <= 5; goe++) {
                const count = distribution[goe] || 0;
                const x = padding + (goe + 5) * barWidth;
                const barHeight = count * yScale;
                const y = height - padding - barHeight;
                
                const color = goe < 0 ? '#f44336' : (goe === 0 ? '#999' : '#4CAF50');
                
                svg += `
                    <rect x="${x + 5}" y="${y}" width="${barWidth - 10}" height="${barHeight}" fill="${color}" opacity="0.8"/>
                    <text x="${x + barWidth/2}" y="${height - padding + 20}" text-anchor="middle" font-size="11" fill="#666">${goe >= 0 ? '+' : ''}${goe}</text>
                    <text x="${x + barWidth/2}" y="${y - 5}" text-anchor="middle" font-size="10" fill="#666">${count}</text>
                `;
            }
            
            svg += `</svg>`;
            return svg;
        }

        function genererGraphiqueNiveaux(niveaux, total) {
            const width = 600;
            const height = 200;
            const padding = 40;
            
            const niveauxOrdre = ['Base', '1', '2', '3', '4'];
            const niveauxPresents = niveauxOrdre.filter(n => niveaux[n]);
            
            if (niveauxPresents.length === 0) return '<p>No data</p>';
            
            const barWidth = (width - 2 * padding) / niveauxPresents.length;
            const maxCount = Math.max(...Object.values(niveaux));
            const yScale = (height - 2 * padding) / (maxCount || 1);
            
            let svg = `
                <svg width="${width}" height="${height}" style="border: 1px solid #e0e0e0; border-radius: 8px; background: white;">
                    <!-- Axes -->
                    <line x1="${padding}" y1="${height - padding}" x2="${width - padding}" y2="${height - padding}" stroke="#ccc" stroke-width="2"/>
                    <line x1="${padding}" y1="${padding + 10}" x2="${padding}" y2="${height - padding}" stroke="#ccc" stroke-width="2"/>
                    
                    <!-- Barres -->
            `;
            
            niveauxPresents.forEach((niveau, index) => {
                const count = niveaux[niveau];
                const percent = ((count / total) * 100).toFixed(1);
                const x = padding + index * barWidth;
                const barHeight = count * yScale;
                const y = height - padding - barHeight;
                
                svg += `
                    <rect x="${x + 10}" y="${y}" width="${barWidth - 20}" height="${barHeight}" fill="#667eea" opacity="0.8"/>
                    <text x="${x + barWidth/2}" y="${height - padding + 20}" text-anchor="middle" font-size="12" fill="#666">Niv ${niveau}</text>
                    <text x="${x + barWidth/2}" y="${y - 5}" text-anchor="middle" font-size="10" fill="#666">${count} (${percent}%)</text>
                `;
            });
            
            svg += `</svg>`;
            return svg;
        }
        
        function telechargerPage() {
            const pageHTML = document.documentElement.outerHTML;
            const blob = new Blob([pageHTML], {type: 'text/html'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'synchro_system_v48_' + new Date().toISOString().split('T')[0] + '.html';
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function exportData() {
            const data = {
                competitions: liste,
                resultats: resultats,
                fusions: fusionsEquipes,
                date: new Date().toISOString()
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'synchro_data_' + new Date().toISOString().split('T')[0] + '.json';
            a.click();
            URL.revokeObjectURL(url);
            alert('‚úÖ Donn√©es export√©es ! Conservez ce fichier en lieu s√ªr.');
        }
        
        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!confirm('‚ö†Ô∏è ATTENTION : Importer des donn√©es remplacera TOUTES vos donn√©es actuelles. Continuer ?')) {
                event.target.value = ''; // Reset input
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // V√©rifier que le fichier contient les bonnes donn√©es
                    if (!data.competitions || !data.resultats) {
                        alert('‚ùå Fichier JSON invalide : format incorrect');
                        return;
                    }
                    
                    // Importer les donn√©es
                    liste = data.competitions || [];
                    resultats = data.resultats || [];
                    fusionsEquipes = data.fusions || [];
                    
                    // Sauvegarder dans localStorage
                    localStorage.setItem(DB_COMPS, JSON.stringify(liste));
                    localStorage.setItem(DB_RES, JSON.stringify(resultats));
                    localStorage.setItem('synchro_fusions_2025', JSON.stringify(fusionsEquipes));
                    
                    alert(`‚úÖ Donn√©es import√©es avec succ√®s !\n\nüìä ${liste.length} competitions\nüìÑ ${resultats.length} r√©sultats\nüîó ${fusionsEquipes.length} fusions d'√©quipes\n\nDate de sauvegarde : ${new Date(data.date).toLocaleString()}`);
                    
                    // Recharger la page pour afficher les nouvelles donn√©es
                    location.reload();
                    
                } catch (error) {
                    console.error('Erreur import:', error);
                    alert('‚ùå Erreur lors de l\'import : ' + error.message);
                }
            };
            
            reader.readAsText(file);
            event.target.value = ''; // Reset input pour permettre de r√©-importer le m√™me fichier
        }
        
        // ===== √âDITEUR D'√âQUIPES =====
        function editeurInit() {
            const select = document.getElementById('editeurCompSelect');
            if (!select) return;
            select.innerHTML = '<option value="">-- Choose une comp√©tition --</option>';
            liste.forEach(comp => {
                const hasRes = resultats.some(r => String(r.compId) === String(comp.id));
                if (hasRes) {
                    const opt = document.createElement('option');
                    opt.value = comp.id;
                    opt.textContent = comp.n;
                    select.appendChild(opt);
                }
            });
        }
        
        function editeurChargerResultats() {
            const compId = document.getElementById('editeurCompSelect').value;
            const progSelect = document.getElementById('editeurProgSelect');
            const progDiv = document.getElementById('editeurResultatSelect');
            const tableDiv = document.getElementById('editeurTableEquipes');
            
            tableDiv.style.display = 'none';
            tableDiv.innerHTML = '';
            
            if (!compId) { progDiv.style.display = 'none'; return; }
            
            const resComp = resultats.filter(r => String(r.compId) === String(compId));
            progSelect.innerHTML = '';
            resComp.forEach(r => {
                const opt = document.createElement('option');
                opt.value = r.id;
                opt.textContent = `${r.cat} - ${r.prog === 'SP' ? 'Short Program' : 'Free Program'}`;
                progSelect.appendChild(opt);
            });
            progDiv.style.display = 'block';
            editeurChargerEquipes();
        }
        
        function editeurChargerEquipes() {
            const resId = document.getElementById('editeurProgSelect').value;
            const tableDiv = document.getElementById('editeurTableEquipes');
            if (!resId) { tableDiv.style.display = 'none'; return; }
            
            const res = resultats.find(r => r.id === resId);
            if (!res) return;
            
            let html = `<table style="width:100%;border-collapse:collapse;background:white;border-radius:8px;overflow:hidden;box-shadow:0 2px 4px rgba(0,0,0,0.1);">
                <thead>
                    <tr style="background:#667eea;color:white;">
                        <th style="padding:10px;">Rank</th>
                        <th style="padding:10px;text-align:left;">Nom d'√©quipe</th>
                        <th style="padding:10px;">Nation</th>
                        <th style="padding:10px;">Score</th>
                        <th style="padding:10px;">Actions</th>
                    </tr>
                </thead><tbody>`;
            
            res.data.equipes.forEach((eq, idx) => {
                html += `<tr style="border-bottom:1px solid #eee;${idx % 2 === 0 ? '' : 'background:#f9f9f9'}">
                    <td style="padding:10px;text-align:center;font-weight:bold;">${eq.rang}</td>
                    <td style="padding:10px;">
                        <input id="editNom_${resId}_${idx}" value="${eq.nom}" 
                            style="width:100%;padding:6px;border:1px solid #ddd;border-radius:4px;font-size:0.95em;">
                    </td>
                    <td style="padding:10px;">
                        <input id="editNat_${resId}_${idx}" value="${eq.nation || ''}" 
                            style="width:70px;padding:6px;border:1px solid #ddd;border-radius:4px;text-align:center;font-size:0.95em;text-transform:uppercase;">
                    </td>
                    <td style="padding:10px;text-align:center;">${eq.total.toFixed(2)}</td>
                    <td style="padding:10px;text-align:center;">
                        <button onclick="editeurSauvegarderEquipe('${resId}', ${idx})" 
                            style="background:#4caf50;color:white;border:none;padding:6px 12px;border-radius:4px;cursor:pointer;margin-right:5px;">‚úÖ Sauver</button>
                        <button onclick="editeurSupprimerEquipe('${resId}', ${idx})" 
                            style="background:#f44336;color:white;border:none;padding:6px 12px;border-radius:4px;cursor:pointer;">üóëÔ∏è Suppr.</button>
                    </td>
                </tr>`;
            });
            
            html += `</tbody></table>`;
            tableDiv.innerHTML = html;
            tableDiv.style.display = 'block';
        }
        
        function editeurSauvegarderEquipe(resId, idx) {
            const res = resultats.find(r => r.id === resId);
            if (!res) return;
            
            const nomInput = document.getElementById(`editNom_${resId}_${idx}`);
            const natInput = document.getElementById(`editNat_${resId}_${idx}`);
            
            const nouveauNom = nomInput.value.trim();
            const nouvelleNation = natInput.value.trim().toUpperCase();
            
            if (!nouveauNom) { alert('Le nom ne peut pas √™tre vide !'); return; }
            
            res.data.equipes[idx].nom = nouveauNom;
            res.data.equipes[idx].nation = nouvelleNation;
            
            localStorage.setItem(DB_RES, JSON.stringify(resultats));
            chargerDonnees();
            
            nomInput.style.background = '#e8f5e9';
            natInput.style.background = '#e8f5e9';
            setTimeout(() => {
                nomInput.style.background = '';
                natInput.style.background = '';
            }, 1500);
        }
        
        function editeurSupprimerEquipe(resId, idx) {
            const res = resultats.find(r => r.id === resId);
            if (!res) return;
            
            const nomEquipe = res.data.equipes[idx].nom;
            if (!confirm(`Supprimer "${nomEquipe}" de ce r√©sultat ?\n\nCette action est irr√©versible.`)) return;
            
            res.data.equipes.splice(idx, 1);
            
            // Recalculer les rangs
            res.data.equipes.sort((a, b) => b.total - a.total);
            res.data.equipes.forEach((eq, i) => { eq.rang = i + 1; });
            
            localStorage.setItem(DB_RES, JSON.stringify(resultats));
            chargerDonnees();
            editeurChargerEquipes(); // Rafra√Æchir le tableau
            
            alert(`‚úÖ "${nomEquipe}" supprim√©e !`);
        }
        
        function switchTab(tab) {
            // Masquer tous les onglets
            const allTabs = ['calendar', 'classement', 'comparaisons', 'statistiques', 'settings'];
            allTabs.forEach(tabName => {
                const el = document.getElementById('tab-' + tabName);
                if (el) el.style.display = 'none';
            });
            
            // Afficher l'onglet s√©lectionn√©
            const selectedEl = document.getElementById('tab-' + tab);
            if (selectedEl) selectedEl.style.display = 'block';
            
            // Appeler les fonctions d'affichage
            if (tab === 'classement') {
                afficherClassement();
            } else if (tab === 'comparaisons') {
                afficherComparaisons();
            } else if (tab === 'statistiques') {
                afficherStatistiques();
            } else if (tab === 'settings') {
                if (typeof afficherGestionEquipes === 'function') afficherGestionEquipes();
                if (typeof editeurInit === 'function') editeurInit();
            }
        }
        
        function migrerRangs() {
            const statusDiv = document.getElementById('migration-status');
            
            if (resultats.length === 0) {
                statusDiv.innerHTML = `<div class="info-box">‚ÑπÔ∏è Aucun r√©sultat √† migrer.</div>`;
                return;
            }
            
            statusDiv.innerHTML = `<div style="padding:10px;background:#e3f2fd;border-radius:5px;">
                ‚è≥ Migration en cours...
            </div>`;
            
            let nbMigres = 0;
            let nbEquipesMigrees = 0;
            let nbProgConverts = 0;
            
            // Pour chaque r√©sultat
            resultats.forEach(res => {
                // Convertir SP/FS en PC/PL
                if (res.prog === 'SP') {
                    res.prog = 'SP';
                    nbProgConverts++;
                } else if (res.prog === 'FS') {
                    res.prog = 'FS';
                    nbProgConverts++;
                }
                
                if (res.data && res.data.equipes && res.data.equipes.length > 0) {
                    // Trier les √©quipes par score total (d√©croissant)
                    res.data.equipes.sort((a, b) => b.total - a.total);
                    
                    // Recalculer les rangs
                    res.data.equipes.forEach((equipe, index) => {
                        const ancienRang = equipe.rang;
                        equipe.rang = index + 1;
                        if (ancienRang !== equipe.rang) {
                            nbEquipesMigrees++;
                        }
                    });
                    
                    nbMigres++;
                }
            });
            
            // Sauvegarder
            const ok = sauvegarderResultats();
            
            if (ok) {
                statusDiv.innerHTML = `<div class="success-box">
                    ‚úÖ Migration r√©ussie !<br>
                    üìä ${nbMigres} r√©sultat${nbMigres > 1 ? 's' : ''} trait√©${nbMigres > 1 ? 's' : ''}<br>
                    üîÑ ${nbEquipesMigrees} √©quipe${nbEquipesMigrees > 1 ? 's' : ''} corrig√©e${nbEquipesMigrees > 1 ? 's' : ''}<br>
                    ${nbProgConverts > 0 ? `üîÄ ${nbProgConverts} programme${nbProgConverts > 1 ? 's' : ''} converti${nbProgConverts > 1 ? 's' : ''} (SP/FS ‚Üí PC/PL)<br>` : ''}
                    <br>
                    üí° Vous pouvez maintenant consulter vos r√©sultats !
                </div>`;
                
                // Rafra√Æchir l'affichage du classement si on est sur cet onglet
                afficherClassement();
            } else {
                statusDiv.innerHTML = `<div style="padding:10px;background:#ffebee;border-radius:5px;color:#c62828;">
                    ‚ùå Erreur lors de la sauvegarde
                </div>`;
            }
        }
        
        function clearData() {
            if (confirm('Effacer TOUTES les donn√©es ?')) {
                localStorage.removeItem(DB_COMPS);
                localStorage.removeItem(DB_RES);
                liste = [];
                resultats = [];
                afficher();
                alert('‚úÖ Donn√©es effac√©es !');
            }
        }
    </script>

    <!-- DIV DE LOGS VISIBLE -->
    <div id="debug-log" style="position:fixed;bottom:0;left:0;right:0;max-height:200px;overflow-y:auto;background:rgba(0,0,0,0.9);color:#0f0;font-family:monospace;font-size:12px;padding:10px;z-index:100000;border-top:2px solid #0f0;">
        <div style="color:#ff0;font-weight:bold;margin-bottom:5px;">üîç DEBUG LOGS</div>
        <div id="debug-content"></div>
    </div>
</body>
</html>
