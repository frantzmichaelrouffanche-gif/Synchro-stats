<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Syst√®me Synchro 2025-26 v104</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 20px; }
        .container { max-width: 1600px; margin: 0 auto; }
        .header { background: white; border-radius: 15px; padding: 30px; margin-bottom: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); }
        .header h1 { color: #1e3c72; font-size: 2em; }
        .btn { padding: 12px 24px; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 1em; transition: all 0.3s; }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
        .btn-success { background: #4CAF50; color: white; }
        .btn-excel { background: #217346; color: white; }
        .info-box { background: #e3f2fd; border-left: 4px solid #2196F3; padding: 15px; margin: 15px 0; border-radius: 5px; }
        .debug-box { background: #fff3e0; border-left: 4px solid #FF9800; padding: 15px; margin: 15px 0; border-radius: 5px; font-family: monospace; font-size: 0.85em; }
        .competition-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(350px, 1fr)); gap: 20px; margin-top: 20px; }
        .competition-card { background: #f8f9ff; border: 2px solid #e0e0e0; border-radius: 12px; padding: 20px; cursor: pointer; transition: all 0.3s; }
        .competition-card:hover { transform: translateY(-5px); box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3); }
        .competition-name { font-size: 1.2em; font-weight: bold; color: #1e3c72; margin-bottom: 8px; }
        .stat-card { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 10px; text-align: center; }
        .stat-number { font-size: 2.5em; font-weight: bold; }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin: 20px 0; }
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 1000; overflow-y: auto; padding: 20px; }
        .modal.active { display: block; }
        .modal-content { background: white; border-radius: 15px; padding: 30px; max-width: 1200px; margin: 20px auto; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid #e0e0e0; }
        .modal-header h2 { color: #1e3c72; font-size: 1.8em; }
        .close-btn { background: #f44336; color: white; border: none; padding: 8px 20px; border-radius: 8px; cursor: pointer; font-weight: 600; }
        .cat-section { margin: 20px 0; padding: 20px; background: #f8f9ff; border-radius: 10px; }
        .cat-title { font-size: 1.2em; font-weight: bold; color: #1e3c72; margin-bottom: 15px; }
        .prog-section { margin: 15px 0; padding: 15px; background: white; border-radius: 8px; border: 2px solid #e0e0e0; }
        .prog-title { font-weight: 600; color: #667eea; margin-bottom: 10px; }
        .btn-primary { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
        .btn-small { padding: 6px 12px; font-size: 0.85em; }
        .success-box { background: #e8f5e9; border-left: 4px solid #4CAF50; padding: 10px; margin: 10px 0; border-radius: 5px; color: #2e7d32; }
        
        /* Styles pour l'affichage d√©taill√© */
        .team-section { margin: 30px 0; border: 2px solid #e0e0e0; border-radius: 15px; overflow: hidden; box-shadow: 0 4px 15px rgba(0,0,0,0.1); }
        .team-header-detailed { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; }
        .team-title-detailed { font-size: 1.5em; margin-bottom: 15px; }
        .team-scores { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; }
        .score-box { background: rgba(255,255,255,0.2); padding: 12px; border-radius: 8px; }
        .score-box .label { font-size: 0.8em; opacity: 0.9; margin-bottom: 4px; }
        .score-box .value { font-size: 1.3em; font-weight: bold; }
        .score-box .rank { font-size: 0.9em; opacity: 0.95; margin-top: 2px; }
        
        table { width: 100%; border-collapse: collapse; background: white; }
        thead { background: #f5f5f5; border-bottom: 2px solid #667eea; }
        th { padding: 12px 10px; text-align: center; font-weight: 600; font-size: 0.9em; color: #1e3c72; }
        th.text-left { text-align: left; }
        td { padding: 12px 10px; text-align: center; border-bottom: 1px solid #f0f0f0; }
        td.text-left { text-align: left; font-weight: 600; }
        
        .element-row { background: white; }
        .element-row:hover { background: #f8f9ff; }
        
        .judge-rank-row { background: #fafafa; font-size: 0.9em; border-bottom: 2px solid #e0e0e0 !important; }
        .judge-rank-row td { padding: 8px 10px; font-style: italic; color: #666; }
        
        .total-row { background: #e8eaf6; font-weight: bold; border-top: 3px solid #667eea !important; border-bottom: 3px solid #667eea !important; }
        .total-row td { padding: 15px 10px; font-size: 1.05em; }
        
        .rank-row { background: #f5f5f5; font-weight: 600; border-bottom: 3px solid #667eea !important; }
        .rank-row td { padding: 12px 10px; }
        
        .rank-badge { display: inline-block; background: #667eea; color: white; padding: 4px 10px; border-radius: 12px; font-weight: bold; font-size: 0.9em; }
        .rank-1 .rank-badge, .rank-badge.rank-1 { background: linear-gradient(135deg, #FFD700, #FFA500); }
        .rank-2 .rank-badge, .rank-badge.rank-2 { background: linear-gradient(135deg, #C0C0C0, #A8A8A8); }
        .rank-3 .rank-badge, .rank-badge.rank-3 { background: linear-gradient(135deg, #CD7F32, #B8860B); }
        
        .element-code { font-family: 'Monaco', 'Courier New', monospace; background: #e8eaf6; padding: 4px 8px; border-radius: 4px; font-weight: bold; color: #1e3c72; }
        .level-badge { display: inline-block; background: #4caf50; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.85em; margin-left: 5px; }
        .fall-badge { display: inline-block; background: #f44336; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.75em; margin-left: 5px; }
        
        .number { font-family: 'Monaco', 'Courier New', monospace; }
        .positive { color: #4caf50; }
        .negative { color: #f44336; }
        .goe-zero { color: #000000; }
        
        .rank-better, .judge-rank-row td.rank-better, .rank-row td.rank-better { color: #2e7d32 !important; font-weight: 900 !important; font-style: normal !important; }
        .rank-worse, .judge-rank-row td.rank-worse, .rank-row td.rank-worse { color: #c62828 !important; font-weight: 900 !important; font-style: normal !important; }
        .rank-equal, .judge-rank-row td.rank-equal, .rank-row td.rank-equal { color: #000000 !important; font-weight: 700 !important; font-style: normal !important; }
        
        .rank-better-header { color: #2e7d32; font-weight: bold; }
        .rank-worse-header { color: #c62828; font-weight: bold; }
        .rank-equal-header { color: #ffffff; font-weight: normal; }
        
        .section-title { background: #f5f5f5; padding: 15px 30px; border-top: 2px solid #e0e0e0; font-weight: bold; color: #1e3c72; font-size: 1.1em; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>‚õ∏Ô∏è Syst√®me Synchro 2025-26 v104</h1>
            <p>Calendrier + Analyse + Export Excel + Comparaisons + Statistiques + Classement</p>
        </div>
        
        <div class="info-box">
            <strong>üí° √âtape 1 :</strong> Chargez le calendrier 2025-26
        </div>
        
        <div style="margin-bottom:20px;">
            <button class="btn btn-success" onclick="switchTab('calendar')" style="margin-right:10px;">üìÖ Calendrier</button>
            <button class="btn" style="background:#667eea;color:white;" onclick="switchTab('classement')">üèÜ Classement</button>
            <button class="btn" style="background:#667eea;color:white;" onclick="switchTab('comparaisons')">üìà Comparaisons</button>
            <button class="btn" style="background:#667eea;color:white;" onclick="switchTab('statistiques')">üìä Statistiques</button>
            <button class="btn" style="background:#667eea;color:white;" onclick="switchTab('settings')">‚öôÔ∏è Param√®tres</button>
            <button class="btn" style="background:#FF9800;color:white;" onclick="afficherDebug()">üîç Debug</button>
        </div>
        
        <div id="debugInfo" class="debug-box" style="display:none;"></div>
        
        <div id="tab-calendar">
        
        <button class="btn btn-success" onclick="chargerCalendrier()">üìã Charger le calendrier</button>
        
        <div style="display: flex; gap: 15px; margin: 30px 0; flex-wrap: wrap;">
            <div style="flex: 1; min-width: 200px;">
                <label style="display: block; font-weight: 600; margin-bottom: 5px; color: #1e3c72;">üîç Rechercher</label>
                <input type="text" id="search" placeholder="Nom..." onkeyup="afficher()" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px;">
            </div>
            <div style="flex: 1; min-width: 200px;">
                <label style="display: block; font-weight: 600; margin-bottom: 5px; color: #1e3c72;">üåç Pays</label>
                <select id="pays" onchange="afficher()" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px;">
                    <option value="">Tous</option>
                </select>
            </div>
        </div>
        
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-number" id="total">0</div>
                <div style="font-size: 0.9em;">Comp√©titions</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="totalPays">0</div>
                <div style="font-size: 0.9em;">Pays</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="totalResultats">0</div>
                <div style="font-size: 0.9em;">R√©sultats analys√©s</div>
            </div>
        </div>
        
        <div class="competition-grid" id="grid"></div>
        </div>
        
        <div id="tab-comparaisons" style="display:none;">
            <!-- Contenu g√©n√©r√© par afficherComparaisons() -->
        </div>
        
        <div id="tab-classement" style="display:none;">
            <h2 style="color: #1e3c72; margin-bottom: 20px;">üèÜ Classement de la saison</h2>
            
            <div style="background:white;padding:20px;border-radius:10px;margin-bottom:20px;">
                <h3 style="color:#1e3c72;margin-top:0;">Filtres</h3>
                
                <div style="margin-bottom:15px;">
                    <strong>Cat√©gorie :</strong><br>
                    <label style="display:inline-block;margin-right:15px;">
                        <input type="checkbox" id="filter-senior" checked onchange="afficherClassement()"> Senior
                    </label>
                    <label style="display:inline-block;margin-right:15px;">
                        <input type="checkbox" id="filter-junior" checked onchange="afficherClassement()"> Junior
                    </label>
                </div>
                
                <div style="margin-bottom:15px;">
                    <strong>Type de comp√©tition :</strong><br>
                    <label style="display:inline-block;margin-right:15px;">
                        <input type="checkbox" id="filter-regional" checked onchange="afficherClassement()"> üü£ R√©gional
                    </label>
                    <label style="display:inline-block;margin-right:15px;">
                        <input type="checkbox" id="filter-national" checked onchange="afficherClassement()"> üîµ National
                    </label>
                    <label style="display:inline-block;margin-right:15px;">
                        <input type="checkbox" id="filter-challenger" checked onchange="afficherClassement()"> üü† Challenger
                    </label>
                    <label style="display:inline-block;margin-right:15px;">
                        <input type="checkbox" id="filter-international" checked onchange="afficherClassement()"> üü¢ International
                    </label>
                </div>
                
                <div style="margin-bottom:15px;">
                    <strong>Programme :</strong><br>
                    <label style="margin-right:15px;">
                        <input type="radio" name="classement-programme" value="total" checked onchange="afficherClassement()"> Total comp√©tition (PC+PL)
                    </label>
                    <label style="margin-right:15px;">
                        <input type="radio" name="classement-programme" value="PC" onchange="afficherClassement()"> Programme Court uniquement
                    </label>
                    <label>
                        <input type="radio" name="classement-programme" value="PL" onchange="afficherClassement()"> Programme Long uniquement
                    </label>
                </div>
                
                <div style="margin-bottom:15px;">
                    <strong>Affichage :</strong><br>
                    <label>
                        <input type="radio" name="classement-mode" value="meilleur" checked onchange="afficherClassement()"> Meilleur r√©sultat par √©quipe
                    </label>
                    <label style="margin-left:20px;">
                        <input type="radio" name="classement-mode" value="tous" onchange="afficherClassement()"> Tous les r√©sultats
                    </label>
                </div>
            </div>
            
            <div id="classement-content"></div>
        </div>
        
        <div id="tab-statistiques" style="display:none;">
            <!-- Contenu g√©n√©r√© par afficherStatistiques() -->
        </div>
        
        <div id="tab-settings" style="display:none;">
            <h2 style="color: #1e3c72; margin-bottom: 20px;">‚öôÔ∏è Param√®tres</h2>
            
            <h3 style="color:#1e3c72;margin-top:20px;">üè∑Ô∏è Format des noms d'√©quipes</h3>
            <div style="padding:20px;background:#f8f9ff;border-radius:10px;margin-bottom:20px;">
                <div style="display:flex;align-items:center;margin-bottom:15px;">
                    <input type="checkbox" id="standardiserCheckbox" onchange="toggleStandardisation()" style="width:20px;height:20px;margin-right:10px;">
                    <label for="standardiserCheckbox" style="font-weight:600;font-size:1.1em;">Standardiser les noms au format ISU international</label>
                </div>
                <div class="info-box" style="margin:0;">
                    <strong>üìã Format ISU :</strong><br>
                    <ul style="margin-top:10px;margin-left:20px;">
                        <li><strong>Senior :</strong> Team [Nom]<br>
                            <em>Ex: "Dream Edges" (Kaari) ‚Üí "Team Dream Edges" (FIN)</em></li>
                        <li><strong>Junior :</strong> Team [Nom] Junior<br>
                            <em>Ex: "Dream Edges" (Kaari) ‚Üí "Team Dream Edges Junior" (FIN)</em></li>
                    </ul>
                    <p style="margin-top:10px;"><strong>üéØ Conversion automatique :</strong></p>
                    <ul style="margin-left:20px;">
                        <li>Les codes clubs nationaux (Kaari, HL, ESS, HTK, etc.) sont automatiquement convertis en codes pays (FIN, USA, CAN, etc.)</li>
                        <li>La nationalit√© s'affiche entre parenth√®ses : "Team Helsinki Rockettes (FIN)"</li>
                        <li>Le nom reste propre et professionnel, sans suffixe de club</li>
                    </ul>
                </div>
            </div>
            
            <h3 style="color:#1e3c72;margin-top:30px;">üóÉÔ∏è Base de donn√©es d'√©quipes</h3>
            <div style="padding:20px;background:#f8f9ff;border-radius:10px;margin-bottom:20px;">
                <div class="info-box" style="margin-bottom:15px;">
                    <strong>üìä √âquipes reconnues :</strong> <span id="nbEquipesDB">0</span> √©quipes dans la base<br>
                    <strong>üéØ D√©tection automatique :</strong> Le syst√®me reconna√Æt automatiquement les √©quipes et trouve leur pays
                </div>
                
                <button class="btn btn-primary" onclick="afficherListeEquipes()">üìã Voir toutes les √©quipes</button>
                <button class="btn btn-success" onclick="ajouterEquipeManuelle()" style="margin-left:10px;">‚ûï Ajouter une √©quipe</button>
                
                <div id="liste-equipes" style="display:none;margin-top:20px;max-height:400px;overflow-y:auto;">
                    <!-- Liste des √©quipes sera affich√©e ici -->
                </div>
            </div>
            
            <h3 style="color:#1e3c72;margin-top:30px;">üîó Gestion des √©quipes</h3>
            <div id="gestion-equipes"></div>
            
            <h3 style="color:#1e3c72;margin-top:30px;">üìÅ Export & Sauvegarde</h3>
            <button class="btn btn-success" onclick="telechargerPage()">üíæ T√©l√©charger cette page HTML</button>
            <button class="btn btn-excel" onclick="exporterToutExcel()" style="margin-left:10px;">üìä Exporter TOUT vers Excel</button>
            <button class="btn btn-success" onclick="exportData()" style="margin-left:10px;">üì§ Exporter les donn√©es JSON</button>
            <button class="btn btn-primary" onclick="document.getElementById('importFileInput').click()" style="margin-left:10px;">üì• Importer des donn√©es JSON</button>
            <input type="file" id="importFileInput" accept=".json" style="display:none;" onchange="importData(event)">
            <button class="btn" style="background:#f44336;color:white;margin-left:10px;" onclick="clearData()">üóëÔ∏è Tout effacer</button>
            
            <div class="info-box" style="margin-top:20px;">
                <strong>üíæ Sauvegarde JSON :</strong><br>
                <strong>Export :</strong> T√©l√©charge un fichier JSON avec TOUTES vos donn√©es (r√©sultats + comp√©titions + fusions).<br>
                <strong>Import :</strong> Restaure vos donn√©es depuis un fichier JSON. ‚ö†Ô∏è Cela REMPLACE les donn√©es actuelles !
            </div>
            
            <div class="info-box" style="margin-top:20px;">
                <strong>üí° Export Excel :</strong><br>
                Cliquez sur "üìä Exporter TOUT vers Excel" pour g√©n√©rer un fichier Excel contenant TOUTES vos comp√©titions analys√©es avec :
                <ul style="margin-top:10px;margin-left:20px;">
                    <li>Un onglet "R√©sum√©" avec vue d'ensemble</li>
                    <li>Un onglet par comp√©tition avec r√©sultats d√©taill√©s</li>
                    <li>Codes couleur : üü¢ Vert = meilleur que le rang g√©n√©ral, üî¥ Rouge = moins bon</li>
                </ul>
            </div>
            
            <div class="info-box" style="margin-top:20px;">
                <strong>üí° T√©l√©charger la page :</strong><br>
                Cliquez sur "üíæ T√©l√©charger cette page HTML" pour sauvegarder l'application compl√®te sur votre iPad. 
                Vous pourrez ensuite l'ouvrir avec Safari m√™me sans connexion internet !
            </div>
        </div>
    </div>
    
    <div id="modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle"></h2>
                <button class="close-btn" onclick="fermerModal()">‚úï Fermer</button>
            </div>
            <div id="modalBody"></div>
        </div>
    </div>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        const cal = [
            {d:"05-oct",l:"Helsinki",p:"FIN",n:"Synchro Tour - stage 1",t:"National"},
            {d:"22-25 Oct",l:"Boondall",p:"AUS",n:"QFSC 2025",t:"National"},
            {d:"6-9 Nov",l:"Ste-Marie",p:"CAN",n:"Ch. Qu√©bec",t:"Regional"},
            {d:"7-9 Nov",l:"Berlin",p:"GER",n:"GoBer Berliner",t:"National"},
            {d:"7-9 Nov",l:"Irvine",p:"USA",n:"Fall Classic",t:"National"},
            {d:"8-9 Nov",l:"Tikkurila",p:"FIN",n:"Synchro Tour 1st",t:"National"},
            {d:"8-9 Nov",l:"Lyon",p:"FRA",n:"Masters Synchro",t:"National"},
            {d:"8-9 Nov",l:"Kungsbacka",p:"SWE",n:"Synkropokal",t:"National"},
            {d:"10-11 Nov",l:"Trento",p:"ITA",n:"Trento Cup",t:"National"},
            {d:"14-15 Nov",l:"London",p:"GBR",n:"Skate London",t:"National"},
            {d:"15-16 Nov",l:"Budapest",p:"HUN",n:"Test Comp",t:"National"},
            {d:"21-23 Nov",l:"Norwood",p:"USA",n:"Boston Classic",t:"National"},
            {d:"28-29 Nov",l:"Rouen",p:"FRA",n:"French Cup",t:"International"},
            {d:"28-5 Dec",l:"Boondall",p:"AUS",n:"Australian Ch.",t:"National"},
            {d:"5-7 Dec",l:"Dumfries",p:"GBR",n:"Trophy D'Ecosse",t:"National"},
            {d:"6 Dec",l:"Jihlava",p:"CZE",n:"Jihlavsky Jezek",t:"National"},
            {d:"6-7 Dec",l:"Boras",p:"SWE",n:"Knalletrofen",t:"National"},
            {d:"6-7 Dec",l:"Tampere",p:"FIN",n:"Synchro Tour 2nd",t:"National"},
            {d:"8 Dec",l:"Aosta",p:"ITA",n:"1¬∞ Gara Naz",t:"National"},
            {d:"8-13 Dec",l:"Oberstdorf",p:"GER",n:"German Ch.",t:"National"},
            {d:"11-14 Dec",l:"Jaca",p:"ESP",n:"Spain Ch.",t:"National"},
            {d:"11-14 Dec",l:"Innsbruck",p:"AUT",n:"Open Austrian",t:"National"},
            {d:"12-14 Dec",l:"Brno",p:"CZE",n:"Santa Claus Cup",t:"International"},
            {d:"12-14 Dec",l:"Woodstock",p:"CAN",n:"Synchro Series 1",t:"National"},
            {d:"20-21 Dec",l:"Gdansk",p:"POL",n:"Polish Ch.",t:"National"},
            {d:"8-9 Jan",l:"Gatineau",p:"CAN",n:"Canadian Ch.",t:"National"},
            {d:"9-10 Jan",l:"Nottingham",p:"GBR",n:"Britania Cup",t:"Challenger Series"},
            {d:"9-10 Jan",l:"Dresden",p:"GER",n:"Dresden Cup",t:"International"},
            {d:"10-11 Jan",l:"Ankara",p:"TUR",n:"Turkish Ch.",t:"National"},
            {d:"11-12 Jan",l:"Zagreb",p:"CRO",n:"Croatian Ch.",t:"National"},
            {d:"15-18 Jan",l:"Ankara",p:"TUR",n:"Anatolian Cup",t:"International"},
            {d:"15-17 Jan",l:"Gdansk",p:"POL",n:"Hevelius Cup",t:"International"},
            {d:"16-18 Jan",l:"Sesto SG",p:"ITA",n:"Sprint Cup",t:"International"},
            {d:"22-24 Jan",l:"Eindhoven",p:"NED",n:"Lumi√®re Cup",t:"Challenger Series"},
            {d:"23-24 Jan",l:"Salzburg",p:"AUT",n:"Mozartcup",t:"International"},
            {d:"29-30 Jan",l:"Madrid",p:"ESP",n:"Absoluto Open",t:"National"},
            {d:"30-31 Jan",l:"Norwood",p:"USA",n:"US Intl Classic",t:"Challenger Series"},
            {d:"31-1 Feb",l:"Huttwil",p:"SUI",n:"SYS Trophy",t:"International"},
            {d:"31-1 Feb",l:"Gothenburg",p:"SWE",n:"Leon Lurje",t:"International"},
            {d:"1 Feb",l:"Pinerolo",p:"ITA",n:"2¬∞ Gara Naz",t:"National"},
            {d:"7-8 Feb",l:"Turku",p:"FIN",n:"Marie Lundmark",t:"Challenger Series"},
            {d:"7-8 Feb",l:"Budapest",p:"HUN",n:"UTE Cup",t:"International"},
            {d:"12-15 Feb",l:"Riga",p:"LAT",n:"Amber Cup",t:"International"},
            {d:"14-15 Feb",l:"Trento",p:"ITA",n:"Italian Ch.",t:"National"},
            {d:"16 Feb",l:"Helsinki",p:"FIN",n:"Synchro Tour 4",t:"National"},
            {d:"19 Feb",l:"Nottingham",p:"GBR",n:"British Ch.",t:"National"},
            {d:"21-22 Feb",l:"Aby",p:"SWE",n:"Swedish Ch.",t:"National"},
            {d:"28-1 Mar",l:"Koprivnice",p:"CZE",n:"Czech Ch.",t:"National"},
            {d:"28-1 Mar",l:"Budapest",p:"HUN",n:"Budapest Cup",t:"International"},
            {d:"28-1 Mar",l:"Widnau",p:"SUI",n:"SwissCup",t:"International"},
            {d:"28-1 Mar",l:"Turku",p:"FIN",n:"Finnish Ch.",t:"National"},
            {d:"4-7 Mar",l:"Salt Lake",p:"USA",n:"US Ch.",t:"National"},
            {d:"6-7 Mar",l:"Neuchatel",p:"SUI",n:"Neuchatel",t:"International"},
            {d:"7 Mar",l:"Kungalv",p:"SWE",n:"Kungalvspokalen",t:"National"},
            {d:"7-9 Mar",l:"Sheffield",p:"GBR",n:"Steel City",t:"International"},
            {d:"13-14 Mar",l:"Gdansk",p:"POL",n:"ISU WJSYSC",t:"Ch. du Monde J"},
            {d:"21 Mar",l:"Basel",p:"SUI",n:"Basilea",t:"International"},
            {d:"28-29 Mar",l:"Sesto SG",p:"ITA",n:"Easter Trophy",t:"International"},
            {d:"10-11 Apr",l:"Salzburg",p:"AUT",n:"ISU WSYSC",t:"Ch. du Monde"}
        ];

        let liste = [];
        let resultats = [];
        let fusionsEquipes = []; // Pour stocker les fusions manuelles d'√©quipes
        
        const DB_COMPS = 'synchro_v2_comps';
        const DB_RES = 'synchro_v2_resultats';
        
        // BASE DE DONN√âES DES √âQUIPES INTERNATIONALES
        // G√©n√©r√©e automatiquement √† partir de la liste officielle
        const equipesInternationales = {
            // Senior
            "Unique": "FIN",
            "Les Supr√™mes": "CAN",
            "Helsinki Rockettes": "FIN",
            "Nova": "CAN",
            "Haydenettes": "USA",
            "Lumineers": "FIN",
            "Ice On Fire": "ITA",
            "Marigold IceUnity": "FIN",
            "Marigold Ice Unity": "FIN", // Variante avec espace
            "Inspire": "SWE",
            "Nexxice": "CAN",
            "Miami University": "USA",
            "Berlin 1": "GER",
            "Skyliners": "USA",
            "Teams Elite": "USA",
            "Hot Shivers": "ITA",
            "Ice Fire": "POL",
            "Icicles": "GBR",
            "Skating Graces": "GER",
            "United Angels": "GER",
            "Passion": "HUN",
            "Olympia": "CZE",
            "Starlight Elite": "SUI",
            "Ice United": "NED",
            "Unity": "AUS",
            "Cool Dreams": "SUI",
            "Zoulous": "FRA",
            "Ice Storm": "AUS",
            "Trine University": "USA",
            "Hayden Select": "USA",
            "Jeanne d'Arc Elite 12": "FRA",
            "Fusion Elite 12": "ESP",
            "Colibri Vienna": "AUT",
            "Bosphorus": "TUR",
            "Halley Elite 12": "ESP",
            "Celestia": "TUR",
            
            // Junior (sans le suffixe Junior)
            "Helsinki Fintastic": "FIN",
            "Dream Edges": "FIN",
            "Musketeers": "FIN",
            "Valley Bay Synchro": "FIN",
            "Spirit": "SWE",
            "Lexettes": "USA",
            "Mystique": "FIN",
            "Image": "USA",
            "Northernettes": "USA",
            "Seaside": "SWE",
            "Reflections": "FIN",
            "Berlin": "GER", // Team Berlin Juniors
            "Fond Du Lac Blades": "USA",
            "Dc Edge": "USA",
            "Moonlights": "SWE",
            "Ice Ignite": "CAN",
            "Crystallettes": "USA",
            "Prima": "CAN",
            "Festa Aboensia": "FIN",
            "Hockettes": "USA",
            "Gold Ice": "CAN",
            "FireBlades": "FIN",
            "Sun City Swing": "FIN",
            "Stella Polaris": "FIN",
            "Kometa": "CZE",
            "Starlight": "SUI",
            "Ladybirds": "ITA",
            "Ice Steps": "FIN",
            "Jeanne d'Arc": "FRA",
            "Le Soleil": "POL",
            "Harmonia": "CZE",
            "Ice Infinity": "FIN",
            "Ice Fusion": "FIN",
            "Eternity": "SWE",
            "Berlin": "GER",
            "Lower Mainland": "CAN",
            "Estreija": "FIN",
            "UTE Synchro": "HUN",
            "Southern Sky": "AUS",
            "Iceskateers Elite": "AUS",
            "Mirum": "ESP",
            "Ice Diamonds": "FIN",
            "Majestic Ice": "AUS",
            "Elite": "TUR",
            "Solent Storm": "GBR",
            "Odyss√©e": "FRA",
            "Halo": "SWE",
            "Ice Dancing Flames": "POL",
            "Ph≈ìnix": "AUS",
            "Phoenix": "AUS", // Variante sans ≈ì
            "Infusion": "AUS",
            "Munich Destiny": "GER",
            "Vizyon": "TUR",
            "Ice Sparkles": "ITA",
            "Diamonds": "EST",
            "Illuminettes": "NED",
            "Golden Roses": "TUR",
            "Eclipse": "AUS",
            "Sweet Mozart": "AUT",
            "Pingvin": "HUN"
        };
        
        // Mapping des codes clubs nationaux vers codes pays (3 lettres)
        const clubVersPays = {
            // Finlande
            'Kaari': 'FIN', 'HL': 'FIN', 'EsJt': 'FIN', 'HSK': 'FIN', 'ETK': 'FIN', 'TRT': 'FIN', 
            'HTK': 'FIN', 'VG-62': 'FIN', 'EVT': 'FIN', 'TapTL': 'FIN', 'TTK': 'FIN', 'OLK': 'FIN',
            'KuLS': 'FIN', 'LTL': 'FIN', 'JyTLS': 'FIN', 'VSJT': 'FIN', 'TuTS': 'FIN', 'PSS': 'FIN',
            'MJT': 'FIN', 'HSJT': 'FIN', 'PoJT': 'FIN', 'SSL': 'FIN', 'JoJT': 'FIN', 'KTL': 'FIN',
            'MLT': 'FIN', 'EsTL': 'FIN', 'PoriTa': 'FIN', 'Ii': 'FIN', 'RiL': 'FIN',
            'ESS': 'FIN', 'EsS': 'FIN', // Espoo Skating School
            'VG': 'FIN', 'VG62': 'FIN', // Vantaa
            'Tap': 'FIN', 'TapT': 'FIN', 'TapL': 'FIN', // Tampere
            'JTLS': 'FIN', 'JyT': 'FIN', // Jyv√§skyl√§
            'KuL': 'FIN', 'Ku': 'FIN', // Kuopio
            
            // Su√®de
            'SKK': 'SWE', 'Gra': 'SWE', 'Mal': 'SWE', 'G√∂t': 'SWE', 'Lyn': 'SWE',
            'Sto': 'SWE', 'V√§s': 'SWE', 'Lin': 'SWE', 'Upp': 'SWE',
            
            // Allemagne
            'BER': 'GER', 'MUC': 'GER', 'HAM': 'GER', 'DOR': 'GER', 'DRE': 'GER',
            
            // Italie
            'MIL': 'ITA', 'ROM': 'ITA', 'TOR': 'ITA', 'BOL': 'ITA', 'FIR': 'ITA',
            
            // Royaume-Uni
            'LON': 'GBR', 'SOL': 'GBR', 'MAN': 'GBR', 'EDI': 'GBR',
            
            // Codes pays standards (d√©j√† √† 3 lettres)
            'FIN': 'FIN', 'SWE': 'SWE', 'GER': 'GER', 'ITA': 'ITA', 'GBR': 'GBR',
            'FRA': 'FRA', 'ESP': 'ESP', 'SUI': 'SUI', 'AUT': 'AUT', 'NED': 'NED', 
            'POL': 'POL', 'CZE': 'CZE', 'HUN': 'HUN', 'TUR': 'TUR', 'EST': 'EST',
            'USA': 'USA', 'CAN': 'CAN', 'AUS': 'AUS', 'NZL': 'NZL',
            'JPN': 'JPN', 'CHN': 'CHN', 'KOR': 'KOR'
        };
        
        // MAPPING EXHAUSTIF DE TOUS LES √âL√âMENTS - Plus fiable que les regex !
        // Chaque code d'√©l√©ment ‚Üí sa cat√©gorie
        const elementMapping = {
            // AX - √âl√©ments artistiques
            "ABB": "AX", "AB1": "AX", "AB2": "AX",
            "ACB": "AX", "AC1": "AX", "AC2": "AX",
            "ALB": "AX", "AL1": "AX", "AL2": "AX",
            "AWB": "AX", "AW1": "AX", "AW2": "AX",
            
            // CrI - Creative Intersection
            "CrIB": "CrI", "CrI1": "CrI",
            
            // CrL - Creative Line
            "CrLB": "CrL", "CrL1": "CrL",
            
            // GL - Group Lift
            "GLB": "GL", "GL1": "GL", "GL2": "GL", "GL3": "GL", "GL4": "GL",
            
            // I+pi - Intersection (25 combinaisons possibles : 5 niveaux I √ó 5 niveaux pi)
            "IB+piB": "I+pi", "IB+pi1": "I+pi", "IB+pi2": "I+pi", "IB+pi3": "I+pi", "IB+pi4": "I+pi",
            "I1+piB": "I+pi", "I1+pi1": "I+pi", "I1+pi2": "I+pi", "I1+pi3": "I+pi", "I1+pi4": "I+pi",
            "I2+piB": "I+pi", "I2+pi1": "I+pi", "I2+pi2": "I+pi", "I2+pi3": "I+pi", "I2+pi4": "I+pi",
            "I3+piB": "I+pi", "I3+pi1": "I+pi", "I3+pi2": "I+pi", "I3+pi3": "I+pi", "I3+pi4": "I+pi",
            "I4+piB": "I+pi", "I4+pi1": "I+pi", "I4+pi2": "I+pi", "I4+pi3": "I+pi", "I4+pi4": "I+pi",
            
            // ME - Move Element
            "MEB": "ME", "ME1": "ME", "ME2": "ME", "ME3": "ME", "ME4": "ME",
            
            // PB - Pivot Block
            "PBB": "PB", "PB1": "PB", "PB2": "PB", "PB3": "PB", "PB4": "PB",
            
            // Pa - Pair Element
            "PaB": "Pa", "Pa1": "Pa", "Pa2": "Pa", "Pa3": "Pa", "Pa4": "Pa",
            
            // SySp - Synchronized Spin
            "SySpB": "SySp", "SySp1": "SySp", "SySp2": "SySp", "SySp3": "SySp", "SySp4": "SySp",
            
            // TrE - Transitions Element
            "TrEB": "TrE", "TrE1": "TrE", "TrE2": "TrE", "TrE3": "TrE", "TrE4": "TrE",
            
            // TwE - Twizzle Element
            "TwEB": "TwE", "TwE1": "TwE", "TwE2": "TwE", "TwE3": "TwE", "TwE4": "TwE",
            
            // NHE+sB - No Hold Element (step toujours Base, niveau varie sur NHE)
            // Programme court juniors + programme long seniors
            "NHEB+sB": "NHE+sB", "NHE1+sB": "NHE+sB", "NHE2+sB": "NHE+sB", "NHE3+sB": "NHE+sB", "NHE4+sB": "NHE+sB",
            
            // NHEB+s - No Hold Element (NHE toujours Base, niveau varie sur step)
            // Programme long juniors + programme court seniors
            "NHEB+s1": "NHEB+s", "NHEB+s2": "NHEB+s", "NHEB+s3": "NHEB+s", "NHEB+s4": "NHEB+s"
            // Note : NHEB+sB peut √™tre soit NHE+sB soit NHEB+s selon le programme
        };
        
        // Option de standardisation (peut √™tre activ√©e/d√©sactiv√©e dans les param√®tres)
        let standardiserNoms = localStorage.getItem('synchro_standardiser') === 'true' || false;
        
        /**
         * Extraire le niveau d'un √©l√©ment √† partir de son code
         * IMPORTANT : Pour les intersections, retourne "x+y" (les 2 niveaux)
         * Cette fonction permet d'afficher correctement les niveaux m√™me pour les donn√©es anciennes
         * @param {string} code - Code complet de l'√©l√©ment (ex: "I4+pi3", "SySp2", "NHEB+s3")
         * @param {string} type - Type de l'√©l√©ment (ex: "I+pi", "SySp", "NHE+sB")
         * @returns {string} - Le niveau format√© (ex: "4+3" pour intersection, "2" pour SySp)
         */
        function getNiveauFromCode(code, type) {
            // Pour les intersections : afficher les 2 niveaux "x+y"
            if (type && type.includes('I+pi')) {
                const levelMatchI = code.match(/I([B\d])\+pi/);
                const levelMatchPi = code.match(/\+pi([B\d])/);
                
                let levelI = '1';
                let levelPi = '1';
                
                if (levelMatchI) {
                    levelI = levelMatchI[1] === 'B' ? 'Base' : levelMatchI[1];
                }
                if (levelMatchPi) {
                    levelPi = levelMatchPi[1] === 'B' ? 'Base' : levelMatchPi[1];
                }
                
                return levelI + '+' + levelPi;
            }
            
            // Pour NHE+s : logique sp√©ciale
            if (code.match(/NHE[B\d]?\+s[B\d]?/)) {
                const typeBase = elementMapping[code];
                
                if (typeBase === 'NHE+sB') {
                    const levelMatch = code.match(/NHE([B\d])\+s/);
                    if (levelMatch) {
                        return levelMatch[1] === 'B' ? 'Base' : levelMatch[1];
                    }
                } else if (typeBase === 'NHEB+s') {
                    const levelMatch = code.match(/\+s([B\d])/);
                    if (levelMatch) {
                        return levelMatch[1] === 'B' ? 'Base' : levelMatch[1];
                    }
                    return 'Base';
                }
            }
            
            // Pour les √©l√©ments simples : dernier caract√®re
            const levelMatch = code.match(/([B\d])$/);
            if (levelMatch) {
                return levelMatch[1] === 'B' ? 'Base' : levelMatch[1];
            }
            
            return '1'; // Fallback
        }
        
        /**
         * NOUVELLE APPROCHE INTELLIGENTE : Extraire le nom d'√©quipe en se basant sur la base de donn√©es
         * Au lieu de deviner o√π couper le nom, on cherche dans la base si un nom d'√©quipe connu est pr√©sent
         * @param {string} nomBrut - Nom complet tel qu'extrait du PDF (ex: "Icicles Junior National Ice Centre, Nottingham")
         * @returns {object|null} - {nom: string, pays: string} ou null si non trouv√©
         */
        function extraireNomEquipeIntelligent(nomBrut) {
            // Nettoyer le nom de base (enlever parenth√®ses, etc.)
            let nomNettoye = nomBrut
                .replace(/\s*\([^)]*\)\s*/g, '')  // Enlever parenth√®ses
                .replace(/^Team\s+/i, '')          // Enlever "Team" au d√©but
                .trim();
            
            // Chercher TOUS les noms d'√©quipes qui matchent (m√™me partiellement)
            const matches = [];
            
            for (const [equipe, pays] of Object.entries(equipesInternationales)) {
                // Cr√©er des variantes du nom d'√©quipe pour matcher
                const variantes = [
                    equipe,
                    equipe.toLowerCase(),
                    equipe + ' Junior',
                    equipe + ' Senior',
                    equipe + ' Juniors',
                ];
                
                const nomLower = nomNettoye.toLowerCase();
                
                for (const variante of variantes) {
                    // Chercher si le nom d'√©quipe est pr√©sent dans le texte (mot complet)
                    const regex = new RegExp('\\b' + variante.toLowerCase().replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\b', 'i');
                    if (regex.test(nomNettoye)) {
                        matches.push({
                            nom: equipe,
                            pays: pays,
                            longueur: equipe.length
                        });
                        break; // Passer √† l'√©quipe suivante
                    }
                }
            }
            
            // Si on a trouv√© des matches, prendre le plus long (pour √©viter "Ice" vs "Ice Storm")
            if (matches.length > 0) {
                matches.sort((a, b) => b.longueur - a.longueur);
                const meilleurMatch = matches[0];
                window.debugLog(`üéØ Match trouv√© dans base: "${meilleurMatch.nom}" (${meilleurMatch.pays})`);
                return {
                    nom: meilleurMatch.nom,
                    pays: meilleurMatch.pays
                };
            }
            
            return null;
        }
        
        /**
         * Trouve le pays d'une √©quipe en cherchant dans la base de donn√©es
         * @param {string} nomEquipe - Nom de l'√©quipe (peut contenir "Team", espaces, etc.)
         * @returns {string|null} - Code pays 3 lettres ou null si non trouv√©
         */
        function trouverPaysEquipe(nomEquipe) {
            const resultat = extraireNomEquipeIntelligent(nomEquipe);
            return resultat ? resultat.pays : null;
        }
        
        /**
         * Standardise un nom d'√©quipe au format international ISU
         * Format Senior: "Team [Nom]" avec nation dans champ s√©par√©
         * Format Junior: "Team [Nom] Junior" avec nation dans champ s√©par√©
         * @param {string} nomBrut - Nom de l'√©quipe tel qu'extrait du PDF
         * @param {string} codeBrut - Code club/nation tel qu'extrait du PDF
         * @param {string} categorie - "Senior" ou "Junior"
         * @returns {object} - {nom: string, nation: string} - Nom standardis√© ET code pays
         */
        function standardiserNomEquipe(nomBrut, codeBrut, categorie) {
            // √âTAPE 0 : NOUVELLE APPROCHE INTELLIGENTE - Chercher dans la base de donn√©es FIRST
            // Ceci r√©sout tous les probl√®mes de parsing (australien, su√©dois, britannique, italien, etc.)
            const matchIntelligent = extraireNomEquipeIntelligent(nomBrut);
            
            if (matchIntelligent) {
                // On a trouv√© l'√©quipe dans la base ! Utiliser ce nom propre
                window.debugLog(`‚úÖ Match intelligent: "${matchIntelligent.nom}" ‚Üí ${matchIntelligent.pays}`);
                
                if (!standardiserNoms) {
                    // Mode d√©sactiv√© : garder le nom trouv√© mais ne pas standardiser
                    return {
                        nom: matchIntelligent.nom,
                        nation: matchIntelligent.pays
                    };
                }
                
                // Mode activ√© : construire le nom standardis√©
                let nomStandard = 'Team ' + matchIntelligent.nom;
                
                // Ajouter "Junior" si c'est une √©quipe junior
                if (categorie && categorie.toLowerCase().includes('junior')) {
                    nomStandard += ' Junior';
                }
                
                return {
                    nom: nomStandard,
                    nation: matchIntelligent.pays
                };
            }
            
            // FALLBACK : Si pas trouv√© dans la base, utiliser l'ancienne m√©thode
            window.debugLog(`‚ö†Ô∏è Pas de match intelligent, fallback sur parsing manuel`);
            
            // √âTAPE 1 : D√©terminer le code pays (ancienne m√©thode)
            let codePays = clubVersPays[codeBrut] || codeBrut;
            
            // Si le code n'est pas reconnu, essayer de le nettoyer
            if (codePays && (codePays.length !== 3 || codePays !== codePays.toUpperCase())) {
                codePays = codePays.toUpperCase().substring(0, 3);
            }
            
            if (!standardiserNoms) {
                // Mode d√©sactiv√© : garder le nom brut mais quand m√™me convertir la nation
                return {
                    nom: nomBrut,
                    nation: codePays || codeBrut
                };
            }
            
            // √âTAPE 2 : Standardiser le nom
            let nom = nomBrut.trim();
            
            // NETTOYAGE UNIVERSEL : Enlever tout ce qui est entre parenth√®ses
            // Ex: "Hot Shivers (Junior ISU synchronized)" ‚Üí "Hot Shivers"
            nom = nom.replace(/\s*\([^)]*\)\s*/g, '').trim();
            
            // NETTOYAGE : Enlever "Team" au d√©but s'il existe d√©j√†
            nom = nom.replace(/^Team\s+/i, '');
            
            // NETTOYAGE : Enlever "Junior" / "Juniors" √† la fin s'il existe d√©j√†
            nom = nom.replace(/\s+Juniors?$/i, '');
            
            // Construire le nom standardis√© (SANS le code pays √† la fin)
            let nomStandard = 'Team ' + nom;
            
            // Ajouter "Junior" si c'est une √©quipe junior
            if (categorie && categorie.toLowerCase().includes('junior')) {
                nomStandard += ' Junior';
            }
            
            // Retourner nom ET nation s√©par√©ment
            return {
                nom: nomStandard,
                nation: codePays || codeBrut
            };
        }

        window.onload = function() {
            chargerDonnees();
        };

        function afficherDebug() {
            const debugDiv = document.getElementById('debugInfo');
            const isVisible = debugDiv.style.display !== 'none';
            
            if (isVisible) {
                debugDiv.style.display = 'none';
                return;
            }
            
            let html = '<strong>üîç √âTAT DU SYST√àME</strong><br><br>';
            html += '<strong>Comp√©titions en m√©moire:</strong> ' + liste.length + '<br>';
            html += '<strong>R√©sultats en m√©moire:</strong> ' + resultats.length + '<br><br>';
            
            html += '<strong>localStorage:</strong><br>';
            html += '- ' + DB_COMPS + ': ' + (localStorage.getItem(DB_COMPS) ? 'OUI' : 'NON') + '<br>';
            html += '- ' + DB_RES + ': ' + (localStorage.getItem(DB_RES) ? 'OUI' : 'NON') + '<br><br>';
            
            if (resultats.length > 0) {
                html += '<strong>D√âTAIL DES R√âSULTATS:</strong><br>';
                resultats.forEach((r, i) => {
                    const comp = liste.find(c => String(c.id) === String(r.compId));
                    html += `[${i}] compId="${r.compId}" (type: ${typeof r.compId})<br>`;
                    html += `    cat="${r.cat}" prog="${r.prog}"<br>`;
                    html += `    comp trouv√©e: ${comp ? comp.n : 'NON'}<br>`;
                    html += `    √©quipes: ${r.data?.equipes?.length || 0}<br><br>`;
                });
            }
            
            debugDiv.innerHTML = html;
            debugDiv.style.display = 'block';
        }

        function chargerDonnees() {
            try {
                const compsStr = localStorage.getItem(DB_COMPS);
                if (compsStr) {
                    liste = JSON.parse(compsStr);
                    console.log('‚úÖ Comp√©titions charg√©es:', liste.length);
                }
            } catch (e) {
                console.error('Erreur chargement comps:', e);
            }
            
            try {
                const resStr = localStorage.getItem(DB_RES);
                if (resStr) {
                    resultats = JSON.parse(resStr);
                    console.log('‚úÖ R√©sultats charg√©s:', resultats.length);
                    
                    // NETTOYAGE : Supprimer les r√©sultats orphelins (sans comp√©tition associ√©e)
                    const avant = resultats.length;
                    resultats = resultats.filter(r => {
                        const compExiste = liste.some(c => String(c.id) === String(r.compId));
                        if (!compExiste) {
                            console.warn('‚ö†Ô∏è R√©sultat orphelin supprim√©:', r.compId);
                        }
                        return compExiste;
                    });
                    
                    if (resultats.length < avant) {
                        console.log(`üßπ ${avant - resultats.length} r√©sultat(s) orphelin(s) supprim√©(s)`);
                        sauvegarderResultats();
                    }
                }
            } catch (e) {
                console.error('Erreur chargement r√©sultats:', e);
            }
            
            // Charger les √©quipes personnalis√©es
            try {
                const equipesCustomStr = localStorage.getItem('synchro_equipes_custom');
                if (equipesCustomStr) {
                    const equipesCustom = JSON.parse(equipesCustomStr);
                    Object.assign(equipesInternationales, equipesCustom);
                    console.log('‚úÖ √âquipes personnalis√©es charg√©es:', Object.keys(equipesCustom).length);
                }
            } catch (e) {
                console.error('Erreur chargement √©quipes personnalis√©es:', e);
            }
            
            // Charger les fusions d'√©quipes
            try {
                const fusionsStr = localStorage.getItem('synchro_fusions_2025');
                if (fusionsStr) {
                    fusionsEquipes = JSON.parse(fusionsStr);
                    console.log('‚úÖ Fusions d\'√©quipes charg√©es:', fusionsEquipes.length);
                }
            } catch (e) {
                console.error('Erreur chargement fusions:', e);
            }
            
            afficher();
        }

        function sauvegarderComps() {
            try {
                localStorage.setItem(DB_COMPS, JSON.stringify(liste));
                console.log('‚úÖ Comp√©titions sauvegard√©es:', liste.length);
            } catch (e) {
                console.error('‚ùå Erreur sauvegarde comps:', e);
                alert('Erreur de sauvegarde des comp√©titions');
            }
        }

        function sauvegarderResultats() {
            try {
                localStorage.setItem(DB_RES, JSON.stringify(resultats));
                console.log('‚úÖ R√©sultats sauvegard√©s:', resultats.length);
                return true;
            } catch (e) {
                console.error('‚ùå Erreur sauvegarde r√©sultats:', e);
                alert('Erreur de sauvegarde des r√©sultats');
                return false;
            }
        }
        
        function supprimerResultat(resId) {
            if (!confirm('√ätes-vous s√ªr de vouloir supprimer ce r√©sultat ?')) {
                return;
            }
            
            const idx = resultats.findIndex(r => r.id === resId);
            if (idx === -1) {
                alert('R√©sultat introuvable');
                return;
            }
            
            const res = resultats[idx];
            
            // Supprimer du tableau
            resultats.splice(idx, 1);
            
            // Sauvegarder
            if (sauvegarderResultats()) {
                alert(`‚úÖ R√©sultat supprim√© : ${res.cat} ${res.prog}`);
                
                // Recharger la page d'upload pour mettre √† jour l'affichage
                ouvrirCompUpload(res.compId);
            }
        }

        function chargerCalendrier() {
            let nb = 0;
            cal.forEach(c => {
                if (!liste.some(x => x.n === c.n)) {
                    liste.push({
                        id: String(Date.now() + Math.random()),
                        d: c.d,
                        l: c.l,
                        p: c.p,
                        n: c.n,
                        t: c.t
                    });
                    nb++;
                }
            });
            sauvegarderComps();
            afficher();
            alert('‚úÖ ' + nb + ' comp√©titions ajout√©es !');
        }

        function afficher() {
            const recherche = (document.getElementById('search')?.value || '').toLowerCase();
            const paysFilt = document.getElementById('pays')?.value || '';
            
            const filtrees = liste.filter(c => {
                const ok1 = c.n.toLowerCase().includes(recherche) || c.l.toLowerCase().includes(recherche);
                const ok2 = !paysFilt || c.p === paysFilt;
                return ok1 && ok2;
            });
            
            document.getElementById('total').textContent = liste.length;
            document.getElementById('totalPays').textContent = new Set(liste.map(c => c.p)).size;
            document.getElementById('totalResultats').textContent = resultats.length;
            
            const grid = document.getElementById('grid');
            grid.innerHTML = '';
            
            filtrees.forEach(c => {
                const aRes = resultats.some(r => String(r.compId) === String(c.id));
                
                // Couleurs par type de comp√©tition (noms EXACTS)
                const typeCouleur = {
                    'Regional': '#9c27b0',           // Violet
                    'National': '#2196F3',           // Bleu
                    'International': '#4CAF50',      // Vert
                    'Challenger Series': '#FF9800',  // Orange
                    'Ch. du Monde': '#f44336',       // Rouge
                    'Ch. du Monde J': '#f44336'      // Rouge (Junior)
                };
                const badgeColor = typeCouleur[c.t] || '#2196F3'; // D√©faut bleu
                
                console.log(`üé® Comp√©tition "${c.n}" - Type: "${c.t}" - Couleur: ${badgeColor}`);
                
                grid.innerHTML += `
                    <div class="competition-card" onclick="ouvrirComp('${c.id}')" style="border-left: 5px solid ${badgeColor} !important;">
                        <div class="competition-name">${c.n}</div>
                        <div style="color:#666;">üìÖ ${c.d}</div>
                        <div style="color:#666;">üìç ${c.l}, ${c.p}</div>
                        <div style="margin-top:10px;">
                            <span style="background:${badgeColor};color:white;padding:4px 10px;border-radius:12px;font-size:0.85em;">${c.t}</span>
                            ${aRes ? '<span style="margin-left:5px;background:#4CAF50;color:white;padding:4px 10px;border-radius:12px;font-size:0.85em;">‚úì R√©sultats</span>' : ''}
                        </div>
                    </div>
                `;
            });
            
            remplirPays();
        }

        function remplirPays() {
            const select = document.getElementById('pays');
            if (!select || select.options.length > 1) return;
            
            const pays = [...new Set(liste.map(c => c.p))].sort();
            pays.forEach(p => {
                const opt = document.createElement('option');
                opt.value = p;
                opt.textContent = p;
                select.appendChild(opt);
            });
        }

        let currentCompId = null;

        function ouvrirComp(id) {
            currentCompId = String(id);
            chargerDonnees();
            
            const comp = liste.find(c => String(c.id) === String(id));
            if (!comp) {
                console.error('‚ùå Comp√©tition introuvable:', id);
                return;
            }
            
            console.log('üìÇ Ouverture comp√©tition:', comp.n);
            
            // V√©rifier s'il y a des r√©sultats pour cette comp√©tition
            const resultatsComp = resultats.filter(r => String(r.compId) === String(id));
            
            if (resultatsComp.length > 0) {
                // Il y a des r√©sultats ‚Üí afficher la vue sommaire directement
                // Prendre le premier r√©sultat (peu importe lequel, afficherVueSommaire va chercher tous les r√©sultats de la comp)
                afficherVueSommaire(resultatsComp[0].id);
                return;
            }
            
            // Pas de r√©sultats ‚Üí afficher la page d'upload
            ouvrirCompUpload(id);
        }
        
        function ouvrirCompUpload(id) {
            currentCompId = String(id);
            chargerDonnees();
            
            const comp = liste.find(c => String(c.id) === String(id));
            if (!comp) {
                console.error('‚ùå Comp√©tition introuvable:', id);
                return;
            }
            
            document.getElementById('modalTitle').textContent = comp.n;
            
            let html = `
                <div style="background:#f8f9ff;padding:15px;border-radius:8px;margin-bottom:20px;">
                    <p><strong>üìÖ</strong> ${comp.d}</p>
                    <p><strong>üìç</strong> ${comp.l}, ${comp.p}</p>
                </div>
                <h3 style="color:#1e3c72;margin:20px 0;">üìÑ Upload Protocoles</h3>
            `;
            
            ['Senior', 'Junior'].forEach(cat => {
                html += `<div class="cat-section"><div class="cat-title">${cat}</div>`;
                
                ['PC', 'PL'].forEach(prog => {
                    const key = `${comp.id}_${cat}_${prog}`;
                    const res = resultats.find(r => 
                        String(r.compId) === String(comp.id) && 
                        r.cat === cat && 
                        r.prog === prog
                    );
                    
                    html += `<div class="prog-section">
                        <div class="prog-title">${prog === 'PC' ? 'üìã Programme Court' : 'üìã Programme Long'}</div>
                        <input type="file" id="file_${key}" accept=".pdf" style="padding:8px;width:100%;margin-bottom:10px;border:2px solid #e0e0e0;border-radius:5px;">
                        <button class="btn btn-primary btn-small" onclick="uploadPDF('${comp.id}','${cat}','${prog}')">üì§ Analyser</button>
                        <div id="status_${key}">
                            ${res ? `<div class="success-box">‚úÖ Analys√© le ${new Date(res.date).toLocaleDateString()} - ${res.data.equipes.length} √©quipes</div>
                            <button class="btn btn-primary btn-small" onclick="afficherVueSommaire('${res.id}')" style="margin-right:5px;">üëÅÔ∏è Voir r√©sultats</button>
                            <button class="btn btn-excel btn-small" onclick="exporterUnResultat('${res.id}')" style="margin-right:5px;">üìä Excel</button>
                            <button class="btn btn-small" style="background:#f44336;color:white;" onclick="supprimerResultat('${res.id}')">üóëÔ∏è Supprimer</button>` : ''}
                        </div>
                    </div>`;
                });
                
                html += '</div>';
            });
            
            document.getElementById('modalBody').innerHTML = html;
            document.getElementById('modal').classList.add('active');
        }

        function fermerModal() {
            document.getElementById('modal').classList.remove('active');
        }

        async function uploadPDF(compId, cat, prog) {
            compId = String(compId);
            
            const key = `${compId}_${cat}_${prog}`;
            const input = document.getElementById('file_' + key);
            const file = input.files[0];
            
            if (!file) {
                alert('S√©lectionnez un PDF');
                return;
            }
            
            const statusDiv = document.getElementById('status_' + key);
            statusDiv.innerHTML = '<div style="padding:10px;background:#fff3e0;border-radius:5px;margin-top:10px;">‚è≥ Analyse...</div>';
            
            // Zone de debug visible
            let debugLogs = [];
            window.debugLog = function(msg) {
                debugLogs.push(msg);
                console.log(msg);
            };
            
            try {
                debugLog('üìÑ D√©but analyse PDF: ' + file.name);
                
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
                
                debugLog(`üìñ PDF charg√©: ${pdf.numPages} pages`);
                
                let texte = '';
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const textContent = await page.getTextContent();
                    texte += textContent.items.map(item => item.str).join(' ') + '\n';
                }
                
                debugLog('üìù Texte extrait: ' + texte.length + ' caract√®res');
                debugLog('üîç Premiers 500 caract√®res: ' + texte.substring(0, 500));
                
                const proto = analyserTexte(texte, cat);
                
                debugLog('üéØ Protocole analys√©: ' + proto.equipes.length + ' √©quipes');
                
                if (proto && proto.equipes && proto.equipes.length > 0) {
                    const res = {
                        id: String(Date.now() + '_' + Math.random()),
                        compId: compId,
                        cat: cat,
                        prog: prog,
                        date: new Date().toISOString(),
                        data: proto
                    };
                    
                    const idx = resultats.findIndex(r => 
                        String(r.compId) === String(compId) && 
                        r.cat === cat && 
                        r.prog === prog
                    );
                    
                    if (idx > -1) {
                        resultats[idx] = res;
                    } else {
                        resultats.push(res);
                    }
                    
                    const ok = sauvegarderResultats();
                    
                    if (ok) {
                        statusDiv.innerHTML = `<div class="success-box">‚úÖ ${proto.equipes.length} √©quipes - SAUVEGARDE OK !</div>
                        <button class="btn btn-primary btn-small" onclick="afficherVueSommaire('${res.id}')" style="margin-right:5px;">üëÅÔ∏è Voir r√©sultats</button>
                        <button class="btn btn-excel btn-small" onclick="exporterUnResultat('${res.id}')">üìä Excel</button>`;
                        
                        afficher();
                    }
                } else {
                    // AFFICHER LES LOGS DANS LA PAGE
                    let debugHTML = '<div style="padding:15px;background:#ffebee;border-radius:5px;margin-top:10px;max-height:400px;overflow-y:auto;">';
                    debugHTML += '<h4 style="color:#c62828;margin-bottom:10px;">‚ùå Extraction impossible - Rapport de d√©bogage :</h4>';
                    debugHTML += '<div style="font-family:monospace;font-size:0.85em;white-space:pre-wrap;">';
                    debugLogs.forEach(log => {
                        debugHTML += log + '\n';
                    });
                    debugHTML += '</div></div>';
                    
                    statusDiv.innerHTML = debugHTML;
                }
            } catch (error) {
                debugLog('‚ùå ERREUR: ' + error.message);
                debugLog('Stack: ' + error.stack);
                
                let debugHTML = '<div style="padding:15px;background:#ffebee;border-radius:5px;margin-top:10px;max-height:400px;overflow-y:auto;">';
                debugHTML += '<h4 style="color:#c62828;margin-bottom:10px;">‚ùå Erreur - Rapport de d√©bogage :</h4>';
                debugHTML += '<div style="font-family:monospace;font-size:0.85em;white-space:pre-wrap;">';
                debugLogs.forEach(log => {
                    debugHTML += log + '\n';
                });
                debugHTML += '</div></div>';
                
                statusDiv.innerHTML = debugHTML;
            }
        }

        function analyserTexte(texte, categorie) {
            const proto = { 
                competition: '',
                programme: '',
                facteur: 2.67,
                equipes: [] 
            };
            
            const lines = texte.split('\n');
            
            // D√©tecter comp√©tition et programme
            for (let line of lines) {
                if (line.includes('CUP') || line.includes('CHAMPIONSHIP') || line.includes('TROPHY') || line.includes('SYNCHRO')) {
                    if (!proto.competition) proto.competition = line.trim().substring(0, 80);
                }
                if (line.includes('SHORT PROGRAM')) proto.programme = 'PC';
                else if (line.includes('FREE SKATING') || line.includes('LONG PROGRAM')) proto.programme = 'PL';
            }
            
            // Extraire le facteur
            const factorMatch = texte.match(/Program Components?\s+Factor\s+Composition\s+([\d\.]+)/);
            if (factorMatch) proto.facteur = parseFloat(factorMatch[1]);
            
            // D√©tecter le format : "Club" ou "Nation"
            const hasClubColumn = texte.includes('Rank   Name   Club   Starting') || texte.includes('Rank Name Club Starting');
            
            window.debugLog(`üîç Format d√©tect√©: ${hasClubColumn ? 'CLUB (Australie)' : 'NATION (ISU standard)'}`);
            
            // NOUVELLE STRAT√âGIE : Trouver tous les headers avec leur position
            let headerPattern;
            
            if (hasClubColumn) {
                // Format Club : capturer UNIQUEMENT lettres/espaces dans nom+club (pas de chiffres)
                // Pattern : Rang + Nom+Club (lettres/espaces/caract√®res sp√©ciaux uniquement) + Starting + 4 scores
                headerPattern = /(\d{1,2})\s+([A-Za-z√Ä-√ø\s\(\)\-\.',]+?)\s+(\d{1,2})\s+([\d]+\.[\d]{2})\s+([\d]+\.[\d]{2})\s+([\d]+\.[\d]{2})\s+([\-\d]+\.[\d]{2})/gm;
                
                window.debugLog(`üîç Pattern Club (lettres + espaces + ponctuation, PAS de deux-points)`);
            } else {
                // Format ISU standard - nom restrictif pour ne pas capturer "Starting"
                // Le nom peut contenir: lettres, chiffres, espaces, tirets, apostrophes, parenth√®ses, points, virgules
                // MAIS on s'arr√™te avant "Starting" en limitant la capture
                // Le code club peut √™tre en majuscules, minuscules, avec tirets ou chiffres (ex: Kaari, EsJt, VG-62, TapTL, KuLS)
                headerPattern = /(\d+)\s+([A-Za-z√Ä-√ø0-9\s\(\)\-\.',]{3,40}?)\s+([A-Za-z0-9\-]{2,6})\s+\d+\s+([\d]+\.[\d]{2})\s+([\d]+\.[\d]{2})\s+([\d]+\.[\d]{2})\s+([\-\d]+\.[\d]{2})/gm;
                
                window.debugLog(`üîç Pattern ISU avec nom restrictif (3-40 caract√®res) + codes club mixtes accept√©s`);
            }
            
            const headers = [];
            let match;
            
            while ((match = headerPattern.exec(texte)) !== null) {
                if (hasClubColumn) {
                    // Pour le format club, on doit s√©parer nom et club dans le groupe captur√©
                    const fullText = match[2].trim();
                    
                    // VALIDATION : rejeter si c'est un faux header (contient des mots du vrai header)
                    if (fullText.match(/Rank|Starting|Total Segment|Total Element|Component Score/i)) {
                        window.debugLog(`‚ö†Ô∏è Rejet√© (faux header): "${fullText.substring(0, 50)}..."`);
                        continue;
                    }
                    
                    // AM√âLIORATION : D√©tecter et enlever les suffixes de clubs australiens/internationaux
                    // Pattern : [Nom √âquipe] [Ville/R√©gion optionnelle] [Type de club]
                    // Exemples :
                    // - "Ice Storm Queensland Synchronized Iceskating Club"
                    // - "Phoenix Boondall Synchronized Ice Skating Club"
                    
                    let nom = fullText;
                    let clubSuffix = '';
                    
                    // Liste des patterns de suffixes de clubs √† enlever (du plus sp√©cifique au plus g√©n√©ral)
                    // IMPORTANT : Les patterns capturent aussi la ville/r√©gion avant le type de club
                    const clubPatterns = [
                        // Formats australiens avec ville
                        /\s+[A-Z][a-z]+\s+Synchronized\s+(Iceskating|Ice\s+Skating)\s+Club$/i,  // "Queensland Synchronized Iceskating Club"
                        /\s+[A-Z][a-z]+\s+Ice\s+Skating\s+Club$/i,                               // "Boondall Ice Skating Club"
                        
                        // Formats su√©dois avec ville (1 ou 2 mots pour la ville)
                        // Exemples: "Kungsbacka Konst√•kningsklubb", "Tj√∂rns Konst√•kningsklubb", "Nacka Team√•kningsklubb"
                        /\s+[A-Z√ñ√Ñ√Ö][a-z√∂√§√•√©]+\s+Konst√•kningsklubb$/i,                           // "[Ville] Konst√•kningsklubb"
                        /\s+[A-Z√ñ√Ñ√Ö][a-z√∂√§√•√©]+\s+Team√•kningsklubb$/i,                            // "[Ville] Team√•kningsklubb"
                        
                        // Format su√©dois complexe avec plusieurs mots
                        // Exemple: "F√∂reningen Ytterby Kung√§lvs Konst√•kare" ‚Üí capture "F√∂reningen Ytterby Kung√§lvs Konst√•kare"
                        /\s+[A-Z√ñ√Ñ√Ö][a-z√∂√§√•√©]+(\s+[A-Z√ñ√Ñ√Ö][a-z√∂√§√•√©]+)+\s+Konst√•kare$/i,          // "[Mots] Konst√•kare"
                        /\s+[A-Z√ñ√Ñ√Ö][a-z√∂√§√•√©]+\s+Konst√•kare$/i,                                  // "[Ville] Konst√•kare"
                        
                        // Formats g√©n√©riques sans ville (fallback)
                        /\s+Synchronized\s+(Iceskating|Ice\s+Skating)\s+Club$/i,                 // "Synchronized Iceskating Club"
                        /\s+Ice\s+Skating\s+Club$/i,                                              // "Ice Skating Club"
                        /\s+Figure\s+Skating\s+Club$/i,                                           // "Figure Skating Club"
                        /\s+Skating\s+Club$/i,                                                    // "Skating Club"
                        /\s+Konst√•kningsklubb$/i,                                                 // "Konst√•kningsklubb" seul
                        /\s+Team√•kningsklubb$/i,                                                  // "Team√•kningsklubb" seul
                        /\s+Konst√•kare$/i                                                         // "Konst√•kare" seul
                    ];
                    
                    for (const pattern of clubPatterns) {
                        const matchClub = nom.match(pattern);
                        if (matchClub) {
                            clubSuffix = matchClub[0];
                            nom = nom.replace(pattern, '').trim();
                            window.debugLog(`üîç Suffixe de club enlev√©: "${clubSuffix.trim()}"`);
                            break;
                        }
                    }
                    
                    // Si aucun pattern trouv√©, utiliser l'ancienne m√©thode (chercher "Club", "Skating", etc.)
                    let nation;
                    if (!clubSuffix) {
                        const parts = fullText.split(/\s+/);
                        let clubStartIndex = -1;
                        
                        for (let i = parts.length - 1; i >= 0; i--) {
                            if (parts[i].match(/Club|Skating|Ice|Synchronized|Synchro|Centre|Center/i)) {
                                clubStartIndex = i;
                                while (clubStartIndex > 0 && parts[clubStartIndex - 1].match(/[A-Z√Ä-≈∏]/)) {
                                    clubStartIndex--;
                                }
                                break;
                            }
                        }
                        
                        if (clubStartIndex > 0) {
                            nom = parts.slice(0, clubStartIndex).join(' ');
                            nation = parts.slice(clubStartIndex).join(' ');
                        } else {
                            // Fallback : prendre les 2-3 premiers mots comme nom
                            nom = parts.slice(0, Math.min(3, parts.length - 1)).join(' ');
                            nation = parts.slice(Math.min(3, parts.length - 1)).join(' ');
                        }
                    } else {
                        nation = clubSuffix.trim();
                    }
                    
                    // NETTOYAGE UNIVERSEL : Enlever tout ce qui est entre parenth√®ses
                    // Ex: "Hot Shivers (Junior ISU synchronized)" ‚Üí "Hot Shivers"
                    // Ex: "Ice On Fire (Senior ISU synchronized)" ‚Üí "Ice On Fire"
                    nom = nom.replace(/\s*\([^)]*\)\s*/g, '').trim();
                    
                    window.debugLog(`üîç Header d√©tect√©: ${match[1]} - "${nom}" (${nation})`);
                    
                    headers.push({
                        index: match.index,
                        rang: parseInt(match[1]),
                        nom: nom,
                        nation: nation,
                        total: parseFloat(match[4]),
                        tech: parseFloat(match[5]),
                        pres: parseFloat(match[6])
                    });
                } else {
                    // Format ISU standard
                    let nom = match[2].trim().replace(/\s+/g, ' ');
                    
                    // NETTOYAGE UNIVERSEL : Enlever tout ce qui est entre parenth√®ses
                    nom = nom.replace(/\s*\([^)]*\)\s*/g, '').trim();
                    
                    if (nom && nom.length > 0 && nom.length < 50) {
                        headers.push({
                            index: match.index,
                            rang: parseInt(match[1]),
                            nom: nom,
                            nation: match[3],
                            total: parseFloat(match[4]),
                            tech: parseFloat(match[5]),
                            pres: parseFloat(match[6])
                        });
                        window.debugLog(`üîç Header d√©tect√©: ${match[1]} - "${nom}" (${match[3]})`);
                    }
                }
            }
            
            window.debugLog(`üìã Nombre de headers trouv√©s: ${headers.length}`);
            
            // Pour chaque header, extraire le bloc jusqu'au prochain header
            for (let i = 0; i < headers.length; i++) {
                const start = headers[i].index;
                const end = (i < headers.length - 1) ? headers[i + 1].index : texte.length;
                const blocEquipe = texte.substring(start, end);
                
                window.debugLog(`üîç √âquipe ${headers[i].rang} ${headers[i].nom}: bloc de ${blocEquipe.length} caract√®res`);
                
                try {
                    const equipe = analyserBlocEquipeV2(blocEquipe, headers[i], categorie);
                    if (equipe && equipe.elements.length > 0) {
                        proto.equipes.push(equipe);
                        window.debugLog(`‚úÖ √âquipe ${equipe.rang}: ${equipe.nom} - ${equipe.elements.length} √©l√©ments`);
                    } else {
                        window.debugLog(`‚ùå Aucun √©l√©ment pour ${headers[i].nom}`);
                    }
                } catch (e) {
                    window.debugLog(`‚ùå Erreur √©quipe ${i}: ${e.message}`);
                }
            }
            
            window.debugLog(`üìä TOTAL: ${proto.equipes.length} √©quipes extraites`);
            
            return proto;
        }
        
        function analyserBlocEquipeV2(bloc, header, categorie) {
            window.debugLog(`üîç Analyse √©quipe: ${header.nom}`);
            window.debugLog(`üîç Extrait bloc (300 premiers car): ${bloc.substring(0, 300)}`);
            
            // Appliquer la standardisation du nom si activ√©e
            const standardisation = standardiserNomEquipe(header.nom, header.nation, categorie);
            
            const eq = {
                rang: header.rang,
                nom: standardisation.nom,      // Nom standardis√© (sans code pays)
                nation: standardisation.nation, // Code pays (3 lettres)
                total: header.total,
                tech: header.tech,
                pres: header.pres,
                elements: [],
                composantes: {
                    composition: [], presentation: [], skatingSkills: [],
                    compFinal: 0, presFinal: 0, skatFinal: 0
                }
            };
            
            // EXTRACTION DES √âL√âMENTS
            let intersectionCount = 0;
            const elemPattern = /(\d+)\s+(SySp[B\d]|TrE[B\d]|NHEB?\+s[B\d]|NHE[B\d]?\+s[B\d]|I[B\d]\+pi[B\d]|ME[B\d]|GL[B\d]?|PB[B\d]|CrI[B\d]?|TwE[B\d]|Pa[B\d]|CrL[B\d]?|AL[B\d]|AB[B\d]|AW[B\d]|AC[B\d]|CrE[B\d]?|NHE)\s+(?:(F[x]?)\s+)?([\d\.]+)\s+([\-\+]?[\d\.]+)\s+((?:[\-\+]?\d+\s+)+)([\d\.]+)/g;
            
            window.debugLog(`üîç Pattern √©l√©ments avec AL, AB, CrL, Pa`);
            
            let match;
            while ((match = elemPattern.exec(bloc)) !== null) {
                const numero = parseInt(match[1]);
                const fullCode = match[2];
                const chute = match[3] ? true : false;
                const bv = parseFloat(match[4]);
                const goe = parseFloat(match[5]);
                const jugesStr = match[6];
                const scoreFinal = parseFloat(match[7]);
                
                // Extraire les GOE des juges
                const jugesGOE = [];
                const jugesParts = jugesStr.trim().split(/\s+/);
                for (let part of jugesParts) {
                    const goeVal = parseInt(part);
                    if (!isNaN(goeVal) && goeVal >= -5 && goeVal <= 5) {
                        jugesGOE.push(goeVal);
                    }
                }
                
                window.debugLog(`üîç √âl√©ment ${numero} ${fullCode}: ${jugesGOE.length} juges (${jugesGOE.join(', ')})`);
                
                if (jugesGOE.length === 0) continue;
                
                // NOUVELLE APPROCHE : Utiliser le mapping exhaustif (beaucoup plus fiable !)
                let type = elementMapping[fullCode];
                
                // Si pas trouv√© dans le mapping, utiliser le fullCode tel quel (fallback)
                if (!type) {
                    window.debugLog(`‚ö†Ô∏è √âl√©ment inconnu: ${fullCode} - utilisation du code brut`);
                    type = fullCode;
                }
                
                // CAS SP√âCIAL : NHEB+sB peut √™tre soit NHE+sB soit NHEB+s selon le programme
                // Par d√©faut on met NHE+sB (le plus commun)
                if (fullCode === "NHEB+sB" && !type) {
                    type = "NHE+sB";
                }
                
                // INTERSECTION : num√©roter les intersections (1√®re, 2√®me)
                if (type === 'I+pi') {
                    intersectionCount++;
                    type = 'I+pi (' + intersectionCount + (intersectionCount === 1 ? '√®re' : '√®me') + ')';
                }
                
                // Extraire le niveau (B = Base, 1, 2, 3, 4)
                let level = '1';
                
                if (fullCode.match(/I[B\d]\+pi/)) {
                    // Intersection : extraire BOTH niveaux (I et pi) pour afficher "x+y"
                    // Exemples : I4+pi3 ‚Üí "4+3", IB+piB ‚Üí "Base+Base", I2+pi4 ‚Üí "2+4"
                    const levelMatchI = fullCode.match(/I([B\d])\+pi/);
                    const levelMatchPi = fullCode.match(/\+pi([B\d])/);
                    
                    let levelI = '1';
                    let levelPi = '1';
                    
                    if (levelMatchI) {
                        levelI = levelMatchI[1] === 'B' ? 'Base' : levelMatchI[1];
                    }
                    if (levelMatchPi) {
                        levelPi = levelMatchPi[1] === 'B' ? 'Base' : levelMatchPi[1];
                    }
                    
                    // Afficher les 2 niveaux : "x+y"
                    level = levelI + '+' + levelPi;
                    
                } else if (fullCode.match(/NHE[B\d]?\+s[B\d]?/)) {
                    // No Hold Element : logique sp√©ciale selon la cat√©gorie
                    const typeBase = elementMapping[fullCode];
                    
                    if (typeBase === 'NHE+sB') {
                        // Step toujours Base, afficher niveau du NHE
                        const levelMatch = fullCode.match(/NHE([B\d])\+s/);
                        if (levelMatch) {
                            level = levelMatch[1] === 'B' ? 'Base' : levelMatch[1];
                        }
                    } else if (typeBase === 'NHEB+s') {
                        // NHE toujours Base, afficher niveau de la step
                        const levelMatch = fullCode.match(/\+s([B\d])/);
                        if (levelMatch) {
                            level = levelMatch[1] === 'B' ? 'Base' : levelMatch[1];
                        } else {
                            level = 'Base';
                        }
                    } else {
                        // Fallback : prendre le niveau du NHE
                        const levelMatch = fullCode.match(/NHE([B\d])?\+s/);
                        if (levelMatch && levelMatch[1]) {
                            level = levelMatch[1] === 'B' ? 'Base' : levelMatch[1];
                        } else {
                            level = 'Base';
                        }
                    }
                } else {
                    // √âl√©ments simples : prendre le dernier caract√®re
                    const levelMatch = fullCode.match(/([B\d])$/);
                    if (levelMatch) {
                        level = levelMatch[1] === 'B' ? 'Base' : levelMatch[1];
                    }
                }
                
                eq.elements.push({
                    numero: numero,
                    code: fullCode,
                    type: type,
                    niveau: level,
                    bv: bv,
                    goe: goe,
                    juges: jugesGOE,
                    score: scoreFinal,
                    chute: chute
                });
            }
            
            // EXTRACTION DES COMPOSANTES
            const compPattern = /Composition\s+[\d\.]+\s+([\d\.\s]+?)(?=Presentation|Skating|$)/s;
            const compMatch = bloc.match(compPattern);
            if (compMatch) {
                const scores = compMatch[1].trim().split(/\s+/).map(parseFloat).filter(n => !isNaN(n) && n <= 10);
                if (scores.length > 0) {
                    eq.composantes.compFinal = scores[scores.length - 1];
                    eq.composantes.composition = scores.slice(0, -1);
                }
            }
            
            const presPattern = /Presentation\s+[\d\.]+\s+([\d\.\s]+?)(?=Skating|Judges Total|$)/s;
            const presMatch = bloc.match(presPattern);
            if (presMatch) {
                const scores = presMatch[1].trim().split(/\s+/).map(parseFloat).filter(n => !isNaN(n) && n <= 10);
                if (scores.length > 0) {
                    eq.composantes.presFinal = scores[scores.length - 1];
                    eq.composantes.presentation = scores.slice(0, -1);
                }
            }
            
            const skatPattern = /Skating Skills\s+[\d\.]+\s+([\d\.\s]+?)(?=Judges Total|Deductions|$)/s;
            const skatMatch = bloc.match(skatPattern);
            if (skatMatch) {
                const scores = skatMatch[1].trim().split(/\s+/).map(parseFloat).filter(n => !isNaN(n) && n <= 10);
                if (scores.length > 0) {
                    eq.composantes.skatFinal = scores[scores.length - 1];
                    eq.composantes.skatingSkills = scores.slice(0, -1);
                }
            }
            
            return eq;
        }

        // FONCTIONS DE CALCUL DES RANGS

        function assignRanksWithTies(sortedScores) {
            const ranks = {};
            let currentRank = 1;
            for (let i = 0; i < sortedScores.length; i++) {
                const current = sortedScores[i];
                if (i > 0 && sortedScores[i].score !== sortedScores[i - 1].score) {
                    currentRank = i + 1;
                }
                ranks[current.teamName] = currentRank;
            }
            return ranks;
        }

        function getRankClass(currentRank, generalRank) {
            if (currentRank < generalRank) return 'rank-better';
            else if (currentRank > generalRank) return 'rank-worse';
            else return 'rank-equal';
        }

        function getRankClassHeader(currentRank, generalRank) {
            if (currentRank < generalRank) return 'rank-better-header';
            else if (currentRank > generalRank) return 'rank-worse-header';
            else return 'rank-equal-header';
        }

        function calculateElementRankings(protocol) {
            const elementsByType = {};
            
            protocol.equipes.forEach(team => {
                team.elements.forEach(element => {
                    const type = element.type;
                    if (!elementsByType[type]) elementsByType[type] = [];
                    elementsByType[type].push({
                        teamName: team.nom,
                        teamRank: team.rang,
                        level: getNiveauFromCode(element.code, element.type),
                        baseValue: element.bv,
                        goe: element.goe,
                        score: element.score,
                        judges: element.juges,
                        hasFall: element.chute
                    });
                });
            });
            
            const hasME = elementsByType['ME'] && elementsByType['ME'].length > 0;
            const hasPa = elementsByType['Pa'] && elementsByType['Pa'].length > 0;
            
            if (hasME && hasPa) {
                const teamsWithME = new Set(elementsByType['ME'].map(e => e.teamName));
                const teamsWithPa = new Set(elementsByType['Pa'].map(e => e.teamName));
                const teamsWithBoth = [...teamsWithME].filter(name => teamsWithPa.has(name));
                
                if (teamsWithBoth.length === 0) {
                    elementsByType['ME/Pa'] = [...(elementsByType['ME'] || []), ...(elementsByType['Pa'] || [])];
                    delete elementsByType['ME'];
                    delete elementsByType['Pa'];
                }
            }
            
            Object.keys(elementsByType).forEach(type => {
                elementsByType[type].sort((a, b) => b.score - a.score);
                elementsByType[type].forEach((item, index) => {
                    item.elementRank = index + 1;
                });
            });
            
            return elementsByType;
        }

        function calculateJudgeRanksForElement(elementData, judgeIndex) {
            const judgeScores = elementData.map(item => ({
                teamName: item.teamName,
                judgeGOE: item.judges[judgeIndex],
                score: item.baseValue + (item.baseValue * item.judges[judgeIndex] * 10 / 100)
            }));
            
            judgeScores.sort((a, b) => b.score - a.score);
            return assignRanksWithTies(judgeScores);
        }

        function calculateTechnicalRankings(protocol) {
            const rankings = protocol.equipes.map(team => ({
                teamName: team.nom,
                score: team.tech
            })).sort((a, b) => b.score - a.score);
            
            return assignRanksWithTies(rankings);
        }

        function calculateComponentsRankings(protocol) {
            const rankings = protocol.equipes.map(team => ({
                teamName: team.nom,
                score: team.pres
            })).sort((a, b) => b.score - a.score);
            
            return assignRanksWithTies(rankings);
        }

        function calculateBaseValueRankings(protocol) {
            const rankings = protocol.equipes.map(team => ({
                teamName: team.nom,
                totalBV: team.elements.reduce((sum, el) => sum + el.bv, 0)
            })).sort((a, b) => b.totalBV - a.totalBV);
            
            const ranks = {};
            rankings.forEach((item, index) => {
                ranks[item.teamName] = index + 1;
            });
            return ranks;
        }

        function calculateJudgeTechnicalRankings(protocol, judgeIndex) {
            const scores = protocol.equipes.map(team => {
                let totalScore = 0;
                team.elements.forEach(element => {
                    const judgeGOE = element.juges[judgeIndex] || 0;
                    const goePoints = (element.bv * judgeGOE * 10) / 100;
                    totalScore += element.bv + goePoints;
                });
                return {
                    teamName: team.nom,
                    score: totalScore
                };
            }).sort((a, b) => b.score - a.score);
            
            const ranks = assignRanksWithTies(scores);
            return { ranks, scores };
        }

        function calculateJudgeComponentsRankings(protocol, judgeIndex) {
            const scores = protocol.equipes.map(team => {
                const total = (team.composantes.composition[judgeIndex] || 0) + 
                             (team.composantes.presentation[judgeIndex] || 0) + 
                             (team.composantes.skatingSkills[judgeIndex] || 0);
                return {
                    teamName: team.nom,
                    score: total
                };
            }).sort((a, b) => b.score - a.score);
            
            return assignRanksWithTies(scores);
        }

        function calculateCompositionRankings(protocol) {
            const rankings = protocol.equipes.map(team => ({
                teamName: team.nom,
                score: team.composantes.compFinal || 0
            })).sort((a, b) => b.score - a.score);
            
            const ranks = {};
            rankings.forEach((item, index) => {
                ranks[item.teamName] = index + 1;
            });
            return ranks;
        }

        function calculateJudgeCompositionRankings(protocol, judgeIndex) {
            const scores = protocol.equipes.map(team => ({
                teamName: team.nom,
                score: team.composantes.composition[judgeIndex] || 0
            })).sort((a, b) => b.score - a.score);
            
            return assignRanksWithTies(scores);
        }

        function calculatePresentationRankings(protocol) {
            const rankings = protocol.equipes.map(team => ({
                teamName: team.nom,
                score: team.composantes.presFinal || 0
            })).sort((a, b) => b.score - a.score);
            
            const ranks = {};
            rankings.forEach((item, index) => {
                ranks[item.teamName] = index + 1;
            });
            return ranks;
        }

        function calculateJudgePresentationRankings(protocol, judgeIndex) {
            const scores = protocol.equipes.map(team => ({
                teamName: team.nom,
                score: team.composantes.presentation[judgeIndex] || 0
            })).sort((a, b) => b.score - a.score);
            
            return assignRanksWithTies(scores);
        }

        function calculateSkatingSkillsRankings(protocol) {
            const rankings = protocol.equipes.map(team => ({
                teamName: team.nom,
                score: team.composantes.skatFinal || 0
            })).sort((a, b) => b.score - a.score);
            
            const ranks = {};
            rankings.forEach((item, index) => {
                ranks[item.teamName] = index + 1;
            });
            return ranks;
        }

        function calculateJudgeSkatingSkillsRankings(protocol, judgeIndex) {
            const scores = protocol.equipes.map(team => ({
                teamName: team.nom,
                score: team.composantes.skatingSkills[judgeIndex] || 0
            })).sort((a, b) => b.score - a.score);
            
            return assignRanksWithTies(scores);
        }

        // EXPORT EXCEL - FONCTION PRINCIPALE

        function exporterToutExcel() {
            if (resultats.length === 0) {
                alert('Aucun r√©sultat √† exporter. Analysez d\'abord des protocoles !');
                return;
            }

            const wb = XLSX.utils.book_new();
            
            // ONGLET 1 : R√âSUM√â
            const resumeData = [
                ['R√âSUM√â G√âN√âRAL - Saison 2025-26'],
                [''],
                ['Comp√©tition', 'Cat√©gorie', 'Programme', 'Date analyse', 'Nb √©quipes']
            ];
            
            resultats.forEach(r => {
                const comp = liste.find(c => String(c.id) === String(r.compId));
                resumeData.push([
                    comp ? comp.n : 'Inconnue',
                    r.cat,
                    r.prog === 'PC' ? 'Programme Court' : 'Programme Long',
                    new Date(r.date).toLocaleDateString(),
                    r.data.equipes.length
                ]);
            });
            
            const wsResume = XLSX.utils.aoa_to_sheet(resumeData);
            wsResume['!cols'] = [{wch: 30}, {wch: 10}, {wch: 18}, {wch: 15}, {wch: 12}];
            XLSX.utils.book_append_sheet(wb, wsResume, 'R√©sum√©');
            
            // ONGLETS PAR COMP√âTITION
            resultats.forEach((res, index) => {
                const comp = liste.find(c => String(c.id) === String(res.compId));
                const sheetName = `${index + 1}. ${(comp ? comp.n : 'Comp').substring(0, 20)}`;
                
                const ws = genererFeuilleExcel(res, comp);
                XLSX.utils.book_append_sheet(wb, ws, sheetName);
            });
            
            // T√âL√âCHARGER
            const fileName = `Synchro_Saison_2025-26_${new Date().toISOString().split('T')[0]}.xlsx`;
            XLSX.writeFile(wb, fileName);
            
            alert(`‚úÖ Export Excel termin√© !\n\n${resultats.length} comp√©tition(s) export√©e(s)`);
        }

        function exporterUnResultat(resId) {
            const res = resultats.find(r => r.id === resId);
            if (!res) {
                alert('R√©sultat introuvable');
                return;
            }
            
            const comp = liste.find(c => String(c.id) === String(res.compId));
            const wb = XLSX.utils.book_new();
            const ws = genererFeuilleExcel(res, comp);
            XLSX.utils.book_append_sheet(wb, ws, 'R√©sultats');
            
            const fileName = `${comp ? comp.n.replace(/[^a-zA-Z0-9]/g, '_') : 'Competition'}_${res.cat}_${res.prog}.xlsx`;
            XLSX.writeFile(wb, fileName);
        }

        function genererFeuilleExcel(res, comp) {
            const protocol = res.data;
            const numJudges = protocol.equipes[0]?.elements[0]?.juges.length || 0;
            
            const elementRankings = calculateElementRankings(protocol);
            const technicalRankings = calculateTechnicalRankings(protocol);
            const componentsRankings = calculateComponentsRankings(protocol);
            const baseValueRankings = calculateBaseValueRankings(protocol);
            const compositionRankings = calculateCompositionRankings(protocol);
            const presentationRankings = calculatePresentationRankings(protocol);
            const skatingSkillsRankings = calculateSkatingSkillsRankings(protocol);
            
            const data = [];
            
            // EN-T√äTE
            data.push([comp ? comp.n : 'Comp√©tition', '', '', '', '', '', '']);
            data.push([`${res.cat} - ${res.prog === 'PC' ? 'Programme Court' : 'Programme Long'}`, '', '', '', '', '', '']);
            data.push([`Analys√© le ${new Date(res.date).toLocaleDateString()}`, '', '', '', '', '', '']);
            data.push(['']);
            
            // CLASSEMENT G√âN√âRAL
            data.push(['CLASSEMENT G√âN√âRAL']);
            data.push(['Rang', '√âquipe', 'Nation', 'Total', 'Technique', 'Pr√©sentation']);
            
            protocol.equipes.forEach(team => {
                data.push([
                    team.rang,
                    team.nom,
                    team.nation,
                    team.total,
                    team.tech,
                    team.pres
                ]);
            });
            
            data.push(['']);
            data.push(['']);
            
            // POUR CHAQUE √âQUIPE
            protocol.equipes.forEach(team => {
                const techRank = technicalRankings[team.nom];
                const compRank = componentsRankings[team.nom];
                const bvRank = baseValueRankings[team.nom];
                const totalBV = team.elements.reduce((sum, el) => sum + el.bv, 0);
                
                data.push([`${team.rang}. ${team.nom} (${team.nation})`]);
                data.push(['']);
                
                // √âL√âMENTS TECHNIQUES
                data.push(['√âL√âMENTS TECHNIQUES']);
                const headerElements = ['√âl√©ment', 'Niveau', 'BV', 'GOE', 'Score', 'Rang'];
                for (let j = 1; j <= numJudges; j++) {
                    headerElements.push(`J${j}`);
                }
                data.push(headerElements);
                
                team.elements.forEach(element => {
                    const elementType = element.type;
                    const niveauCalcule = getNiveauFromCode(element.code, element.type);
                    let teamElementData = elementRankings[elementType] ? 
                        elementRankings[elementType].find(e => e.teamName === team.nom && e.level === niveauCalcule) : null;
                    
                    if (!teamElementData && (elementType === 'ME' || elementType === 'Pa') && elementRankings['ME/Pa']) {
                        teamElementData = elementRankings['ME/Pa'].find(e => e.teamName === team.nom && e.level === niveauCalcule);
                    }
                    
                    const elementRank = teamElementData ? teamElementData.elementRank : '-';
                    
                    const row = [
                        `${elementType}${element.chute ? ' (CHUTE)' : ''}`,
                        `Niv ${getNiveauFromCode(element.code, element.type)}`,
                        element.bv,
                        element.goe,
                        element.score,
                        elementRank
                    ];
                    
                    element.juges.forEach(goe => row.push(goe));
                    data.push(row);
                    
                    // Rangs des juges pour cet √©l√©ment
                    const rankRow = ['Rangs juges', '', '', '', '', ''];
                    for (let j = 0; j < numJudges; j++) {
                        let elementDataForJudge = elementRankings[elementType];
                        if (!elementDataForJudge && (elementType === 'ME' || elementType === 'Pa') && elementRankings['ME/Pa']) {
                            elementDataForJudge = elementRankings['ME/Pa'];
                        }
                        
                        const judgeRanks = calculateJudgeRanksForElement(elementDataForJudge, j);
                        const judgeRank = judgeRanks[team.nom] || '-';
                        rankRow.push(judgeRank);
                    }
                    data.push(rankRow);
                });
                
                // TOTAL TECHNIQUE
                const totalTechRow = ['TOTAL TECHNIQUE', '', `BV: ${totalBV.toFixed(2)}`, '', `Score: ${team.tech.toFixed(2)}`, techRank];
                for (let j = 0; j < numJudges; j++) {
                    const judgeData = calculateJudgeTechnicalRankings(protocol, j);
                    const judgeScore = judgeData.scores.find(s => s.teamName === team.nom);
                    totalTechRow.push(judgeScore ? judgeScore.score.toFixed(2) : '-');
                }
                data.push(totalTechRow);
                
                const rankTechRow = ['Rangs Tech', '', `BV Rang: ${bvRank}`, '', '', ''];
                for (let j = 0; j < numJudges; j++) {
                    const judgeData = calculateJudgeTechnicalRankings(protocol, j);
                    const judgeRank = judgeData.ranks[team.nom] || '-';
                    rankTechRow.push(judgeRank);
                }
                data.push(rankTechRow);
                
                data.push(['']);
                
                // COMPOSANTES
                data.push(['COMPOSANTES']);
                const headerComp = ['Composante', 'Score'];
                for (let j = 1; j <= numJudges; j++) {
                    headerComp.push(`J${j}`);
                }
                data.push(headerComp);
                
                // Composition
                const compRankFinal = compositionRankings[team.nom];
                const rowComp = ['Composition', team.composantes.compFinal ? team.composantes.compFinal.toFixed(2) : '-'];
                team.composantes.composition.forEach(s => rowComp.push(s.toFixed(2)));
                data.push(rowComp);
                
                const rankCompRow = ['Rangs Comp', compRankFinal];
                for (let j = 0; j < numJudges; j++) {
                    const judgeRanks = calculateJudgeCompositionRankings(protocol, j);
                    const judgeRank = judgeRanks[team.nom] || '-';
                    rankCompRow.push(judgeRank);
                }
                data.push(rankCompRow);
                
                // Presentation
                const presRankFinal = presentationRankings[team.nom];
                const rowPres = ['Presentation', team.composantes.presFinal ? team.composantes.presFinal.toFixed(2) : '-'];
                team.composantes.presentation.forEach(s => rowPres.push(s.toFixed(2)));
                data.push(rowPres);
                
                const rankPresRow = ['Rangs Pr√©s', presRankFinal];
                for (let j = 0; j < numJudges; j++) {
                    const judgeRanks = calculateJudgePresentationRankings(protocol, j);
                    const judgeRank = judgeRanks[team.nom] || '-';
                    rankPresRow.push(judgeRank);
                }
                data.push(rankPresRow);
                
                // Skating Skills
                const skatRankFinal = skatingSkillsRankings[team.nom];
                const rowSkat = ['Skating Skills', team.composantes.skatFinal ? team.composantes.skatFinal.toFixed(2) : '-'];
                team.composantes.skatingSkills.forEach(s => rowSkat.push(s.toFixed(2)));
                data.push(rowSkat);
                
                const rankSkatRow = ['Rangs Skating', skatRankFinal];
                for (let j = 0; j < numJudges; j++) {
                    const judgeRanks = calculateJudgeSkatingSkillsRankings(protocol, j);
                    const judgeRank = judgeRanks[team.nom] || '-';
                    rankSkatRow.push(judgeRank);
                }
                data.push(rankSkatRow);
                
                // TOTAL COMPOSANTES
                const totalCompRow = ['TOTAL', team.pres.toFixed(2)];
                for (let j = 0; j < numJudges; j++) {
                    const sumBeforeFactor = (team.composantes.composition[j] || 0) + 
                                           (team.composantes.presentation[j] || 0) + 
                                           (team.composantes.skatingSkills[j] || 0);
                    const totalWithFactor = sumBeforeFactor * protocol.facteur;
                    totalCompRow.push(totalWithFactor.toFixed(2));
                }
                data.push(totalCompRow);
                
                const rankCompTotalRow = ['Rangs Pr√©s', compRank];
                for (let j = 0; j < numJudges; j++) {
                    const judgeRanks = calculateJudgeComponentsRankings(protocol, j);
                    const judgeRank = judgeRanks[team.nom] || '-';
                    rankCompTotalRow.push(judgeRank);
                }
                data.push(rankCompTotalRow);
                
                data.push(['']);
                data.push(['']);
            });
            
            const ws = XLSX.utils.aoa_to_sheet(data);
            
            // Largeurs des colonnes
            ws['!cols'] = [
                {wch: 20}, // √âl√©ment/Composante
                {wch: 10}, // Niveau/Score
                {wch: 10}, // BV
                {wch: 10}, // GOE
                {wch: 10}, // Score
                {wch: 8}   // Rang
            ];
            for (let j = 0; j < numJudges; j++) {
                ws['!cols'].push({wch: 8});
            }
            
            // Couleurs pour les rangs (optionnel - n√©cessite xlsx-style)
            // Pour l'instant, on laisse simple
            
            return ws;
        }

        // AFFICHAGE D√âTAILL√â (voirRes - identique √† v42)
        
        // ============================================
        // AFFICHAGE VUE SOMMAIRE DES R√âSULTATS
        // ============================================
        
        function afficherVueSommaire(resId) {
            const res = resultats.find(r => r.id === resId);
            if (!res) {
                alert('R√©sultat introuvable !');
                return;
            }
            
            const comp = liste.find(c => String(c.id) === String(res.compId));
            const titre = `${comp ? comp.n : 'Comp√©tition'}`;
            
            document.getElementById('modalTitle').textContent = titre;
            
            // Chercher toutes les cat√©gories disponibles pour cette comp√©tition
            const resultatsComp = resultats.filter(r => String(r.compId) === String(res.compId));
            const categoriesDisponibles = [...new Set(resultatsComp.map(r => r.cat))];
            
            let html = '<button class="btn btn-primary" onclick="ouvrirCompUpload(\'' + res.compId + '\')">‚Üê Retour √† la comp√©tition</button>';
            html += '<button class="btn" style="background:#FF9800;color:white;margin-left:10px;" onclick="ouvrirCompUpload(\'' + res.compId + '\')">üìÑ G√©rer les PDFs</button>';
            html += '<button class="btn btn-excel" onclick="exporterUnResultat(\'' + res.id + '\')" style="margin-left:10px;">üìä Excel</button>';
            
            // Onglets de cat√©gories
            if (categoriesDisponibles.length > 1) {
                html += '<div style="margin:20px 0;border-bottom:2px solid #e0e0e0;">';
                categoriesDisponibles.forEach(cat => {
                    const isActive = cat === res.cat;
                    html += `<button class="btn" style="background:${isActive ? '#667eea' : '#f5f5f5'};color:${isActive ? 'white' : '#666'};border-radius:8px 8px 0 0;margin-right:5px;" onclick="afficherCategorie('${res.compId}', '${cat}')">${cat}</button>`;
                });
                html += '</div>';
            }
            
            // Afficher le contenu pour la cat√©gorie s√©lectionn√©e
            html += genererContenuCategorie(res.compId, res.cat);
            
            document.getElementById('modalBody').innerHTML = html;
            document.getElementById('modal').classList.add('active');
        }
        
        function afficherCategorie(compId, categorie) {
            // Trouver un r√©sultat pour cette cat√©gorie
            const res = resultats.find(r => String(r.compId) === String(compId) && r.cat === categorie);
            if (res) {
                afficherVueSommaire(res.id);
            }
        }
        
        function genererContenuCategorie(compId, categorie) {
            // Chercher les 2 programmes (PC et PL) pour cette cat√©gorie
            const resultatsComp = resultats.filter(r => 
                String(r.compId) === String(compId) && 
                r.cat === categorie
            );
            
            const resPC = resultatsComp.find(r => r.prog === 'PC');
            const resPL = resultatsComp.find(r => r.prog === 'PL');
            
            let html = '';
            if (resPC && resPL) {
                html += '<div style="background:white;padding:20px;border-radius:10px;margin:20px 0;border:2px solid #667eea;">';
                html += '<h2 style="color:#1e3c72;margin-top:0;">üèÜ CLASSEMENT TOTAL (PC + PL)</h2>';
                
                // Calculer les totaux
                const totaux = [];
                const equipesPC = resPC.data.equipes;
                const equipesPL = resPL.data.equipes;
                
                equipesPC.forEach(eqPC => {
                    const nomCanonique = obtenirNomCanonique(eqPC.nom);
                    const eqPL = equipesPL.find(e => obtenirNomCanonique(e.nom) === nomCanonique);
                    
                    if (eqPL) {
                        totaux.push({
                            nom: eqPC.nom,
                            nation: eqPC.nation,
                            totalScore: eqPC.total + eqPL.total,
                            scorePC: eqPC.total,
                            scorePL: eqPL.total,
                            idPC: resPC.id,
                            idPL: resPL.id
                        });
                    }
                });
                
                totaux.sort((a, b) => b.totalScore - a.totalScore);
                
                html += '<table style="width:100%;border-collapse:collapse;margin-top:15px;">';
                html += '<thead><tr style="background:#f5f5f5;">';
                html += '<th style="padding:12px;text-align:center;border-bottom:2px solid #ddd;">#</th>';
                html += '<th style="padding:12px;text-align:left;border-bottom:2px solid #ddd;">√âquipe</th>';
                html += '<th style="padding:12px;text-align:right;border-bottom:2px solid #ddd;"><strong>Total</strong></th>';
                html += '<th style="padding:12px;text-align:center;border-bottom:2px solid #ddd;"></th>';
                html += '</tr></thead><tbody>';
                
                totaux.forEach((eq, idx) => {
                    html += '<tr style="border-bottom:1px solid #eee;">';
                    html += `<td style="padding:12px;text-align:center;font-weight:bold;font-size:1.1em;">${idx + 1}</td>`;
                    html += `<td style="padding:12px;"><strong>${eq.nom}</strong> <span style="color:#666;">(${eq.nation})</span></td>`;
                    html += `<td style="padding:12px;text-align:right;font-weight:bold;font-size:1.2em;color:#1e3c72;">${eq.totalScore.toFixed(2)}</td>`;
                    html += `<td style="padding:12px;text-align:center;"><button class="btn btn-small" style="background:#667eea;color:white;" onclick="voirDetailsEquipe('${eq.nom}', '${eq.idPC}', '${eq.idPL}')">üîç D√©tails</button></td>`;
                    html += '</tr>';
                });
                
                html += '</tbody></table></div>';
            }
            
            // PROGRAMME COURT
            if (resPC) {
                html += '<div style="background:white;padding:20px;border-radius:10px;margin:20px 0;border:2px solid #2196F3;">';
                html += '<h2 style="color:#1e3c72;margin-top:0;">üìò PROGRAMME COURT</h2>';
                
                const equipesPC = [...resPC.data.equipes].sort((a, b) => a.rang - b.rang);
                
                html += '<table style="width:100%;border-collapse:collapse;margin-top:15px;">';
                html += '<thead><tr style="background:#f5f5f5;">';
                html += '<th style="padding:12px;text-align:center;border-bottom:2px solid #ddd;">#</th>';
                html += '<th style="padding:12px;text-align:left;border-bottom:2px solid #ddd;">√âquipe</th>';
                html += '<th style="padding:12px;text-align:right;border-bottom:2px solid #ddd;">PC</th>';
                html += '<th style="padding:12px;text-align:center;border-bottom:2px solid #ddd;"></th>';
                html += '</tr></thead><tbody>';
                
                equipesPC.forEach(eq => {
                    html += '<tr style="border-bottom:1px solid #eee;">';
                    html += `<td style="padding:12px;text-align:center;font-weight:bold;">${eq.rang}</td>`;
                    html += `<td style="padding:12px;"><strong>${eq.nom}</strong> <span style="color:#666;">(${eq.nation})</span></td>`;
                    html += `<td style="padding:12px;text-align:right;font-weight:bold;font-size:1.1em;">${eq.total.toFixed(2)}</td>`;
                    html += `<td style="padding:12px;text-align:center;"><button class="btn btn-small" style="background:#667eea;color:white;" onclick="voirDetailsEquipe('${eq.nom}', '${resPC.id}', null)">üîç</button></td>`;
                    html += '</tr>';
                });
                
                html += '</tbody></table>';
                html += `<div style="margin-top:15px;"><button class="btn" style="background:#2196F3;color:white;" onclick="voirRes('${resPC.id}')">‚ñº Voir analyse d√©taill√©e compl√®te</button></div>`;
                html += '</div>';
            }
            
            // PROGRAMME LONG
            if (resPL) {
                html += '<div style="background:white;padding:20px;border-radius:10px;margin:20px 0;border:2px solid #4CAF50;">';
                html += '<h2 style="color:#1e3c72;margin-top:0;">üìó PROGRAMME LONG</h2>';
                
                const equipesPL = [...resPL.data.equipes].sort((a, b) => a.rang - b.rang);
                
                html += '<table style="width:100%;border-collapse:collapse;margin-top:15px;">';
                html += '<thead><tr style="background:#f5f5f5;">';
                html += '<th style="padding:12px;text-align:center;border-bottom:2px solid #ddd;">#</th>';
                html += '<th style="padding:12px;text-align:left;border-bottom:2px solid #ddd;">√âquipe</th>';
                html += '<th style="padding:12px;text-align:right;border-bottom:2px solid #ddd;">PL</th>';
                html += '<th style="padding:12px;text-align:center;border-bottom:2px solid #ddd;"></th>';
                html += '</tr></thead><tbody>';
                
                equipesPL.forEach(eq => {
                    html += '<tr style="border-bottom:1px solid #eee;">';
                    html += `<td style="padding:12px;text-align:center;font-weight:bold;">${eq.rang}</td>`;
                    html += `<td style="padding:12px;"><strong>${eq.nom}</strong> <span style="color:#666;">(${eq.nation})</span></td>`;
                    html += `<td style="padding:12px;text-align:right;font-weight:bold;font-size:1.1em;">${eq.total.toFixed(2)}</td>`;
                    html += `<td style="padding:12px;text-align:center;"><button class="btn btn-small" style="background:#667eea;color:white;" onclick="voirDetailsEquipe('${eq.nom}', null, '${resPL.id}')">üîç</button></td>`;
                    html += '</tr>';
                });
                
                html += '</tbody></table>';
                html += `<div style="margin-top:15px;"><button class="btn" style="background:#4CAF50;color:white;" onclick="voirRes('${resPL.id}')">‚ñº Voir analyse d√©taill√©e compl√®te</button></div>`;
                html += '</div>';
            }
            
            return html;
        }
        
        function voirDetailsEquipe(nomEquipe, idPC, idPL) {
            // D√©terminer le compId et la cat√©gorie √† partir de l'un des r√©sultats
            let compId = null;
            let categorie = null;
            
            if (idPC) {
                const resPC = resultats.find(r => r.id === idPC);
                if (resPC) {
                    compId = resPC.compId;
                    categorie = resPC.cat;
                }
            } else if (idPL) {
                const resPL = resultats.find(r => r.id === idPL);
                if (resPL) {
                    compId = resPL.compId;
                    categorie = resPL.cat;
                }
            }
            
            let html = `<button class="btn btn-primary" onclick="afficherCategorie('${compId}', '${categorie}')">‚Üê Retour au classement</button>`;
            html += `<h2 style="color:#1e3c72;margin:20px 0;">${nomEquipe}</h2>`;
            
            // Afficher le PC si existe
            if (idPC) {
                const resPC = resultats.find(r => r.id === idPC);
                if (resPC) {
                    const nomCanonique = obtenirNomCanonique(nomEquipe);
                    const equipePC = resPC.data.equipes.find(e => obtenirNomCanonique(e.nom) === nomCanonique);
                    
                    if (equipePC) {
                        html += '<div style="background:white;padding:20px;border-radius:10px;margin:20px 0;border:2px solid #2196F3;">';
                        html += '<h3 style="color:#1e3c72;margin-top:0;">üìò PROGRAMME COURT</h3>';
                        html += `<div style="margin-bottom:20px;"><strong>Score Total:</strong> ${equipePC.total.toFixed(2)} | <strong>Rang:</strong> ${equipePC.rang}</div>`;
                        
                        // Tableau des √©l√©ments
                        html += '<h4>√âl√©ments Techniques</h4>';
                        html += '<table style="width:100%;border-collapse:collapse;"><thead><tr style="background:#f5f5f5;">';
                        html += '<th style="padding:8px;border:1px solid #ddd;">#</th>';
                        html += '<th style="padding:8px;border:1px solid #ddd;">√âl√©ment</th>';
                        html += '<th style="padding:8px;border:1px solid #ddd;">BV</th>';
                        html += '<th style="padding:8px;border:1px solid #ddd;">GOE</th>';
                        html += '<th style="padding:8px;border:1px solid #ddd;">Score</th>';
                        
                        const nbJuges = equipePC.elements[0]?.juges.length || 0;
                        for (let j = 1; j <= nbJuges; j++) {
                            html += `<th style="padding:8px;border:1px solid #ddd;">J${j}</th>`;
                        }
                        html += '</tr></thead><tbody>';
                        
                        equipePC.elements.forEach((el, idx) => {
                            html += '<tr>';
                            html += `<td style="padding:8px;border:1px solid #ddd;">${idx + 1}</td>`;
                            html += `<td style="padding:8px;border:1px solid #ddd;"><strong>${el.type}${el.niveau}</strong>${el.chute ? ' <span style="background:#f44336;color:white;padding:2px 6px;border-radius:4px;font-size:0.75em;">F</span>' : ''}</td>`;
                            html += `<td style="padding:8px;border:1px solid #ddd;">${el.bv.toFixed(2)}</td>`;
                            html += `<td style="padding:8px;border:1px solid #ddd;color:${el.goe >= 0 ? '#4caf50' : '#f44336'};">${el.goe >= 0 ? '+' : ''}${el.goe.toFixed(2)}</td>`;
                            html += `<td style="padding:8px;border:1px solid #ddd;"><strong>${el.score.toFixed(2)}</strong></td>`;
                            
                            el.juges.forEach(j => {
                                html += `<td style="padding:8px;border:1px solid #ddd;color:${j > 0 ? '#4caf50' : (j < 0 ? '#f44336' : '#666')};">${j > 0 ? '+' : ''}${j}</td>`;
                            });
                            html += '</tr>';
                        });
                        
                        html += `<tr style="background:#f5f5f5;font-weight:bold;">`;
                        html += `<td colspan="2" style="padding:8px;border:1px solid #ddd;">TOTAL TECHNIQUE</td>`;
                        html += `<td colspan="${3 + nbJuges}" style="padding:8px;border:1px solid #ddd;text-align:right;">${equipePC.tech.toFixed(2)}</td>`;
                        html += '</tr></tbody></table>';
                        
                        // Composantes
                        html += '<h4 style="margin-top:20px;">Composantes de Programme</h4>';
                        html += '<table style="width:100%;border-collapse:collapse;"><thead><tr style="background:#f5f5f5;">';
                        html += '<th style="padding:8px;border:1px solid #ddd;">Composante</th>';
                        html += '<th style="padding:8px;border:1px solid #ddd;">Score Final</th>';
                        for (let j = 1; j <= nbJuges; j++) {
                            html += `<th style="padding:8px;border:1px solid #ddd;">J${j}</th>`;
                        }
                        html += '</tr></thead><tbody>';
                        
                        html += '<tr>';
                        html += '<td style="padding:8px;border:1px solid #ddd;">Composition</td>';
                        html += `<td style="padding:8px;border:1px solid #ddd;"><strong>${equipePC.composantes.compFinal.toFixed(2)}</strong></td>`;
                        equipePC.composantes.composition.forEach(s => {
                            html += `<td style="padding:8px;border:1px solid #ddd;">${s.toFixed(2)}</td>`;
                        });
                        html += '</tr>';
                        
                        html += '<tr>';
                        html += '<td style="padding:8px;border:1px solid #ddd;">Presentation</td>';
                        html += `<td style="padding:8px;border:1px solid #ddd;"><strong>${equipePC.composantes.presFinal.toFixed(2)}</strong></td>`;
                        equipePC.composantes.presentation.forEach(s => {
                            html += `<td style="padding:8px;border:1px solid #ddd;">${s.toFixed(2)}</td>`;
                        });
                        html += '</tr>';
                        
                        html += '<tr>';
                        html += '<td style="padding:8px;border:1px solid #ddd;">Skating Skills</td>';
                        html += `<td style="padding:8px;border:1px solid #ddd;"><strong>${equipePC.composantes.skatFinal.toFixed(2)}</strong></td>`;
                        equipePC.composantes.skatingSkills.forEach(s => {
                            html += `<td style="padding:8px;border:1px solid #ddd;">${s.toFixed(2)}</td>`;
                        });
                        html += '</tr>';
                        
                        html += `<tr style="background:#f5f5f5;font-weight:bold;">`;
                        html += `<td colspan="1" style="padding:8px;border:1px solid #ddd;">TOTAL COMPOSANTES</td>`;
                        html += `<td colspan="${1 + nbJuges}" style="padding:8px;border:1px solid #ddd;text-align:right;">${equipePC.pres.toFixed(2)}</td>`;
                        html += '</tr>';
                        
                        html += '</tbody></table></div>';
                    }
                }
            }
            
            // Afficher le PL si existe (m√™me structure)
            if (idPL) {
                const resPL = resultats.find(r => r.id === idPL);
                if (resPL) {
                    const nomCanonique = obtenirNomCanonique(nomEquipe);
                    const equipePL = resPL.data.equipes.find(e => obtenirNomCanonique(e.nom) === nomCanonique);
                    
                    if (equipePL) {
                        html += '<div style="background:white;padding:20px;border-radius:10px;margin:20px 0;border:2px solid #4CAF50;">';
                        html += '<h3 style="color:#1e3c72;margin-top:0;">üìó PROGRAMME LONG</h3>';
                        html += `<div style="margin-bottom:20px;"><strong>Score Total:</strong> ${equipePL.total.toFixed(2)} | <strong>Rang:</strong> ${equipePL.rang}</div>`;
                        
                        // M√™me structure que PC
                        html += '<h4>√âl√©ments Techniques</h4>';
                        html += '<table style="width:100%;border-collapse:collapse;"><thead><tr style="background:#f5f5f5;">';
                        html += '<th style="padding:8px;border:1px solid #ddd;">#</th>';
                        html += '<th style="padding:8px;border:1px solid #ddd;">√âl√©ment</th>';
                        html += '<th style="padding:8px;border:1px solid #ddd;">BV</th>';
                        html += '<th style="padding:8px;border:1px solid #ddd;">GOE</th>';
                        html += '<th style="padding:8px;border:1px solid #ddd;">Score</th>';
                        
                        const nbJuges = equipePL.elements[0]?.juges.length || 0;
                        for (let j = 1; j <= nbJuges; j++) {
                            html += `<th style="padding:8px;border:1px solid #ddd;">J${j}</th>`;
                        }
                        html += '</tr></thead><tbody>';
                        
                        equipePL.elements.forEach((el, idx) => {
                            html += '<tr>';
                            html += `<td style="padding:8px;border:1px solid #ddd;">${idx + 1}</td>`;
                            html += `<td style="padding:8px;border:1px solid #ddd;"><strong>${el.type}${el.niveau}</strong>${el.chute ? ' <span style="background:#f44336;color:white;padding:2px 6px;border-radius:4px;font-size:0.75em;">F</span>' : ''}</td>`;
                            html += `<td style="padding:8px;border:1px solid #ddd;">${el.bv.toFixed(2)}</td>`;
                            html += `<td style="padding:8px;border:1px solid #ddd;color:${el.goe >= 0 ? '#4caf50' : '#f44336'};">${el.goe >= 0 ? '+' : ''}${el.goe.toFixed(2)}</td>`;
                            html += `<td style="padding:8px;border:1px solid #ddd;"><strong>${el.score.toFixed(2)}</strong></td>`;
                            
                            el.juges.forEach(j => {
                                html += `<td style="padding:8px;border:1px solid #ddd;color:${j > 0 ? '#4caf50' : (j < 0 ? '#f44336' : '#666')};">${j > 0 ? '+' : ''}${j}</td>`;
                            });
                            html += '</tr>';
                        });
                        
                        html += `<tr style="background:#f5f5f5;font-weight:bold;">`;
                        html += `<td colspan="2" style="padding:8px;border:1px solid #ddd;">TOTAL TECHNIQUE</td>`;
                        html += `<td colspan="${3 + nbJuges}" style="padding:8px;border:1px solid #ddd;text-align:right;">${equipePL.tech.toFixed(2)}</td>`;
                        html += '</tr></tbody></table>';
                        
                        // Composantes PL (m√™me structure)
                        html += '<h4 style="margin-top:20px;">Composantes de Programme</h4>';
                        html += '<table style="width:100%;border-collapse:collapse;"><thead><tr style="background:#f5f5f5;">';
                        html += '<th style="padding:8px;border:1px solid #ddd;">Composante</th>';
                        html += '<th style="padding:8px;border:1px solid #ddd;">Score Final</th>';
                        for (let j = 1; j <= nbJuges; j++) {
                            html += `<th style="padding:8px;border:1px solid #ddd;">J${j}</th>`;
                        }
                        html += '</tr></thead><tbody>';
                        
                        html += '<tr>';
                        html += '<td style="padding:8px;border:1px solid #ddd;">Composition</td>';
                        html += `<td style="padding:8px;border:1px solid #ddd;"><strong>${equipePL.composantes.compFinal.toFixed(2)}</strong></td>`;
                        equipePL.composantes.composition.forEach(s => {
                            html += `<td style="padding:8px;border:1px solid #ddd;">${s.toFixed(2)}</td>`;
                        });
                        html += '</tr>';
                        
                        html += '<tr>';
                        html += '<td style="padding:8px;border:1px solid #ddd;">Presentation</td>';
                        html += `<td style="padding:8px;border:1px solid #ddd;"><strong>${equipePL.composantes.presFinal.toFixed(2)}</strong></td>`;
                        equipePL.composantes.presentation.forEach(s => {
                            html += `<td style="padding:8px;border:1px solid #ddd;">${s.toFixed(2)}</td>`;
                        });
                        html += '</tr>';
                        
                        html += '<tr>';
                        html += '<td style="padding:8px;border:1px solid #ddd;">Skating Skills</td>';
                        html += `<td style="padding:8px;border:1px solid #ddd;"><strong>${equipePL.composantes.skatFinal.toFixed(2)}</strong></td>`;
                        equipePL.composantes.skatingSkills.forEach(s => {
                            html += `<td style="padding:8px;border:1px solid #ddd;">${s.toFixed(2)}</td>`;
                        });
                        html += '</tr>';
                        
                        html += `<tr style="background:#f5f5f5;font-weight:bold;">`;
                        html += `<td colspan="1" style="padding:8px;border:1px solid #ddd;">TOTAL COMPOSANTES</td>`;
                        html += `<td colspan="${1 + nbJuges}" style="padding:8px;border:1px solid #ddd;text-align:right;">${equipePL.pres.toFixed(2)}</td>`;
                        html += '</tr>';
                        
                        html += '</tbody></table></div>';
                    }
                }
            }
            
            document.getElementById('modalBody').innerHTML = html;
            document.getElementById('modal').classList.add('active');
        }
        
        function voirRes(resId) {
            const res = resultats.find(r => r.id === resId);
            if (!res) {
                alert('R√©sultat introuvable !');
                return;
            }
            
            const comp = liste.find(c => String(c.id) === String(res.compId));
            const titre = `${comp ? comp.n : 'Comp√©tition'} - ${res.cat} ${res.prog}`;
            
            document.getElementById('modalTitle').textContent = titre;
            
            const protocol = res.data;
            const elementRankings = calculateElementRankings(protocol);
            const numJudges = protocol.equipes[0]?.elements[0]?.juges.length || 0;
            const technicalRankings = calculateTechnicalRankings(protocol);
            const componentsRankings = calculateComponentsRankings(protocol);
            const baseValueRankings = calculateBaseValueRankings(protocol);
            
            const compositionRankings = calculateCompositionRankings(protocol);
            const presentationRankings = calculatePresentationRankings(protocol);
            const skatingSkillsRankings = calculateSkatingSkillsRankings(protocol);
            
            let html = '<button class="btn btn-primary" onclick="ouvrirComp(\'' + res.compId + '\')">‚Üê Retour √† la comp√©tition</button>';
            html += '<button class="btn btn-excel" onclick="exporterUnResultat(\'' + res.id + '\')" style="margin-left:10px;">üìä Exporter Excel</button>';
            html += '<div style="margin:20px 0;padding:15px;background:#e8f5e9;border-radius:8px;"><strong>‚úÖ Analyse D√©taill√©e</strong> - ' + protocol.equipes.length + ' √©quipes - ' + numJudges + ' juges</div>';
            
            protocol.equipes.forEach(team => {
                const techRank = technicalRankings[team.nom];
                const compRank = componentsRankings[team.nom];
                const bvRank = baseValueRankings[team.nom];
                const totalBV = team.elements.reduce((sum, el) => sum + el.bv, 0);
                
                const techRankHeaderClass = getRankClassHeader(techRank, team.rang);
                const compRankHeaderClass = getRankClassHeader(compRank, team.rang);
                
                html += `
                    <div class="team-section">
                        <div class="team-header-detailed">
                            <div class="team-title-detailed">${team.rang}. ${team.nom} (${team.nation})</div>
                            <div class="team-scores">
                                <div class="score-box">
                                    <div class="label">Score Total</div>
                                    <div class="value">${team.total.toFixed(2)}</div>
                                    <div class="rank">Rang: ${team.rang}</div>
                                </div>
                                <div class="score-box">
                                    <div class="label">Score Technique</div>
                                    <div class="value">${team.tech.toFixed(2)}</div>
                                    <div class="rank ${techRankHeaderClass}">Rang: ${techRank}</div>
                                </div>
                                <div class="score-box">
                                    <div class="label">Score Pr√©sentation</div>
                                    <div class="value">${team.pres.toFixed(2)}</div>
                                    <div class="rank ${compRankHeaderClass}">Rang: ${compRank}</div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="section-title">üéØ √âl√©ments Techniques</div>
                        <table>
                            <thead>
                                <tr>
                                    <th class="text-left">√âl√©ment</th>
                                    <th>Niveau</th>
                                    <th>BV</th>
                                    <th>GOE</th>
                                    <th>Score</th>
                                    <th>Rang</th>
                `;
                
                for (let j = 1; j <= numJudges; j++) {
                    html += `<th>J${j}</th>`;
                }
                
                html += `</tr></thead><tbody>`;
                
                team.elements.forEach(element => {
                    const elementType = element.type;
                    const niveauCalcule = getNiveauFromCode(element.code, element.type);
                    let teamElementData = elementRankings[elementType] ? 
                        elementRankings[elementType].find(e => e.teamName === team.nom && e.level === niveauCalcule) : null;
                    
                    if (!teamElementData && (elementType === 'ME' || elementType === 'Pa') && elementRankings['ME/Pa']) {
                        teamElementData = elementRankings['ME/Pa'].find(e => e.teamName === team.nom && e.level === niveauCalcule);
                    }
                    
                    const elementRank = teamElementData ? teamElementData.elementRank : '-';
                    const rankClass = elementRank <= 3 && elementRank !== '-' ? `rank-${elementRank}` : '';
                    
                    html += `
                        <tr class="element-row ${rankClass}">
                            <td class="text-left">
                                <span class="element-code">${elementType}</span>
                                ${element.chute ? '<span class="fall-badge">CHUTE</span>' : ''}
                            </td>
                            <td><span class="level-badge">Niv ${getNiveauFromCode(element.code, element.type)}</span></td>
                            <td class="number">${element.bv.toFixed(2)}</td>
                            <td class="number ${element.goe >= 0 ? 'positive' : 'negative'}">
                                ${element.goe >= 0 ? '+' : ''}${element.goe.toFixed(2)}
                            </td>
                            <td class="number"><strong>${element.score.toFixed(2)}</strong></td>
                            <td><span class="rank-badge ${elementRank <= 3 && elementRank !== '-' ? 'rank-'+elementRank : ''}">${elementRank}</span></td>
                    `;
                    
                    element.juges.forEach(judgeGOE => {
                        const goeClass = judgeGOE > 0 ? 'positive' : (judgeGOE < 0 ? 'negative' : 'goe-zero');
                        const goeSign = judgeGOE > 0 ? '+' : '';
                        html += `<td class="number ${goeClass}">${goeSign}${judgeGOE}</td>`;
                    });
                    
                    html += `</tr>`;
                    
                    html += `<tr class="judge-rank-row"><td class="text-left" colspan="6" style="text-align: left; padding-left: 20px;">Rangs des juges :</td>`;
                    
                    for (let j = 0; j < numJudges; j++) {
                        let elementDataForJudge = elementRankings[elementType];
                        if (!elementDataForJudge && (elementType === 'ME' || elementType === 'Pa') && elementRankings['ME/Pa']) {
                            elementDataForJudge = elementRankings['ME/Pa'];
                        }
                        
                        const judgeRanks = calculateJudgeRanksForElement(elementDataForJudge, j);
                        const judgeRank = judgeRanks[team.nom] || '-';
                        const rankCompClass = (judgeRank !== '-') ? getRankClass(judgeRank, team.rang) : '';
                        html += `<td class="${rankCompClass}">${judgeRank}</td>`;
                    }
                    
                    html += `</tr>`;
                });
                
                html += `<tr class="total-row">
                    <td class="text-left">TOTAL TECHNIQUE</td>
                    <td colspan="2" class="number"><strong>BV: ${totalBV.toFixed(2)}</strong></td>
                    <td colspan="2" class="number"><strong>Score: ${team.tech.toFixed(2)}</strong></td>
                    <td><span class="rank-badge">${techRank}</span></td>
                `;
                
                for (let j = 0; j < numJudges; j++) {
                    const judgeData = calculateJudgeTechnicalRankings(protocol, j);
                    const judgeScore = judgeData.scores.find(s => s.teamName === team.nom);
                    html += `<td class="number"><strong>${judgeScore ? judgeScore.score.toFixed(2) : '-'}</strong></td>`;
                }
                html += `</tr>`;
                
                html += `<tr class="rank-row">
                    <td class="text-left">Rangs Technique</td>
                    <td colspan="2">BV Rang: ${bvRank}</td>
                    <td colspan="3"></td>
                `;
                
                for (let j = 0; j < numJudges; j++) {
                    const judgeData = calculateJudgeTechnicalRankings(protocol, j);
                    const judgeRank = judgeData.ranks[team.nom] || '-';
                    const rankCompClass = (judgeRank !== '-') ? getRankClass(judgeRank, team.rang) : '';
                    html += `<td class="${rankCompClass}"><strong>${judgeRank}</strong></td>`;
                }
                html += `</tr>`;
                
                html += `</tbody></table>`;
                
                html += `
                    <div class="section-title">üé® Composantes de Programme</div>
                    <table>
                        <thead>
                            <tr>
                                <th class="text-left">Composante</th>
                                <th>Score</th>
                `;
                
                for (let j = 1; j <= numJudges; j++) {
                    html += `<th>J${j}</th>`;
                }
                
                html += `</tr></thead><tbody>`;
                
                const compRankFinal = compositionRankings[team.nom];
                const compRankClass = getRankClass(compRankFinal, team.rang);
                html += `<tr><td class="text-left">Composition</td><td class="number"><strong>${team.composantes.compFinal ? team.composantes.compFinal.toFixed(2) : '-'}</strong></td>`;
                team.composantes.composition.forEach(score => {
                    html += `<td class="number">${score.toFixed(2)}</td>`;
                });
                html += `</tr>`;
                
                html += `<tr class="judge-rank-row"><td class="text-left" colspan="1" style="text-align: left; padding-left: 20px;">Rangs Comp.:</td><td class="${compRankClass}">${compRankFinal}</td>`;
                for (let j = 0; j < numJudges; j++) {
                    const judgeRanks = calculateJudgeCompositionRankings(protocol, j);
                    const judgeRank = judgeRanks[team.nom] || '-';
                    const rankCompClass = (judgeRank !== '-') ? getRankClass(judgeRank, team.rang) : '';
                    html += `<td class="${rankCompClass}">${judgeRank}</td>`;
                }
                html += `</tr>`;
                
                const presRankFinal = presentationRankings[team.nom];
                const presRankClass = getRankClass(presRankFinal, team.rang);
                html += `<tr><td class="text-left">Presentation</td><td class="number"><strong>${team.composantes.presFinal ? team.composantes.presFinal.toFixed(2) : '-'}</strong></td>`;
                team.composantes.presentation.forEach(score => {
                    html += `<td class="number">${score.toFixed(2)}</td>`;
                });
                html += `</tr>`;
                
                html += `<tr class="judge-rank-row"><td class="text-left" colspan="1" style="text-align: left; padding-left: 20px;">Rangs Pr√©s.:</td><td class="${presRankClass}">${presRankFinal}</td>`;
                for (let j = 0; j < numJudges; j++) {
                    const judgeRanks = calculateJudgePresentationRankings(protocol, j);
                    const judgeRank = judgeRanks[team.nom] || '-';
                    const rankCompClass = (judgeRank !== '-') ? getRankClass(judgeRank, team.rang) : '';
                    html += `<td class="${rankCompClass}">${judgeRank}</td>`;
                }
                html += `</tr>`;
                
                const skatRankFinal = skatingSkillsRankings[team.nom];
                const skatRankClass = getRankClass(skatRankFinal, team.rang);
                html += `<tr><td class="text-left">Skating Skills</td><td class="number"><strong>${team.composantes.skatFinal ? team.composantes.skatFinal.toFixed(2) : '-'}</strong></td>`;
                team.composantes.skatingSkills.forEach(score => {
                    html += `<td class="number">${score.toFixed(2)}</td>`;
                });
                html += `</tr>`;
                
                html += `<tr class="judge-rank-row"><td class="text-left" colspan="1" style="text-align: left; padding-left: 20px;">Rangs Skating:</td><td class="${skatRankClass}">${skatRankFinal}</td>`;
                for (let j = 0; j < numJudges; j++) {
                    const judgeRanks = calculateJudgeSkatingSkillsRankings(protocol, j);
                    const judgeRank = judgeRanks[team.nom] || '-';
                    const rankCompClass = (judgeRank !== '-') ? getRankClass(judgeRank, team.rang) : '';
                    html += `<td class="${rankCompClass}">${judgeRank}</td>`;
                }
                html += `</tr>`;
                
                html += `<tr class="total-row"><td class="text-left">TOTAL</td><td class="number"><strong>${team.pres.toFixed(2)}</strong></td>`;
                for (let j = 0; j < numJudges; j++) {
                    const sumBeforeFactor = (team.composantes.composition[j] || 0) + 
                                           (team.composantes.presentation[j] || 0) + 
                                           (team.composantes.skatingSkills[j] || 0);
                    const totalWithFactor = sumBeforeFactor * protocol.facteur;
                    html += `<td class="number"><strong>${totalWithFactor.toFixed(2)}</strong></td>`;
                }
                html += `</tr>`;
                
                const compRankClass2 = getRankClass(compRank, team.rang);
                html += `<tr class="rank-row"><td class="text-left">Rangs Pr√©sentation</td><td class="${compRankClass2}"><strong>${compRank}</strong></td>`;
                for (let j = 0; j < numJudges; j++) {
                    const judgeRanks = calculateJudgeComponentsRankings(protocol, j);
                    const judgeRank = judgeRanks[team.nom] || '-';
                    const rankCompClass = (judgeRank !== '-') ? getRankClass(judgeRank, team.rang) : '';
                    html += `<td class="${rankCompClass}"><strong>${judgeRank}</strong></td>`;
                }
                html += `</tr>`;
                
                html += `</tbody></table></div>`;
            });
            
            document.getElementById('modalBody').innerHTML = html;
        }
        
        // ============================================
        // NORMALISATION DES NOMS D'√âQUIPES
        // ============================================
        
        function normaliserNomEquipe(nom, nation) {
            let nomNormalise = nom.trim();
            
            // Retirer le code nation/club √† la fin si pr√©sent
            const suffixesARetirer = [
                nation, // Le code nation lui-m√™me
                /\b(Senior|Junior|Intermediate|Novice|Advanced Novice|Basic Novice)\b/gi,
                /\b\d{1,2}\b$/, // Num√©ros √† la fin (1, 2, etc.)
                /\b[A-Z]{2,6}\b$/, // Codes pays/clubs √† la fin
                /\-\s*(Senior|Junior|PC|PL|SP|FS)$/i // Suffixes avec tiret
            ];
            
            for (let pattern of suffixesARetirer) {
                if (typeof pattern === 'string') {
                    const regex = new RegExp('\\s+' + pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '$', 'i');
                    nomNormalise = nomNormalise.replace(regex, '');
                } else {
                    nomNormalise = nomNormalise.replace(pattern, '');
                }
            }
            
            nomNormalise = nomNormalise.replace(/\s+/g, ' ').trim();
            return nomNormalise;
        }
        
        function calculerSimilarite(str1, str2) {
            // Nettoyer UNIQUEMENT les cat√©gories entre parenth√®ses avant comparaison
            const nettoyerCategories = (str) => {
                let clean = str;
                // Retirer UNIQUEMENT les cat√©gories ISU synchronized entre parenth√®ses
                clean = clean.replace(/\s*\((Senior|Junior|Intermediate|Novice|Advanced Novice|Basic Novice)\s+ISU\s+synchronized\)/gi, '');
                clean = clean.replace(/\s*\((Senior|Junior|Intermediate|Novice)\s+synchronized\)/gi, '');
                return clean.trim().toLowerCase();
            };
            
            const s1 = nettoyerCategories(str1);
            const s2 = nettoyerCategories(str2);
            
            if (s1 === s2) return 100;
            
            const len1 = s1.length;
            const len2 = s2.length;
            
            if (len1 === 0) return len2 === 0 ? 100 : 0;
            if (len2 === 0) return 0;
            
            const matrix = [];
            for (let i = 0; i <= len2; i++) {
                matrix[i] = [i];
            }
            for (let j = 0; j <= len1; j++) {
                matrix[0][j] = j;
            }
            
            for (let i = 1; i <= len2; i++) {
                for (let j = 1; j <= len1; j++) {
                    if (s2.charAt(i - 1) === s1.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            
            const distance = matrix[len2][len1];
            const maxLen = Math.max(len1, len2);
            return Math.round((1 - distance / maxLen) * 100);
        }
        
        // ============================================
        // FONCTIONS DE COMPARAISON D'√âQUIPES
        // ============================================
        
        
        // ============================================
        // GESTION MANUELLE DES FUSIONS D'√âQUIPES
        // ============================================
        
        // Carte de fusion manuelle des √©quipes
        let equipeFusions = JSON.parse(localStorage.getItem('synchro_v2_fusions') || '{}');
        
        function sauvegarderFusions() {
            localStorage.setItem('synchro_v2_fusions', JSON.stringify(equipeFusions));
        }
        
        function obtenirNomCanonique(nomOriginal) {
            // Si une fusion manuelle existe, l'utiliser
            if (equipeFusions[nomOriginal]) {
                return equipeFusions[nomOriginal];
            }
            // Sinon retourner le nom original
            return nomOriginal;
        }
        
        
        function fusionnerEquipes(nomSource, nomCible) {
            // Fusionner nomSource vers nomCible
            equipeFusions[nomSource] = nomCible;
            sauvegarderFusions();
            
            // Rafra√Æchir tous les affichages
            afficherGestionEquipes();
            afficherComparaisons();
            afficherStatistiques();
            
            // Message de confirmation
            alert(`‚úì Fusion effectu√©e !\n\n"${nomSource}"\n‚Üí sera regroup√© avec\n"${nomCible}"`);
        }
        
        function defusionnerEquipe(nom) {
            delete equipeFusions[nom];
            sauvegarderFusions();
            
            // Rafra√Æchir les affichages
            afficherComparaisons();
            afficherStatistiques();
            afficherGestionEquipes();
        }
        
        function toggleStandardisation() {
            const checkbox = document.getElementById('standardiserCheckbox');
            standardiserNoms = checkbox.checked;
            localStorage.setItem('synchro_standardiser', standardiserNoms.toString());
            
            if (standardiserNoms) {
                alert('‚úÖ Standardisation activ√©e !\n\nLes nouveaux protocoles PDF seront analys√©s avec les noms au format ISU international.\n\nPour appliquer aux protocoles d√©j√† charg√©s, rechargez-les.');
            } else {
                alert('‚ÑπÔ∏è Standardisation d√©sactiv√©e.\n\nLes noms d\'√©quipes seront conserv√©s tels qu\'extraits des PDFs.');
            }
        }
        
        function afficherListeEquipes() {
            const div = document.getElementById('liste-equipes');
            const isVisible = div.style.display !== 'none';
            
            if (isVisible) {
                div.style.display = 'none';
                return;
            }
            
            // Grouper par pays
            const parPays = {};
            for (const [equipe, pays] of Object.entries(equipesInternationales)) {
                if (!parPays[pays]) parPays[pays] = [];
                parPays[pays].push(equipe);
            }
            
            // Trier les pays
            const paysTri√©s = Object.keys(parPays).sort();
            
            let html = '<div style="background:white;padding:15px;border-radius:8px;">';
            html += '<h4 style="margin-bottom:15px;">üìã Liste des √©quipes par pays</h4>';
            
            paysTri√©s.forEach(pays => {
                const equipes = parPays[pays].sort();
                html += `<div style="margin-bottom:15px;">`;
                html += `<strong style="color:#667eea;">${pays}</strong> (${equipes.length} √©quipe${equipes.length > 1 ? 's' : ''})<br>`;
                html += `<div style="margin-left:20px;margin-top:5px;font-size:0.9em;">`;
                equipes.forEach(eq => {
                    html += `${eq}<br>`;
                });
                html += '</div></div>';
            });
            
            html += '</div>';
            div.innerHTML = html;
            div.style.display = 'block';
            
            // Mettre √† jour le compteur
            document.getElementById('nbEquipesDB').textContent = Object.keys(equipesInternationales).length;
        }
        
        function ajouterEquipeManuelle() {
            const nom = prompt('Nom de l\'√©quipe (sans "Team" ni "Junior") :');
            if (!nom) return;
            
            const pays = prompt('Code pays (3 lettres, ex: FIN, USA, CAN, AUS) :');
            if (!pays || pays.length !== 3) {
                alert('‚ùå Code pays invalide. Doit √™tre 3 lettres (ex: FIN, USA, CAN)');
                return;
            }
            
            const paysUpper = pays.toUpperCase();
            
            // Ajouter √† la base
            equipesInternationales[nom.trim()] = paysUpper;
            
            // Sauvegarder dans localStorage
            const equipesPersonnalisees = JSON.parse(localStorage.getItem('synchro_equipes_custom') || '{}');
            equipesPersonnalisees[nom.trim()] = paysUpper;
            localStorage.setItem('synchro_equipes_custom', JSON.stringify(equipesPersonnalisees));
            
            alert(`‚úÖ √âquipe ajout√©e !\n\n${nom} ‚Üí ${paysUpper}\n\nCette √©quipe sera maintenant reconnue automatiquement.`);
            
            // Rafra√Æchir l'affichage si visible
            const div = document.getElementById('liste-equipes');
            if (div.style.display !== 'none') {
                afficherListeEquipes();
                afficherListeEquipes(); // Double appel pour forcer le rafra√Æchissement
            }
        }
        
        function afficherGestionEquipes() {
            // Initialiser la checkbox de standardisation
            const checkbox = document.getElementById('standardiserCheckbox');
            if (checkbox) {
                checkbox.checked = standardiserNoms;
            }
            
            // Mettre √† jour le compteur d'√©quipes
            const nbEquipesSpan = document.getElementById('nbEquipesDB');
            if (nbEquipesSpan) {
                nbEquipesSpan.textContent = Object.keys(equipesInternationales).length;
            }
            
            if (resultats.length === 0) {
                document.getElementById('gestion-equipes').innerHTML = `
                    <div class="info-box">
                        <strong>‚ÑπÔ∏è Aucune donn√©e disponible</strong><br>
                        Uploadez des protocoles PDF pour commencer.
                    </div>`;
                return;
            }
            
            // Extraire toutes les √©quipes uniques
            const nomsEquipes = new Set();
            resultats.forEach(res => {
                res.data.equipes.forEach(team => {
                    nomsEquipes.add(team.nom);
                });
            });
            
            const equipesArray = Array.from(nomsEquipes).sort();
            
            // D√©tecter les similitudes
            const suggestions = [];
            for (let i = 0; i < equipesArray.length; i++) {
                for (let j = i + 1; j < equipesArray.length; j++) {
                    const sim = calculerSimilarite(equipesArray[i], equipesArray[j]);
                    if (sim >= 70) { // Seuil de similarit√©
                        suggestions.push({
                            nom1: equipesArray[i],
                            nom2: equipesArray[j],
                            similarite: sim
                        });
                    }
                }
            }
            
            let html = '<div class="info-box">';
            html += '<strong>üîó Fusionner des √©quipes</strong><br>';
            html += 'Regroupez les variantes d\'une m√™me √©quipe (ex: "Team Helsinki Rockettes" et "Helsinki Rockettes")';
            html += '</div>';
            
            // Afficher les suggestions de fusion
            if (suggestions.length > 0) {
                html += '<div style="margin-top:20px;">';
                html += '<h4 style="color:#1e3c72;">üí° Suggestions (noms similaires d√©tect√©s)</h4>';
                
                suggestions.forEach(sug => {
                    // V√©rifier si d√©j√† fusionn√©
                    const dejaFusionne = equipeFusions[sug.nom1] === sug.nom2 || equipeFusions[sug.nom2] === sug.nom1;
                    
                    html += `<div style="padding:10px;background:#f5f5f5;border-radius:5px;margin-bottom:10px;">`;
                    html += `<div style="display:flex;align-items:center;gap:10px;">`;
                    html += `<span style="flex:1;"><strong>${sug.nom1}</strong></span>`;
                    html += `<span style="color:#999;">‚âà ${sug.similarite}%</span>`;
                    html += `<span style="flex:1;"><strong>${sug.nom2}</strong></span>`;
                    
                    if (!dejaFusionne) {
                        html += `<button class="btn btn-small btn-primary" onclick="fusionnerEquipes('${sug.nom1.replace(/'/g, "\\'")}', '${sug.nom2.replace(/'/g, "\\'")}')">‚Üí Fusionner</button>`;
                        html += `<button class="btn btn-small btn-primary" onclick="fusionnerEquipes('${sug.nom2.replace(/'/g, "\\'")}', '${sug.nom1.replace(/'/g, "\\'")}')">‚Üê Fusionner</button>`;
                    } else {
                        html += `<span style="color:#4caf50;">‚úì Fusionn√©</span>`;
                    }
                    
                    html += `</div></div>`;
                });
                
                html += '</div>';
            }
            
            // Afficher les fusions actives
            const fusionsActives = Object.keys(equipeFusions);
            if (fusionsActives.length > 0) {
                html += '<div style="margin-top:20px;">';
                html += '<h4 style="color:#1e3c72;">‚úì Fusions actives</h4>';
                
                fusionsActives.forEach(nom => {
                    const cible = equipeFusions[nom];
                    html += `<div style="padding:10px;background:#e8f5e9;border-radius:5px;margin-bottom:10px;">`;
                    html += `<div style="display:flex;align-items:center;gap:10px;">`;
                    html += `<span style="flex:1;"><strong>${nom}</strong> ‚Üí <strong>${cible}</strong></span>`;
                    html += `<button class="btn btn-small" style="background:#f44336;color:white;" onclick="defusionnerEquipe('${nom.replace(/'/g, "\\'")}')">‚úï Annuler</button>`;
                    html += `</div></div>`;
                });
                
                html += '</div>';
            }
            
            document.getElementById('gestion-equipes').innerHTML = html;
        }
        
        function extraireEquipes() {
            const equipes = new Map();
            
            resultats.forEach(res => {
                const comp = liste.find(c => String(c.id) === String(res.compId));
                
                res.data.equipes.forEach(team => {
                    // Appliquer les fusions manuelles si elles existent
                    const nomCanonique = obtenirNomCanonique(team.nom);
                    const key = nomCanonique;
                    
                    if (!equipes.has(key)) {
                        equipes.set(key, {
                            nom: nomCanonique,
                            nomsOriginaux: new Set([team.nom]),
                            nation: team.nation,
                            apparitions: []
                        });
                    }
                    
                    // Ajouter le nom original √† la liste
                    equipes.get(key).nomsOriginaux.add(team.nom);
                    
                    equipes.get(key).apparitions.push({
                        compId: res.compId,
                        compNom: comp ? comp.n : 'Inconnu',
                        compDate: comp ? comp.d : '',
                        cat: res.cat,
                        prog: res.prog,
                        rang: team.rang,
                        total: team.total,
                        tech: team.tech,
                        pres: team.pres,
                        elements: team.elements,
                        composantes: team.composantes
                    });
                });
            });
            
            return Array.from(equipes.values()).sort((a, b) => a.nom.localeCompare(b.nom));
        }

        function afficherComparaisons() {
            if (resultats.length === 0) {
                document.getElementById('tab-comparaisons').innerHTML = `
                    <div class="info-box">
                        <strong>‚ÑπÔ∏è Aucune donn√©e disponible</strong><br>
                        Analysez d'abord des protocoles pour utiliser les comparaisons.
                    </div>
                `;
                return;
            }
            
            const equipes = extraireEquipes();
            
            let html = `
                <h2 style="color: #1e3c72; margin-bottom: 20px;">üìà Comparaison d'√âquipes</h2>
                
                <div style="background: white; padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                    <h3 style="color: #667eea; margin-bottom: 15px;">Suivi de Progression</h3>
                    <p style="margin-bottom: 15px;">S√©lectionnez une √©quipe pour voir son √©volution sur la saison :</p>
                    
                    <select id="equipeSelect" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; margin-bottom: 15px;">
                        <option value="">-- Choisir une √©quipe --</option>
            `;
            
            equipes.forEach(eq => {
                html += `<option value="${eq.nom}">${eq.nom} (${eq.nation}) - ${eq.apparitions.length} comp√©tition(s)</option>`;
            });
            
            html += `
                    </select>
                    
                    <div style="margin: 15px 0;">
                        <label style="font-weight: 600; color: #1e3c72; margin-right: 20px;">Type d'analyse :</label>
                        <label style="margin-right: 15px;">
                            <input type="radio" name="typeProgression" value="total" checked onchange="afficherProgressionEquipe()">
                            Total Comp√©tition (PC + PL)
                        </label>
                        <label style="margin-right: 15px;">
                            <input type="radio" name="typeProgression" value="PC" onchange="afficherProgressionEquipe()">
                            Programme Court uniquement
                        </label>
                        <label>
                            <input type="radio" name="typeProgression" value="PL" onchange="afficherProgressionEquipe()">
                            Programme Long uniquement
                        </label>
                    </div>
                    
                    <button class="btn btn-primary" onclick="afficherProgressionEquipe()">üìä Voir la progression</button>
                </div>
                
                <div id="progressionResult"></div>
            `;
            
            document.getElementById('tab-comparaisons').innerHTML = html;
        }

        function afficherProgressionEquipe() {
            const select = document.getElementById('equipeSelect');
            const nomEquipe = select.value;
            
            if (!nomEquipe) {
                alert('S√©lectionnez une √©quipe');
                return;
            }
            
            const typeRadio = document.querySelector('input[name="typeProgression"]:checked');
            const type = typeRadio ? typeRadio.value : 'total';
            
            const equipes = extraireEquipes();
            const equipe = equipes.find(eq => eq.nom === nomEquipe);
            
            if (!equipe || equipe.apparitions.length === 0) {
                alert('Aucune donn√©e trouv√©e');
                return;
            }
            
            // Filtrer selon le type
            let apparitionsFiltrees = [];
            
            if (type === 'total') {
                // Regrouper par comp√©tition + cat√©gorie pour calculer les totaux
                const parComp = new Map();
                
                equipe.apparitions.forEach(app => {
                    const key = `${app.compId}_${app.cat}`;
                    if (!parComp.has(key)) {
                        parComp.set(key, {
                            compId: app.compId,
                            compNom: app.compNom,
                            compDate: app.compDate,
                            cat: app.cat,
                            PC: null,
                            PL: null
                        });
                    }
                    
                    if (app.prog === 'PC') {
                        parComp.get(key).PC = app;
                    } else if (app.prog === 'PL') {
                        parComp.get(key).PL = app;
                    }
                });
                
                // Calculer les totaux
                parComp.forEach(comp => {
                    if (comp.PC && comp.PL) {
                        apparitionsFiltrees.push({
                            compId: comp.compId, // IMPORTANT: n√©cessaire pour le tri chronologique
                            compNom: comp.compNom,
                            compDate: comp.compDate,
                            cat: comp.cat,
                            prog: 'Total',
                            rang: Math.min(comp.PC.rang, comp.PL.rang), // Meilleur des deux rangs
                            total: comp.PC.total + comp.PL.total,
                            tech: comp.PC.tech + comp.PL.tech,
                            pres: comp.PC.pres + comp.PL.pres
                        });
                    }
                });
            } else {
                // Filtrer PC ou PL uniquement
                apparitionsFiltrees = equipe.apparitions.filter(app => app.prog === type);
            }
            
            if (apparitionsFiltrees.length === 0) {
                document.getElementById('progressionResult').innerHTML = `
                    <div class="info-box">
                        <strong>‚ÑπÔ∏è Aucune donn√©e pour ce type</strong><br>
                        Cette √©quipe n'a pas de r√©sultats en ${type === 'PC' ? 'Programme Court' : type === 'PL' ? 'Programme Long' : 'Total Comp√©tition'}.
                    </div>
                `;
                return;
            }
            
            // Trier par ordre chronologique (ordre du calendrier)
            apparitionsFiltrees.sort((a, b) => {
                const compA = liste.find(c => String(c.id) === String(a.compId));
                const compB = liste.find(c => String(c.id) === String(b.compId));
                const indexA = liste.indexOf(compA);
                const indexB = liste.indexOf(compB);
                return indexA - indexB;
            });
            
            const typeLabel = type === 'total' ? 'Total Comp√©tition (PC + PL)' : 
                             type === 'PC' ? 'Programme Court' : 'Programme Long';
            
            let html = `
                <div style="background: white; padding: 20px; border-radius: 10px; margin-top: 20px;">
                    <h3 style="color: #1e3c72; margin-bottom: 10px;">${equipe.nom} (${equipe.nation})</h3>
                    <p style="color: #667eea; margin-bottom: 20px;"><strong>${typeLabel}</strong> - ${apparitionsFiltrees.length} comp√©tition(s)</p>
                    
                    <div style="margin-bottom: 30px; overflow-x: auto;">
                        ${genererGraphiqueProgression(apparitionsFiltrees, type)}
                    </div>
                    
                    <h4 style="color: #667eea; margin-bottom: 15px;">üìã D√©tail des Comp√©titions</h4>
                    <table style="width:100%; border-collapse: collapse;">
                        <thead style="background: #f5f5f5;">
                            <tr>
                                <th style="padding: 12px; text-align: left; border-bottom: 2px solid #667eea;">Comp√©tition</th>
                                <th style="padding: 12px; text-align: center; border-bottom: 2px solid #667eea;">Programme</th>
                                <th style="padding: 12px; text-align: center; border-bottom: 2px solid #667eea;">Rang</th>
                                <th style="padding: 12px; text-align: center; border-bottom: 2px solid #667eea;">Total</th>
                                <th style="padding: 12px; text-align: center; border-bottom: 2px solid #667eea;">Technique</th>
                                <th style="padding: 12px; text-align: center; border-bottom: 2px solid #667eea;">Pr√©sentation</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            apparitionsFiltrees.forEach((app, index) => {
                const evolTotal = index > 0 ? app.total - apparitionsFiltrees[index-1].total : 0;
                const evolClass = evolTotal > 0 ? 'positive' : (evolTotal < 0 ? 'negative' : '');
                const evolSign = evolTotal > 0 ? '+' : '';
                
                html += `
                    <tr style="border-bottom: 1px solid #f0f0f0;">
                        <td style="padding: 12px;">${app.compNom}</td>
                        <td style="padding: 12px; text-align: center;">${app.cat} ${app.prog}</td>
                        <td style="padding: 12px; text-align: center;"><strong>${app.rang}</strong></td>
                        <td style="padding: 12px; text-align: center;">
                            <strong>${app.total.toFixed(2)}</strong>
                            ${index > 0 ? `<span class="${evolClass}" style="font-size: 0.85em; margin-left: 5px;">(${evolSign}${evolTotal.toFixed(2)})</span>` : ''}
                        </td>
                        <td style="padding: 12px; text-align: center;">${app.tech.toFixed(2)}</td>
                        <td style="padding: 12px; text-align: center;">${app.pres.toFixed(2)}</td>
                    </tr>
                `;
            });
            
            html += `
                        </tbody>
                    </table>
                </div>
            `;
            
            document.getElementById('progressionResult').innerHTML = html;
        }

        function genererGraphiqueProgression(apparitions, type) {
            const width = 800;
            const height = 300;
            const padding = 50;
            
            const maxScore = Math.max(...apparitions.map(a => a.total));
            const minScore = Math.min(...apparitions.map(a => a.total));
            const scoreRange = maxScore - minScore || 10;
            const yScale = (height - 2 * padding) / scoreRange;
            const xScale = (width - 2 * padding) / Math.max(1, apparitions.length - 1);
            
            let pathTotal = '';
            let pathTech = '';
            let pathPres = '';
            
            apparitions.forEach((app, i) => {
                const x = padding + i * xScale;
                const yTotal = height - padding - (app.total - minScore) * yScale;
                const yTech = height - padding - (app.tech - minScore) * yScale;
                const yPres = height - padding - (app.pres - minScore) * yScale;
                
                pathTotal += (i === 0 ? 'M' : 'L') + x + ',' + yTotal + ' ';
                pathTech += (i === 0 ? 'M' : 'L') + x + ',' + yTech + ' ';
                pathPres += (i === 0 ? 'M' : 'L') + x + ',' + yPres + ' ';
            });
            
            const typeLabel = type === 'total' ? 'PC + PL' : type;
            
            let svg = `
                <svg width="${width}" height="${height}" style="border: 1px solid #e0e0e0; border-radius: 8px; background: white;">
                    <!-- Titre -->
                    <text x="${width/2}" y="25" text-anchor="middle" font-size="14" font-weight="bold" fill="#1e3c72">√âvolution ${typeLabel}</text>
                    
                    <!-- Grille -->
                    <line x1="${padding}" y1="${padding + 15}" x2="${padding}" y2="${height - padding}" stroke="#ccc" stroke-width="2"/>
                    <line x1="${padding}" y1="${height - padding}" x2="${width - padding}" y2="${height - padding}" stroke="#ccc" stroke-width="2"/>
                    
                    <!-- Lignes horizontales (grille) -->
                    <line x1="${padding}" y1="${padding + 15 + (height - 2*padding - 15) * 0.25}" x2="${width - padding}" y2="${padding + 15 + (height - 2*padding - 15) * 0.25}" stroke="#eee" stroke-width="1"/>
                    <line x1="${padding}" y1="${padding + 15 + (height - 2*padding - 15) * 0.5}" x2="${width - padding}" y2="${padding + 15 + (height - 2*padding - 15) * 0.5}" stroke="#eee" stroke-width="1"/>
                    <line x1="${padding}" y1="${padding + 15 + (height - 2*padding - 15) * 0.75}" x2="${width - padding}" y2="${padding + 15 + (height - 2*padding - 15) * 0.75}" stroke="#eee" stroke-width="1"/>
                    
                    <!-- Lignes -->
                    <path d="${pathTotal}" fill="none" stroke="#667eea" stroke-width="3"/>
                    <path d="${pathTech}" fill="none" stroke="#4CAF50" stroke-width="2" stroke-dasharray="5,5"/>
                    <path d="${pathPres}" fill="none" stroke="#FF9800" stroke-width="2" stroke-dasharray="5,5"/>
                    
                    <!-- Points -->
            `;
            
            apparitions.forEach((app, i) => {
                const x = padding + i * xScale;
                const yTotal = height - padding - (app.total - minScore) * yScale;
                
                svg += `<circle cx="${x}" cy="${yTotal}" r="5" fill="#667eea"/>`;
                svg += `<text x="${x}" y="${height - padding + 20}" text-anchor="middle" font-size="10" fill="#666">${app.compNom.substring(0, 10)}</text>`;
                if (type !== 'total') {
                    svg += `<text x="${x}" y="${height - padding + 33}" text-anchor="middle" font-size="9" fill="#999">${app.cat}</text>`;
                }
            });
            
            // L√©gende
            svg += `
                    <text x="${padding}" y="${padding}" font-size="12" fill="#667eea" font-weight="bold">‚Äî Total</text>
                    <text x="${padding + 100}" y="${padding}" font-size="12" fill="#4CAF50">--- Technique</text>
                    <text x="${padding + 220}" y="${padding}" font-size="12" fill="#FF9800">--- Pr√©sentation</text>
                    
                    <!-- Valeurs min/max -->
                    <text x="${padding - 40}" y="${height - padding + 5}" font-size="10" fill="#666">${minScore.toFixed(0)}</text>
                    <text x="${padding - 40}" y="${padding + 20}" font-size="10" fill="#666">${maxScore.toFixed(0)}</text>
                </svg>
            `;
            
            return svg;
        }
        
        // ============================================
        // FONCTIONS DE STATISTIQUES PAR √âL√âMENT
        // ============================================
        
        function extraireTousElements() {
            const elements = [];
            
            resultats.forEach(res => {
                const comp = liste.find(c => String(c.id) === String(res.compId));
                
                res.data.equipes.forEach(team => {
                    // Appliquer les fusions manuelles
                    const nomCanonique = obtenirNomCanonique(team.nom);
                    
                    team.elements.forEach(elem => {
                        elements.push({
                            type: elem.type,
                            niveau: getNiveauFromCode(elem.code, elem.type),
                            bv: elem.bv,
                            goe: elem.goe,
                            score: elem.score,
                            juges: elem.juges,
                            chute: elem.chute,
                            equipe: nomCanonique,
                            equipeOriginal: team.nom,
                            nation: team.nation,
                            compNom: comp ? comp.n : 'Inconnu',
                            cat: res.cat,
                            prog: res.prog
                        });
                    });
                });
            });
            
            return elements;
        }

        function afficherStatistiques() {
            if (resultats.length === 0) {
                document.getElementById('tab-statistiques').innerHTML = `
                    <div class="info-box">
                        <strong>‚ÑπÔ∏è Aucune donn√©e disponible</strong><br>
                        Analysez d'abord des protocoles pour utiliser les statistiques.
                    </div>
                `;
                return;
            }
            
            const tousElements = extraireTousElements();
            const typesElements = [...new Set(tousElements.map(e => e.type))].sort();
            
            // Cr√©er la liste des √©quipes avec nation
            const equipesMap = new Map();
            tousElements.forEach(e => {
                equipesMap.set(e.equipe, e.nation);
            });
            const equipesTriees = Array.from(equipesMap.entries()).sort((a, b) => a[0].localeCompare(b[0]));
            const equipes = [...new Set(tousElements.map(e => e.equipe))].sort();
            
            let html = `
                <h2 style="color: #1e3c72; margin-bottom: 20px;">üìä Statistiques par √âl√©ment</h2>
                
                <div style="background: white; padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                    <h3 style="color: #667eea; margin-bottom: 15px;">S√©lection de l'√©l√©ment</h3>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                        <div>
                            <label style="display: block; font-weight: 600; margin-bottom: 5px;">Type d'√©l√©ment</label>
                            <select id="statElementType" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px;">
                                <option value="">-- Choisir --</option>
            `;
            
            typesElements.forEach(type => {
                const count = tousElements.filter(e => e.type === type).length;
                html += `<option value="${type}">${type} (${count})</option>`;
            });
            
            html += `
                            </select>
                        </div>
                        
                        <div>
                            <label style="display: block; font-weight: 600; margin-bottom: 5px;">Niveau (optionnel)</label>
                            <select id="statNiveau" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px;">
                                <option value="">Tous</option>
                                <option value="Base">Base</option>
                                <option value="1">1</option>
                                <option value="2">2</option>
                                <option value="3">3</option>
                                <option value="4">4</option>
                            </select>
                        </div>
                        
                        <div>
                            <label style="display: block; font-weight: 600; margin-bottom: 5px;">Cat√©gorie</label>
                            <select id="statCategorie" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px;">
                                <option value="">Toutes</option>
                                <option value="Senior">Senior</option>
                                <option value="Junior">Junior</option>
                            </select>
                        </div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                        <div>
                            <label style="display: block; font-weight: 600; margin-bottom: 5px;">Programme</label>
                            <select id="statProgramme" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px;">
                                <option value="">Tous</option>
                                <option value="PC">Programme Court</option>
                                <option value="PL">Programme Long</option>
                            </select>
                        </div>
                        
                        <div>
                            <label style="display: block; font-weight: 600; margin-bottom: 5px;">√âquipe (optionnel)</label>
                            <select id="statEquipe" style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px;">
                                <option value="">Toutes</option>
            `;
            
            equipesTriees.forEach(([nom, nation]) => {
                html += `<option value="${nom}">${nom} (${nation})</option>`;
            });
            
            html += `
                            </select>
                        </div>
                    </div>
                    
                    <button class="btn btn-primary" onclick="analyserElement()">üìä Analyser</button>
                </div>
                
                <div id="statsResult"></div>
            `;
            
            document.getElementById('tab-statistiques').innerHTML = html;
        }
        
        // ============================================
        // CLASSEMENT DE LA SAISON
        // ============================================
        
        function afficherClassement() {
            if (resultats.length === 0) {
                document.getElementById('classement-content').innerHTML = `
                    <div class="info-box">
                        <strong>‚ÑπÔ∏è Aucune donn√©e disponible</strong><br>
                        Uploadez des protocoles PDF pour voir le classement.
                    </div>`;
                return;
            }
            
            // R√©cup√©rer les filtres
            const inclureSenior = document.getElementById('filter-senior').checked;
            const inclureJunior = document.getElementById('filter-junior').checked;
            const inclureRegional = document.getElementById('filter-regional').checked;
            const inclureNational = document.getElementById('filter-national').checked;
            const inclureChallenger = document.getElementById('filter-challenger').checked;
            const inclureInternational = document.getElementById('filter-international').checked;
            const filtreProgramme = document.querySelector('input[name="classement-programme"]:checked').value;
            const mode = document.querySelector('input[name="classement-mode"]:checked').value;
            
            // Si mode "total", calculer les totaux par comp√©tition
            if (filtreProgramme === 'total') {
                // Regrouper par √©quipe + comp√©tition
                const totauxParComp = {};
                
                resultats.forEach(res => {
                    const comp = liste.find(c => String(c.id) === String(res.compId));
                    if (!comp) return;
                    
                    // Filtre cat√©gorie
                    if (res.cat === 'Senior' && !inclureSenior) return;
                    if (res.cat === 'Junior' && !inclureJunior) return;
                    
                    const typeComp = comp.t;
                    if (typeComp === 'Regional' && !inclureRegional) return;
                    if (typeComp === 'National' && !inclureNational) return;
                    if (typeComp === 'Challenger Series' && !inclureChallenger) return;
                    if (typeComp === 'International' && !inclureInternational) return;
                    
                    res.data.equipes.forEach(team => {
                        const nomCanonique = obtenirNomCanonique(team.nom);
                        const cle = `${nomCanonique}_${res.compId}_${res.cat}`;
                        
                        if (!totauxParComp[cle]) {
                            totauxParComp[cle] = {
                                equipe: nomCanonique,
                                nation: team.nation,
                                compId: res.compId,
                                compNom: comp.n,
                                compType: typeComp,
                                cat: res.cat,
                                resultats: []
                            };
                        }
                        
                        totauxParComp[cle].resultats.push({
                            prog: res.prog,
                            rang: team.rang,
                            total: team.total,
                            tech: team.tech,
                            pres: team.pres
                        });
                    });
                });
                
                // Calculer les totaux
                const tousLesResultats = Object.values(totauxParComp).map(item => {
                    const totalScore = item.resultats.reduce((sum, r) => sum + r.total, 0);
                    const totalTech = item.resultats.reduce((sum, r) => sum + r.tech, 0);
                    const totalPres = item.resultats.reduce((sum, r) => sum + r.pres, 0);
                    const meilleurRang = Math.min(...item.resultats.map(r => r.rang));
                    const programmes = item.resultats.map(r => r.prog).join(' + ');
                    
                    return {
                        equipe: item.equipe,
                        nation: item.nation,
                        compNom: item.compNom,
                        compType: item.compType,
                        cat: item.cat,
                        prog: programmes,
                        rang: meilleurRang,
                        total: totalScore,
                        tech: totalTech,
                        pres: totalPres
                    };
                });
                
                // Appliquer le mode (meilleur/tous)
                let classement;
                if (mode === 'meilleur') {
                    const meilleursParEquipe = {};
                    tousLesResultats.forEach(r => {
                        if (!meilleursParEquipe[r.equipe] || r.total > meilleursParEquipe[r.equipe].total) {
                            meilleursParEquipe[r.equipe] = r;
                        }
                    });
                    classement = Object.values(meilleursParEquipe);
                } else {
                    classement = tousLesResultats;
                }
                
                classement.sort((a, b) => b.total - a.total);
                afficherTableauClassement(classement);
                
            } else {
                // Mode programme unique (SP ou FS)
                const tousLesResultats = [];
                let nbIgnores = 0;
                const programmesVus = new Set();
                
                resultats.forEach(res => {
                    programmesVus.add(res.prog); // Logger tous les programmes vus
                    
                    if (res.prog !== filtreProgramme) {
                        nbIgnores++;
                        return; // Filtrer par programme
                    }
                    
                    // Filtre cat√©gorie
                    if (res.cat === 'Senior' && !inclureSenior) return;
                    if (res.cat === 'Junior' && !inclureJunior) return;
                    
                    const comp = liste.find(c => String(c.id) === String(res.compId));
                    const typeComp = comp ? comp.t : 'Unknown';
                    
                    if (!comp) return;
                    if (typeComp === 'Regional' && !inclureRegional) return;
                    if (typeComp === 'National' && !inclureNational) return;
                    if (typeComp === 'Challenger Series' && !inclureChallenger) return;
                    if (typeComp === 'International' && !inclureInternational) return;
                    
                    res.data.equipes.forEach(team => {
                        const nomCanonique = obtenirNomCanonique(team.nom);
                        tousLesResultats.push({
                            equipe: nomCanonique,
                            nation: team.nation,
                            compNom: comp.n,
                            compType: typeComp,
                            cat: res.cat,
                            prog: res.prog,
                            rang: team.rang,
                            total: team.total,
                            tech: team.tech,
                            pres: team.pres
                        });
                    });
                });
                
                console.log(`üîç Programmes dans les donn√©es: ${Array.from(programmesVus).join(', ')}`);
                console.log(`üîç Filtre demand√©: "${filtreProgramme}"`);
                console.log(`üîç R√©sultats trouv√©s: ${tousLesResultats.length}, ignor√©s: ${nbIgnores}`);
                
                let classement;
                if (mode === 'meilleur') {
                    const meilleursParEquipe = {};
                    tousLesResultats.forEach(r => {
                        if (!meilleursParEquipe[r.equipe] || r.total > meilleursParEquipe[r.equipe].total) {
                            meilleursParEquipe[r.equipe] = r;
                        }
                    });
                    classement = Object.values(meilleursParEquipe);
                } else {
                    classement = tousLesResultats;
                }
                
                classement.sort((a, b) => b.total - a.total);
                afficherTableauClassement(classement);
            }
        }
        
        function afficherTableauClassement(classement) {
            // Afficher
            let html = '<div style="background:white;padding:20px;border-radius:10px;">';
            html += `<p style="color:#666;margin-bottom:20px;">üìä ${classement.length} r√©sultat(s) affich√©(s)</p>`;
            html += '<table style="width:100%;border-collapse:collapse;">';
            html += '<thead><tr style="background:#f5f5f5;text-align:left;">';
            html += '<th style="padding:12px;border-bottom:2px solid #ddd;">#</th>';
            html += '<th style="padding:12px;border-bottom:2px solid #ddd;">√âquipe</th>';
            html += '<th style="padding:12px;border-bottom:2px solid #ddd;">Nation</th>';
            html += '<th style="padding:12px;border-bottom:2px solid #ddd;">Comp√©tition</th>';
            html += '<th style="padding:12px;border-bottom:2px solid #ddd;">Cat.</th>';
            html += '<th style="padding:12px;border-bottom:2px solid #ddd;">Prog.</th>';
            html += '<th style="padding:12px;border-bottom:2px solid #ddd;text-align:center;">Rang</th>';
            html += '<th style="padding:12px;border-bottom:2px solid #ddd;text-align:right;"><strong>Total</strong></th>';
            html += '<th style="padding:12px;border-bottom:2px solid #ddd;text-align:right;">Tech</th>';
            html += '<th style="padding:12px;border-bottom:2px solid #ddd;text-align:right;">Pres</th>';
            html += '</tr></thead><tbody>';
            
            classement.forEach((r, idx) => {
                const typeCouleur = {
                    'Regional': '#9c27b0',           // Violet
                    'National': '#2196F3',           // Bleu
                    'International': '#4CAF50',      // Vert
                    'Challenger Series': '#FF9800',  // Orange
                    'Ch. du Monde': '#f44336',       // Rouge
                    'Ch. du Monde J': '#f44336'      // Rouge (Junior)
                };
                const badgeColor = typeCouleur[r.compType] || '#666';
                
                html += `<tr style="border-bottom:1px solid #eee;border-left: 4px solid ${badgeColor};">`;
                html += `<td style="padding:12px;font-weight:bold;">${idx + 1}</td>`;
                html += `<td style="padding:12px;"><strong>${r.equipe}</strong></td>`;
                html += `<td style="padding:12px;">${r.nation}</td>`;
                html += `<td style="padding:12px;"><span style="background:${badgeColor};color:white;padding:2px 8px;border-radius:8px;font-size:0.8em;">${r.compType}</span> ${r.compNom}</td>`;
                html += `<td style="padding:12px;">${r.cat}</td>`;
                html += `<td style="padding:12px;">${r.prog}</td>`;
                html += `<td style="padding:12px;text-align:center;">${r.rang}</td>`;
                html += `<td style="padding:12px;text-align:right;font-weight:bold;font-size:1.1em;">${r.total.toFixed(2)}</td>`;
                html += `<td style="padding:12px;text-align:right;">${r.tech.toFixed(2)}</td>`;
                html += `<td style="padding:12px;text-align:right;">${r.pres.toFixed(2)}</td>`;
                html += '</tr>';
            });
            
            html += '</tbody></table></div>';
            
            document.getElementById('classement-content').innerHTML = html;
        }

        function analyserElement() {
            const typeSelect = document.getElementById('statElementType').value;
            const niveauSelect = document.getElementById('statNiveau').value;
            const catSelect = document.getElementById('statCategorie').value;
            const progSelect = document.getElementById('statProgramme').value;
            const equipeSelect = document.getElementById('statEquipe').value;
            
            if (!typeSelect) {
                alert('S√©lectionnez un type d\'√©l√©ment');
                return;
            }
            
            const tousElements = extraireTousElements();
            
            // Filtrer
            let elementsFiltres = tousElements.filter(e => e.type === typeSelect);
            
            if (niveauSelect) {
                elementsFiltres = elementsFiltres.filter(e => e.niveau === niveauSelect);
            }
            if (catSelect) {
                elementsFiltres = elementsFiltres.filter(e => e.cat === catSelect);
            }
            if (progSelect) {
                elementsFiltres = elementsFiltres.filter(e => e.prog === progSelect);
            }
            if (equipeSelect) {
                elementsFiltres = elementsFiltres.filter(e => e.equipe === equipeSelect);
            }
            
            if (elementsFiltres.length === 0) {
                document.getElementById('statsResult').innerHTML = `
                    <div class="info-box">
                        <strong>‚ÑπÔ∏è Aucun √©l√©ment trouv√©</strong><br>
                        Aucun √©l√©ment ne correspond √† ces crit√®res.
                    </div>
                `;
                return;
            }
            
            // Calculer les stats
            const nbTotal = elementsFiltres.length;
            const scoreMax = Math.max(...elementsFiltres.map(e => e.score));
            const scoreMin = Math.min(...elementsFiltres.map(e => e.score));
            const scoreMoyen = elementsFiltres.reduce((sum, e) => sum + e.score, 0) / nbTotal;
            const goeMoyen = elementsFiltres.reduce((sum, e) => sum + e.goe, 0) / nbTotal;
            const bvMoyen = elementsFiltres.reduce((sum, e) => sum + e.bv, 0) / nbTotal;
            const nbChutes = elementsFiltres.filter(e => e.chute).length;
            
            // Distribution des niveaux
            const niveaux = {};
            elementsFiltres.forEach(e => {
                niveaux[e.niveau] = (niveaux[e.niveau] || 0) + 1;
            });
            
            // Distribution des GOE
            const goeDistribution = {};
            for (let i = -5; i <= 5; i++) {
                goeDistribution[i] = 0;
            }
            elementsFiltres.forEach(e => {
                e.juges.forEach(goe => {
                    if (goe >= -5 && goe <= 5) {
                        goeDistribution[goe]++;
                    }
                });
            });
            
            // Top 10
            const top10 = [...elementsFiltres].sort((a, b) => b.score - a.score).slice(0, 10);
            
            // Filtres actifs
            const filtresActifs = [];
            if (niveauSelect) filtresActifs.push(`Niveau ${niveauSelect}`);
            if (catSelect) filtresActifs.push(catSelect);
            if (progSelect) filtresActifs.push(progSelect === 'PC' ? 'Programme Court' : 'Programme Long');
            if (equipeSelect) filtresActifs.push(equipeSelect);
            
            let html = `
                <div style="background: white; padding: 20px; border-radius: 10px; margin-top: 20px;">
                    <h3 style="color: #1e3c72; margin-bottom: 10px;">Analyse : ${typeSelect}</h3>
                    ${filtresActifs.length > 0 ? `<p style="color: #667eea; margin-bottom: 20px;">Filtres : ${filtresActifs.join(', ')}</p>` : ''}
                    
                    <!-- Vue d'ensemble -->
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 30px;">
                        <div style="background: #e8eaf6; padding: 15px; border-radius: 8px;">
                            <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">Nb d'ex√©cutions</div>
                            <div style="font-size: 1.8em; font-weight: bold; color: #1e3c72;">${nbTotal}</div>
                        </div>
                        <div style="background: #e8f5e9; padding: 15px; border-radius: 8px;">
                            <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">Score moyen</div>
                            <div style="font-size: 1.8em; font-weight: bold; color: #4CAF50;">${scoreMoyen.toFixed(2)}</div>
                        </div>
                        <div style="background: #fff3e0; padding: 15px; border-radius: 8px;">
                            <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">GOE moyen</div>
                            <div style="font-size: 1.8em; font-weight: bold; color: #FF9800;">${goeMoyen >= 0 ? '+' : ''}${goeMoyen.toFixed(2)}</div>
                        </div>
                        <div style="background: #fce4ec; padding: 15px; border-radius: 8px;">
                            <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">BV moyen</div>
                            <div style="font-size: 1.8em; font-weight: bold; color: #c2185b;">${bvMoyen.toFixed(2)}</div>
                        </div>
                        <div style="background: #ffebee; padding: 15px; border-radius: 8px;">
                            <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">Chutes</div>
                            <div style="font-size: 1.8em; font-weight: bold; color: #f44336;">${nbChutes}</div>
                        </div>
                        <div style="background: #e0f2f1; padding: 15px; border-radius: 8px;">
                            <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">Meilleur score</div>
                            <div style="font-size: 1.8em; font-weight: bold; color: #00796b;">${scoreMax.toFixed(2)}</div>
                        </div>
                    </div>
                    
                    <!-- Distribution des GOE -->
                    <h4 style="color: #667eea; margin-bottom: 15px;">üìä Distribution des GOE (tous juges confondus)</h4>
                    <div style="margin-bottom: 30px;">
                        ${genererGraphiqueGOE(goeDistribution)}
                    </div>
                    
                    <!-- Distribution des niveaux -->
                    ${!niveauSelect ? `
                    <h4 style="color: #667eea; margin-bottom: 15px;">üéØ R√©partition par niveau</h4>
                    <div style="margin-bottom: 30px;">
                        ${genererGraphiqueNiveaux(niveaux, nbTotal)}
                    </div>
                    ` : ''}
                    
                    <!-- Top 10 -->
                    <h4 style="color: #667eea; margin-bottom: 15px;">üèÜ Top ${Math.min(10, elementsFiltres.length)} ${equipeSelect ? 'des ex√©cutions' : 'des meilleures ex√©cutions'}</h4>
                    <table style="width:100%; border-collapse: collapse;">
                        <thead style="background: #f5f5f5;">
                            <tr>
                                <th style="padding: 12px; text-align: center; border-bottom: 2px solid #667eea;">Rang</th>
                                <th style="padding: 12px; text-align: left; border-bottom: 2px solid #667eea;">√âquipe</th>
                                <th style="padding: 12px; text-align: left; border-bottom: 2px solid #667eea;">Comp√©tition</th>
                                <th style="padding: 12px; text-align: center; border-bottom: 2px solid #667eea;">Niveau</th>
                                <th style="padding: 12px; text-align: center; border-bottom: 2px solid #667eea;">BV</th>
                                <th style="padding: 12px; text-align: center; border-bottom: 2px solid #667eea;">GOE</th>
                                <th style="padding: 12px; text-align: center; border-bottom: 2px solid #667eea;">Score</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            top10.forEach((elem, index) => {
                const rankClass = index < 3 ? `rank-${index + 1}` : '';
                html += `
                    <tr class="${rankClass}" style="border-bottom: 1px solid #f0f0f0;">
                        <td style="padding: 12px; text-align: center;"><strong>${index + 1}</strong></td>
                        <td style="padding: 12px;">${elem.equipe} (${elem.nation})</td>
                        <td style="padding: 12px;">${elem.compNom} - ${elem.cat} ${elem.prog}</td>
                        <td style="padding: 12px; text-align: center;"><span class="level-badge">Niv ${elem.niveau}</span></td>
                        <td style="padding: 12px; text-align: center; font-family: monospace;">${elem.bv.toFixed(2)}</td>
                        <td style="padding: 12px; text-align: center; font-family: monospace; color: ${elem.goe >= 0 ? '#4caf50' : '#f44336'};">${elem.goe >= 0 ? '+' : ''}${elem.goe.toFixed(2)}</td>
                        <td style="padding: 12px; text-align: center; font-family: monospace;"><strong>${elem.score.toFixed(2)}</strong></td>
                    </tr>
                `;
            });
            
            html += `
                        </tbody>
                    </table>
                </div>
            `;
            
            document.getElementById('statsResult').innerHTML = html;
        }

        function genererGraphiqueGOE(distribution) {
            const width = 800;
            const height = 250;
            const padding = 40;
            
            const maxCount = Math.max(...Object.values(distribution));
            const yScale = (height - 2 * padding) / (maxCount || 1);
            const barWidth = (width - 2 * padding) / 11; // -5 √† +5 = 11 valeurs
            
            let svg = `
                <svg width="${width}" height="${height}" style="border: 1px solid #e0e0e0; border-radius: 8px; background: white;">
                    <!-- Titre -->
                    <text x="${width/2}" y="20" text-anchor="middle" font-size="14" font-weight="bold" fill="#1e3c72">Distribution des GOE</text>
                    
                    <!-- Axes -->
                    <line x1="${padding}" y1="${height - padding}" x2="${width - padding}" y2="${height - padding}" stroke="#ccc" stroke-width="2"/>
                    <line x1="${padding}" y1="${padding + 10}" x2="${padding}" y2="${height - padding}" stroke="#ccc" stroke-width="2"/>
                    
                    <!-- Barres -->
            `;
            
            for (let goe = -5; goe <= 5; goe++) {
                const count = distribution[goe] || 0;
                const x = padding + (goe + 5) * barWidth;
                const barHeight = count * yScale;
                const y = height - padding - barHeight;
                
                const color = goe < 0 ? '#f44336' : (goe === 0 ? '#999' : '#4CAF50');
                
                svg += `
                    <rect x="${x + 5}" y="${y}" width="${barWidth - 10}" height="${barHeight}" fill="${color}" opacity="0.8"/>
                    <text x="${x + barWidth/2}" y="${height - padding + 20}" text-anchor="middle" font-size="11" fill="#666">${goe >= 0 ? '+' : ''}${goe}</text>
                    <text x="${x + barWidth/2}" y="${y - 5}" text-anchor="middle" font-size="10" fill="#666">${count}</text>
                `;
            }
            
            svg += `</svg>`;
            return svg;
        }

        function genererGraphiqueNiveaux(niveaux, total) {
            const width = 600;
            const height = 200;
            const padding = 40;
            
            const niveauxOrdre = ['Base', '1', '2', '3', '4'];
            const niveauxPresents = niveauxOrdre.filter(n => niveaux[n]);
            
            if (niveauxPresents.length === 0) return '<p>Aucune donn√©e</p>';
            
            const barWidth = (width - 2 * padding) / niveauxPresents.length;
            const maxCount = Math.max(...Object.values(niveaux));
            const yScale = (height - 2 * padding) / (maxCount || 1);
            
            let svg = `
                <svg width="${width}" height="${height}" style="border: 1px solid #e0e0e0; border-radius: 8px; background: white;">
                    <!-- Axes -->
                    <line x1="${padding}" y1="${height - padding}" x2="${width - padding}" y2="${height - padding}" stroke="#ccc" stroke-width="2"/>
                    <line x1="${padding}" y1="${padding + 10}" x2="${padding}" y2="${height - padding}" stroke="#ccc" stroke-width="2"/>
                    
                    <!-- Barres -->
            `;
            
            niveauxPresents.forEach((niveau, index) => {
                const count = niveaux[niveau];
                const percent = ((count / total) * 100).toFixed(1);
                const x = padding + index * barWidth;
                const barHeight = count * yScale;
                const y = height - padding - barHeight;
                
                svg += `
                    <rect x="${x + 10}" y="${y}" width="${barWidth - 20}" height="${barHeight}" fill="#667eea" opacity="0.8"/>
                    <text x="${x + barWidth/2}" y="${height - padding + 20}" text-anchor="middle" font-size="12" fill="#666">Niv ${niveau}</text>
                    <text x="${x + barWidth/2}" y="${y - 5}" text-anchor="middle" font-size="10" fill="#666">${count} (${percent}%)</text>
                `;
            });
            
            svg += `</svg>`;
            return svg;
        }
        
        function telechargerPage() {
            const pageHTML = document.documentElement.outerHTML;
            const blob = new Blob([pageHTML], {type: 'text/html'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'synchro_system_v48_' + new Date().toISOString().split('T')[0] + '.html';
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function exportData() {
            const data = {
                competitions: liste,
                resultats: resultats,
                fusions: fusionsEquipes,
                date: new Date().toISOString()
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'synchro_data_' + new Date().toISOString().split('T')[0] + '.json';
            a.click();
            URL.revokeObjectURL(url);
            alert('‚úÖ Donn√©es export√©es ! Conservez ce fichier en lieu s√ªr.');
        }
        
        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!confirm('‚ö†Ô∏è ATTENTION : Importer des donn√©es remplacera TOUTES vos donn√©es actuelles. Continuer ?')) {
                event.target.value = ''; // Reset input
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // V√©rifier que le fichier contient les bonnes donn√©es
                    if (!data.competitions || !data.resultats) {
                        alert('‚ùå Fichier JSON invalide : format incorrect');
                        return;
                    }
                    
                    // Importer les donn√©es
                    liste = data.competitions || [];
                    resultats = data.resultats || [];
                    fusionsEquipes = data.fusions || [];
                    
                    // Sauvegarder dans localStorage
                    localStorage.setItem(DB_COMPS, JSON.stringify(liste));
                    localStorage.setItem(DB_RES, JSON.stringify(resultats));
                    localStorage.setItem('synchro_fusions_2025', JSON.stringify(fusionsEquipes));
                    
                    alert(`‚úÖ Donn√©es import√©es avec succ√®s !\n\nüìä ${liste.length} comp√©titions\nüìÑ ${resultats.length} r√©sultats\nüîó ${fusionsEquipes.length} fusions d'√©quipes\n\nDate de sauvegarde : ${new Date(data.date).toLocaleString()}`);
                    
                    // Recharger la page pour afficher les nouvelles donn√©es
                    location.reload();
                    
                } catch (error) {
                    console.error('Erreur import:', error);
                    alert('‚ùå Erreur lors de l\'import : ' + error.message);
                }
            };
            
            reader.readAsText(file);
            event.target.value = ''; // Reset input pour permettre de r√©-importer le m√™me fichier
        }
        
        function switchTab(tab) {
            document.getElementById('tab-calendar').style.display = tab === 'calendar' ? 'block' : 'none';
            document.getElementById('tab-classement').style.display = tab === 'classement' ? 'block' : 'none';
            document.getElementById('tab-comparaisons').style.display = tab === 'comparaisons' ? 'block' : 'none';
            document.getElementById('tab-statistiques').style.display = tab === 'statistiques' ? 'block' : 'none';
            document.getElementById('tab-settings').style.display = tab === 'settings' ? 'block' : 'none';
            
            if (tab === 'classement') {
                afficherClassement();
            } else if (tab === 'comparaisons') {
                afficherComparaisons();
            } else if (tab === 'statistiques') {
                afficherStatistiques();
            } else if (tab === 'settings') {
                afficherGestionEquipes();
            }
        }
        
        function clearData() {
            if (confirm('Effacer TOUTES les donn√©es ?')) {
                localStorage.removeItem(DB_COMPS);
                localStorage.removeItem(DB_RES);
                liste = [];
                resultats = [];
                afficher();
                alert('‚úÖ Donn√©es effac√©es !');
            }
        }
    </script>
</body>
</html>
